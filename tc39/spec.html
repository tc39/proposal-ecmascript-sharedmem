<!-- -*- indent-tabs-mode: nil -*-

     Process this file with ../format.sh to produce shmem.html.  See comments in that file.
-->
<!doctype html>
<meta charset="utf8">
<title>ECMAScript Shared Memory and Atomics</title>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<h1>ECMAScript Shared Memory and Atomics</h1>
<p> Revised: 2015-08-18 </p>

<emu-intro id="intro">
<h1>Introduction</h1>

<p> This proposal adds a simple form of shared memory to ECMAScript.  Shared memory is being exposed in the form of a new SharedArrayBuffer type; the existing TypedArrays are adapted in such a way that they can be used to create views on shared memory.  The new Atomics global object provides atomic operations on shared memory locations, including operations that can be used to create blocking synchronization primitives.  Though not a part of this specification, we intend for the role of "threads" to be played by Web Workers in web browser environments.<p>

<p> At this time the proposal adds only low-level primitives to ECMAScript; we expect the developer community to put together abstractions that are useful in specific domains. </p>

<p> The work has been driven by the following use cases: <p>

<ul>
  <li> Support for threaded code in programs written in other languages that are translated to asm.js or plain JS or a combination of the two, notably C++ but also JVM and CIL bytecode, Halide, Clojure, Rust, and similar safe languages.
  <li> Support for hand-written JS or JS+asm.js that makes use of multiprocessing facilities for select tasks, such as image processing, asset management, or game AI.
</ul>

<p> The proposal makes only very basic assumptions about the required hardware and should be broadly implementable with good performance.  A closely related API has been available in Firefox Nightly for some time. </p>

<p>This specification constitutes a restatement and formalization of an earlier work, <a href="https://docs.google.com/document/d/1NDGA_gZJ7M7w1Bh8S0AoDyEqwDdRh4uSoTPSNn77PFk/edit?usp=sharing">the spec document for which</a> also contains additional rationale, background information, discussions, implementation notes, and comments.</p>

<p> This specification is substantially complete, apart from these aspects: </p>
<ul>
  <li> The memory model is going to be refined further (for a while).
  <li> It is highly desirable to add facilities that allow conflicting shared memory operations to have defined meaning.  For example, adding Atomics.loadUnordered, Atomics.storeUnordered, and perhaps an explicit Atomics.fence operation, might be enough to allow a translation from JVM bytecodes to ECMAScript.
</ul>

<p>Changelog:</p>
<ul>
  <li> 2015-08-18 -- reformat, update to ecmarkup 1.7.
  <li> 2015-08-06 -- added sections on forward progress and clarifications and changes to worker semantics.
  <li> 2015-07-09 -- ongoing cleanup and minor bug fixing.  Restated the memory model.
  <li> 2015-07-08 -- initial translation from the original proposal.
</ul>

</emu-intro>

<emu-clause id="Overview">
  <h1>Overview (ES6 4)</h1>
  <emu-clause id="Overview.Overview">
    <h1>ECMAScript Overview (ES6 4.2)</h1>
    <p>In the third paragraph, include <b>SharedArrayBuffer</b> after <b>ArrayBuffer</b>.</p>
  </emu-clause>
  <emu-clause id="Overview.Terms">
    <h1>Terms and Definitions (ES6 4.3)</h1>
    <emu-clause id="Overview.Terms.Agent">
      <h1>Agent</h1>
      <p> The combination of an instance of an ECMAScript execution environment and the ECMAScript programs running within that environment. </p>
      <emu-note>
        <p> (Spec draft note) Plausibly this should be worded in terms of running 'jobs'. </p>
      </emu-note>
    </emu-clause>
    <emu-clause id="Overview.Terms.AgentComm">
      <h1>Agent communication</h1>
      <p> Two agents are said to be able to communicate through shared memory if there can exist a Shared Data Block that can come to be referenced from both agents, not necessarily at the same time.  (Note this does not require the agents to have overlapping lifetimes.) </p>
    </emu-clause>
    <emu-clause id="Overview.Terms.Cluster">
      <h1>Agent cluster</h1>
      <p> A maximal set of agents that are able to communicate through shared memory. </p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1>ECMAScript Data Types and Values (ES6 6)</h1>
  
  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1>ECMAScript Language Types (ES6 6.1)</h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1>The Number Type (ES6 6.1.6)</h1>
      <p>In the NOTE, include <b>SharedArrayBuffer</b> along with <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1>The Object Type (ES6 6.1.7)</h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1>Well-Known Intrinsic Objects (ES6 6.1.7.4)</h1>
        <p>In table 7, include rows for %SharedArrayBuffer% and %SharedArrayBufferPrototype% in the manner of the rows for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>
  
  <emu-clause id="DataTypesValues.SpecTypes">
    <h1>ECMAScript Specification Types (ES6 6.2)</h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1>Data blocks (ES6 6.2.6)</h1>
      <p> Insert the following paragraph after the third: </p>
      <p> A data block that resides in memory that can be referenced from multiple agents is designated a Shared Data Block. </p>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">
        <h1>CopyDataBlockBytes( toBlock, toIndex, fromBlock, fromIndex, count ) (ES6 6.2.6.2)</h1>
        <p>Modify this algorithm as follows:</p>
        <ul>
          <li> In step 1, allow also a Shared Data Block.
        </ul>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">
        <h1>CreateSharedByteDataBlock( size )</h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _size_ >= 0.
          1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a ~RangeError~ exception.
          1. Set all of the bytes of _db_ to 0.
          1. Return _db_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.SharedDataBlockID" aoid="SharedDataBlockID">
        <h1>SharedDataBlockID( block )</h1>
        <p>When the abstract operation SharedDataBlockID is called with Shared Data Block argument _block_, the following steps are taken:</p>
        <emu-alg>
          1. Let _G_ be an address-free identifier for _block_.  All agents in the same cluster have the same value for _G_ for any given _block_.
          1. Return _G_.
        </emu-alg>
        <emu-note>
          <p>The Shared Data Block ID is used by the futex mechanism and names _block_ independently of any virtual addresses it may be mapped to in any particular agent.</p>
        </emu-note>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1>Executable Code and Execution Contexts (ES6 8)</h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">
    <h1>Jobs and Job Queues (ES6 8.4)</h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1>Forward Progress Guarantees</h1>
      <p>Implementations should ensure that all unblocked jobs eventually make progress. </p>
      <emu-note>
        <p>(Spec draft note) This section may be formalized at least partly in the terms of the C++ working paper on forward progress (http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4439.pdf) or it may be left as-is.  An ES6 job is most plausibly a 'Concurrent agent' in the terms of that paper. </p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="GlobalObject">
  <h1>The Global Object (ES6 18)</h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1>Constructor Properties of the Global Object (ES6 18.3)</h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1>SharedArrayBuffer</h1>
      <p> Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1>Atomics</h1>
      <p> Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items ) 
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1>Indexed Collections (ES6 22)</h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1>TypedArray Objects (ES6 22.2)</h1>
    <emu-note>
      <p>(Spec draft notes)  This specification extends the TypedArray specification to allow TypedArrays to view SharedArrayBuffers.  There is a question whether existing TypedArray methods that create a new TypedArray on top of a new ArrayBuffer (%TypedArray%.prototype.filter, %TypedArray%.prototype.map, %TypedArray%.prototype.slice, %TypedArray%.prototype.subarray) should continue to create an ArrayBuffer even if the input buffer is a SharedArrayBuffer, or whether they should instead create a SharedArrayBuffer in that case.</p>
      <p>Additionally here is a question whether TypedArray constructors should be extended to allow them to allocate shared memory, and whether TypedArray static methods (%TypedArray%.of, %TypedArray%.from) should be extended to allow them to allocate shared memory.</p>
      <p>For the time being, I have opted not to change any of those functions: shared memory can only be created by explicitly invoking the constructor of SharedArrayBuffer (or the constructors of any user-defined subclasses of SharedArrayBuffer).</p>
    </emu-note>

    <emu-clause id="IndexedCollections.TypedArray.intrinsic">
      <h1>The %TypedArray% intrinsic object (ES6 22.2.1)</h1>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromObject">
        <h1>%TypedArray%( object ) (ES6 22.2.1.4)</h1>
        <p>This algorithm is modified as follows:</p>
        <ul>
          <li> Add the restriction on the applicability of this constructor that it does not apply if the object has a [[SharedArrayBufferData]] internal slot.
        </ul>
      </emu-clause>

      <emu-clause id="IndexedCollections.TypedArray.intrinsic.constructFromBuffer">
        <h1>%TypedArray%( buffer [ , byteOffset [ , length ] ] ) (ES6 22.2.1.5)</h1>
        <p>This algorithm is modified as follows:</p>
        <ul>
          <li>In the first paragraph, allow also an object that has a [[SharedArrayBufferData]] internal slot.
          <li>In step 1, allow also an object that has a [[SharedArrayBufferData]] internal slot.
          <li>In step 12, if IsSharedMemory(_buffer_) then let _bufferByteLength_ be the value of _buffer_'s [[SharedArrayBufferByteLength]] internal slot.
        </ul>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1>Properties of the %TypedArrayPrototype% object (ES6 22.2.3)</h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1> %TypedArray%.prototype.set( overloaded [ , offset ] ) (ES6 22.2.3.22)</h1>
        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1>%TypedArray%.prototype.set( typedArray [, offset ] ) (ES6 22.2.3.22.2)</h1>
          <p> Before step 24, insert the following algorithm:</p>
          <emu-alg>
            1. If IsSharedMemory(_srcBuffer_) is ~true~ and IsSharedMemory(_targetBuffer_) is ~true~ then:
              1. Let _srcBlock_ be _srcBuffer_'s [[SharedArrayBufferData]] internal slot
              1. Let _targetBlock_ be _targetBuffer_'s [[SharedArrayBufferData]] internal slot
              1. Let _srcId_ be SharedDataBlockID(_srcBlock_)
              1. Let _targetId_ be SharedDataBlockID(_targetBlock_)
              1. If _srcId_ = _targetId_ then let _doClone_ be ~true~, else let _doClone_ be ~false~
            1. Else, let _doClone_ be ~false~
          </emu-alg>
          <p> Then, in step 24, also choose to clone srcBuffer if _doClone_ is ~true~. </p>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1>Structured Data (ES6 24)</h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1>ArrayBuffer Objects (ES6 24.1)</h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1>Abstract Operations for ArrayBuffer (ES6 24.1.1)</h1>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.IsDetachedBuffer" aoid="IsDetachedBuffer">
        <h1>IsDetachedBuffer( arrayBuffer ) (ES6 24.1.1.2)</h1>
        <p> This algorithm is rewritten as follows: </p>
        <emu-alg>
          1. Assert: Type(_arrayBuffer_) is Object and it has an [[ArrayBufferData]] internal slot or a [[SharedArrayBufferData]] internal slot.
          1. If _arrayBuffer_ has an [[ArrayBufferData]] internal slot and _arrayBuffer_’s [[ArrayBufferData]] internal slot is null, return ~true~.
          1. Return ~false~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.CloneArrayBuffer" aoid="CloneArrayBuffer">
        <h1>CloneArrayBuffer( srcBuffer, srcByteOffset [, cloneConstructor] ) (ES6 24.1.1.4)</h1>
        <p>This algorithm is modified as follows:</p>
        <ul>
          <li> In the introductory paragraph, note that this function can take a SharedArrayBuffer as well.
          <li> In step 1, allow for a [[SharedArrayBufferData]] internal slot.
          <li> In step 4, if IsSharedMemory(_srcBuffer_) then let _srcLength_ be the value of _srcBuffer_'s [[SharedArrayBufferByteLength]] internal slot.
          <li> In step 7, if IsSharedMemory(_srcBuffer_) then let _srcBlock_ be the value of _srcBuffer_’s [[SharedArrayBufferData]] internal slot.
        </ul>
      </emu-clause>
      
      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1>GetValueFromBuffer( arrayBuffer, byteIndex, type, isLittleEndian ) (ES6 24.1.1.5)</h1>
        <p> This algorithm is modified as follows:</p>
        <ul>
          <li> The parameter _arrayBuffer_ can be an ArrayBuffer or SharedArrayBuffer.
          <li> All agents in the same cluster must compute the same value for _isLittleEndian_ if it is not present.
          <li> In step 4, if IsSharedMemory( _arrayBuffer_ ) is ~true~ then use the value of _arrayBuffer_'s [[SharedArrayBufferData]] internal slot.
        </ul>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1>SetValueInBuffer( arrayBuffer, byteIndex, type, value, isLittleEndian ) (ES6 24.1.1.6)</h1>
        <p> This algorithm is modified as follows:</p>
        <ul>
          <li> The parameter _arrayBuffer_ can be an ArrayBuffer or SharedArrayBuffer.
          <li> All agents in the same cluster must compute the same value for _isLittleEndian_ if it is not present.
          <li> In step 5, if IsSharedMemory( _arrayBuffer_ ) is ~true~ then use the value of _arrayBuffer_'s [[SharedArrayBufferData]] internal slot.
        </ul>

        <emu-note>
          <p> When SetValueInBuffer is called to set bytes in shared memory the implementation may set several bytes at a time (and that is the normal case), but it may not use read-modify-write on a larger datum, as that might introduce data races where the source program has none.  Data races are discussed in the section on the Atomics object. </p>
        </emu-note>
      </emu-clause>
      
    </emu-clause> <!-- abstract -->
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.DataView">
    <h1>DataView Objects (ES6 24.2)</h1>
    <emu-clause id="StructuredData.DataView.constructor">
      <h1>The DataView Constructor (ES6 24.2.2)</h1>
      <emu-clause id="StructuredData.DataView.constructor.detail">
        <h1>DataView( buffer [ , byteOffset [ , byteLength ] ] ) (ES6 24.2.2.1)</h1>
        <p> This algorithm is modified as follows: </p>
        <ul>
          <li> In step 3, allow also a [[SharedArrayBufferData]] internal slot.
          <li> In step 9, if IsSharedMemory(_buffer_) then let _bufferByteLength_ be the value of _buffer_'s [[SharedArrayBufferByteLength]] internal slot.
        </ul>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- DataView -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1>Abstract Operations for SharedArrayBuffer</h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1>AllocateSharedArrayBuffer( constructor, byteLength )</h1>
        <p> The abstract operation AllocateSharedArrayBuffer with arguments _constructor_ and _byteLength_ is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg>
          1. Let _obj_ be OrdinaryCreateFromConstructor(constructor, "%SharedArrayBufferPrototype%", «‍[[SharedArrayBufferData]], [[SharedArrayBufferByteLength]]» ).
          1. ReturnIfAbrupt(_obj_).
          1. Assert: _byteLength_ is a positive integer.
          1. Let block be CreateSharedByteDataBlock(_byteLength_).
          1. ReturnIfAbrupt(_block_).
          1. Set _obj_’s [[SharedArrayBufferData]] internal slot to block.
          1. Set _obj_’s [[SharedArrayBufferByteLength]] internal slot to _byteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedMemory" aoid="IsSharedMemory">
        <h1>IsSharedMemory( obj )</h1>
        <p> IsSharedMemory tests whether an object represents shared memory. </p>
        <emu-alg>
          1. Assert: Type(_obj_) is ~Object~ and it has an [[ArrayBufferData]] internal slot or a [[SharedArrayBufferData]] internal slot.
          1. If _obj_ has a [[SharedArrayBufferData]] internal slot then return ~true~.
          1. Return ~false~.
        </emu-alg>
      </emu-clause>

    </emu-clause> <!-- abstract -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1>The SharedArrayBuffer Constructor</h1>
      <p> The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the ~SharedArrayBuffer~ property of the global object. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner. </p>

      <p> The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an ~extends~ clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a ~super~ call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the ~SharedArrayBuffer.prototype~ built-in methods. </p>

      <emu-note>
        <p> Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[SharedArrayBufferData]] slot is never ~undefined~.</p>
      </emu-note>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1>SharedArrayBuffer( length )</h1>
        <p> SharedArrayBuffer called with argument length performs the following steps: </p>
        <emu-alg>
          1. If NewTarget is ~undefined~, throw a ~TypeError~ exception.
          1. Let _numberLength_ be ToNumber(_length_).
          1. Let _byteLength_ be ToLength(_numberLength_).
          1. ReturnIfAbrupt(_byteLength_).
          1. If SameValueZero(_numberLength_, _byteLength_) is ~false~, throw a ~RangeError~ exception.
          1. Return AllocateSharedArrayBuffer(NewTarget, _byteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1>Properties of the SharedArrayBuffer constructor</h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object %FunctionPrototype% (q.v.).</p>

      <p>Besides its ~length~ property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>
      
      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.isView">
        <h1>SharedArrayBuffer.isView( arg )</h1>
        <p>The isView function takes one argument arg, and performs the following steps are taken:</p>
        <emu-alg>
          1. If Type(_arg_) is not ~Object~, return ~false~.
          1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return ~true~.
          1. Return ~false~.
        </emu-alg>
        <emu-note>
          <p> (Spec draft notes)  This function is identical to ArrayBuffer.isView, since TypedArrays use the [[ViewedArrayBuffer]] internal slot to hold both unshared and shared views.  There is an opportunity to do something more interesting, namely, to make SharedArrayBuffer.isView() return ~true~ only if its argument is viewing a SharedArrayBuffer, and to make ArrayBuffer.isView() return ~false~ if its argument is viewing a SharedArrayBuffer.</p>
        </emu-note>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p> The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</P>
        <p> This property has the attributes { [[Writable]]: ~false~, [[Enumerable]]: ~false~, [[Configurable]]: ~false~ }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1>get SharedArrayBuffer [ @@species ]</h1>
        <P>`SharedArrayBuffer[@@species]` is an accessor property whose set accessor function is ~undefined~. Its get accessor function performs the following steps:</P>
        <emu-alg>
          1. Return the ~this~ value.
        </emu-alg>
        <P> The value of the name property of this function is "`get [Symbol.species]`".</P>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1>Properties of the SharedArrayBuffer prototype object</h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object %ObjectPrototype% (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have a [[SharedArrayBufferData]] or [[SharedArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>

        <p> SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is ~undefined~. Its get accessor function performs the following steps: </P>

        <emu-alg>
          1. Let _O_ be the ~this~ value.
          1. If Type(_O_) is not ~Object~, throw a ~TypeError~ exception.
          1. If _O_ does not have a [[SharedArrayBufferData]] internal slot, throw a ~TypeError~ exception.
          1. Let _length_ be the value of _O_’s [[SharedArrayBufferByteLength]] internal slot.
          1. Return _length_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p> The initial value of `SharedArrayBuffer.prototype.constructor` is the intrinsic object %SharedArrayBuffer%. </p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice( start, end )</h1>
        <p> The following steps are taken: </p>
        <emu-alg>
          1. Let _O_ be the ~this~ value.
          1. If Type(_O_) is not ~Object~, throw a ~TypeError~ exception.
          1. If _O_ does not have a [[SharedArrayBufferData]] internal slot, throw a ~TypeError~ exception.
          1. Let _len_ be the value of _O_’s [[SharedArrayBufferByteLength]] internal slot.
          1. Let _relativeStart_ be ToInteger(_start_).
          1. ReturnIfAbrupt(_relativeStart_).
          1. If _relativeStart_ &lt; 0, let first be max((_len_ + _relativeStart_),0); else let first be min(_relativeStart_, _len_).
          1. If _end_ is ~undefined~, let _relativeEnd_ be _len_; else let _relativeEnd_ be ToInteger(_end_).
          1. ReturnIfAbrupt(_relativeEnd_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_),0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_,0).
          1. Let _ctor_ be SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. ReturnIfAbrupt(_ctor_).
          1. Let _new_ be Construct(_ctor_, «newLen»).
          1. ReturnIfAbrupt(_new_).
          1. If _new_ does not have a [[SharedArrayBufferData]] internal slot, throw a ~TypeError~ exception.
          1. If SameValue(_new_, _O_) is ~true~, throw a ~TypeError~ exception.
          1. If the value of _new_’s [[SharedArrayBufferByteLength]] internal slot &lt; _newLen_, throw a ~TypeError~ exception.
          1. Let _fromBuf_ be the value of _O_’s [[SharedArrayBufferData]] internal slot.
          1. Let _toBuf_ be the value of _new_’s [[SharedArrayBufferData]] internal slot.
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1>SharedArrayBuffer.prototype[ @@toStringTag ]</h1>
        <p> The initial value of the @@toStringTag property is the String value `"SharedArrayBuffer"`.</p>

        <p>This property has the attributes { [[Writable]]: ~false~, [[Enumerable]]: ~false~, [[Configurable]]: ~true~ }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1>Properties of the SharedArrayBuffer instances</h1>

      <p> SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have a [[SharedArrayBufferData]] internal slot and a [[SharedArrayBufferByteLength]] internal slot. </p>

      <emu-note>
        <p> SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached. </p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1>The Atomics Object</h1>
  
  <emu-clause id="AtomicsObjectValueProps">
    <h1>Value Properties of the Atomics Object</h1>
    <emu-clause id="Atomics.OK">
      <h1>Atomics.OK</h1>
      <p>The value 0.</p>
    </emu-clause>
    <emu-clause id="Atomics.NOTEQUAL">
      <h1>Atomics.NOTEQUAL</h1>
      <p>The value -1.</p>
    </emu-clause>
    <emu-clause id="Atomics.TIMEDOUT">
      <h1>Atomics.TIMEDOUT</h1>
      <p>The value -2.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause "AtomicsObjectFunctionProps.semantics">
    <h1>Runtime semantics</h1>
    
    <emu-clause id="Atomics.WithAtomicAccessTo">
      <h1>With atomic access to ...</h1>
      
      <p> Let <em>atomic accesses</em> be those algorithm steps that are labeled 'With atomic access to ...' in the algorithms below, ie, atomic load, atomic store, and the atomic read-modify-write operations add, sub, and, or, xor, exchange, and compareExchange.</p>

      <p> Let an <em>access qualifier</em> on an atomic access be the triple comprising a Shared Data Block ID, an offset, and a size.</p>
        
      <p> Let <em>data accesses</em> be those invocations of GetValueFromBuffer() and SetValueInBuffer() that are not part of atomic accesses.</p>
        
      <p> A valid execution of an agent is constrained by:</p>
      <ul>
        <li> The ordering of the agent's programs' steps in the dynamic semantics
        <li> The happens-before relation of the agent cluster (next section)
      </ul>
      
      <p> If valid executions of two agents are able access the same shared memory cell at the same time and at least one access is a write then those accesses are said to <em>conflict</em>.  Two accesses from different agents form a <em>data race</em> if they conflict and at least one access is a data access, or if the accesses are both atomic but their access qualifiers do not match exactly. </p>

      <p> If the execution of an agent cluster has no data races, then the agent cluster behaves according to one of its sequentially consistent executions. </p>
        
      <p> Data races are allowed in ECMAScript programs, but their effects are hardware and implementation dependent and the result values of racing operations are unpredictable:  If two writes race, the value written to memory is unpredictable; if a read races with a write then the value read from memory is unpredictable.  A data race affects the reading and writing of all memory cells in the union of the access ranges of the racing accesses. </p>

      <emu-note>
        <p> Two atomic accesses can race if the byte ranges being accessed are overlapping but not equal. </p>

        <p> It's probably desirable to formalize "at the same time" further.  See Boehm and Adve 2008, Foundations of the C++ Concurrency Memory Model.  </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="Atomics.HappensBefore">
      <h1>Happens-before</h1>

      <p> The following rules constrain the interleaving of agent steps within a cluster:</p>
      <ul>
        <li> When an agent calls Atomics.futexWake or Atomics.futexWakeOrRequeue and another agent that was in a call to Atomics.futexWait wakes up as a result of the first agent's call, then the call to Atomics.futexWake or Atomics.futexWakeOrRequeue in the first agent happens-before the return from Atomics.futexWait in the second agent.
        <li> When a Shared Data Block is passed from one agent to the other, the sending of the block from the sender happens-before the receipt of the block in the recipient.
        <li> The ECMAScript embedding may extend the happens-before relation to take into account agent creation and destruction and inter-agent communication that does not go through shared memory.
      </ul>

    </emu-clause>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1>Runtime semantics: ValidateSharedIntegerTypedArray( typedArray [, onlyInt32] )</h1>
      <emu-alg>
        1. If Type(_typedArray_) is not Object, throw a ~TypeError~ exception.
        1. Let _typeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. If _onlyInt32_ is ~true~ then
          1. If _typeName_ is not "Int32Array" then throw a ~TypeError~ exception
        1. Else
          1. If _typeName_ is not "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Int32Array", or "Uint32Array" then throw a ~TypeError~ exception
        1. If _typedArray_ does not have a [[ViewedArrayBuffer]] internal slot, throw a ~TypeError~ exception.
        1. Let _buffer_ be the value of _typedArray_’s [[ViewedArrayBuffer]] internal slot.
        1. If Type(_buffer_) is not Object, throw a ~TypeError~ exception.
        1. If _buffer_ does not have a [[SharedArrayBufferData]] internal slot, throw a ~TypeError~ exception.
        1. Return _buffer_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1>Runtime semantics: ValidateAtomicAccess( typedArray, index )</h1>
      <P> Perform the following steps: </p>
      <emu-alg>
        1. Assert: _typedArray_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
        1. If Type(_index_) is String then
          1. Let _numValue_ be CanonicalNumericIndexString( _index_ )
          1. If _numValue_ is ~undefined~ then throw a ~RangeError~ exception
        1. Else if Type(_index_) is Number
          1. Let _numValue_ be _index_
        1. Else:
          1. Throw a ~RangeError~ exception
        1. If IsInteger(_numValue_) is ~false~ throw a ~RangeError~ exception
        1. If _numValue_ = -0 throw a ~RangeError~ exception
        1. Let _length_ be the value of _typedArray_'s [[ArrayLength]] internal slot.
        1. If _numValue_ &lt; 0 or _numValue_ &ge; _length_ throw a ~RangeError~ exception
        1. Return _numValue_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="WithinTheFutexCriticalSection">
      <h1>Within the futex critical section ...</h1>
      <p> In the algorithms below, the algorithm step 'Within the futex critical section' means the following:</p>
      <ul>
        <li> There is a single critical section for the futex operations that is shared among all agents in a cluster.
        <li> The phrase 'Within the futex critical section' acquires that section exclusively; any return from the dependent statements releases the section.
      </ul>
    </emu-clause>

    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1>Runtime semantics: AgentSignifier( )</h1>
      <p> When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg>
        1. Let _W_ be an identifier that identifies the calling agent within its cluster.
        2. Return _W_.
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1>Runtime semantics: AddWaiter( W, G, i )</h1>
      <p> When AddWaiter is called with an agent signifier _W_, a Shared Data Block ID _G_, and a nonnegative integer _i_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the futex critical section.
        1. Assert: _W_ is not in any global list of waiters
        1. Add _W_ to the end of the global list of all waiters that wait on (_G_, _i_)
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1>Runtime semantics: RemoveWaiter( W, G, i )</h1>
      <p> When RemoveWaiter is called with an agent signifier _W_, a Shared Data Block ID _G_, and a nonnegative integer _i_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the futex critical section.
        1. Assert: _W_ is in the global list of all waiters that wait on (_G_, _i_)
        1. Remove _W_ from the global list of all waiters that wait on (_G_, _i_)
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1>Runtime semantics: RemoveWaiters( G, i)</h1>
      <p> When RemoveWaiters is called with Shared Data Block ID _G_ and a nonnegative integer _i_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the futex critical section.
        1. Let _L_ be a copy of the global list of all waiters that wait on (_G_, _i_)
        1. Set the global list of all waiters that wait on (_G_, _i_) to the empty list
        1. Return _L_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1>Runtime semantics: Suspend( W, timeout )</h1>
      <p> When Suspend is called with a an agent signifier _W_ and nonnegative number _timeout_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the futex critical section.
        1. Assert: The calling agent is on some global list of waiters
        1. Assert: _W_ is equal to AgentSignifier()
        1. Atomically relinquish the futex critical section and suspend _W_ for up to _timeout_ milliseconds.  _W_ can wake up either because the timeout expired or because it was woken explicitly by another agent calling WakeWaiter(_W_), and not for any other reasons at all.
        1. Re-acquire the futex critical section.
        1. If _W_ was woken explicitly by another agent calling WakeWaiter(_W_), then return ~true~
        1. Return ~false~
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1>Runtime semantics: WakeWaiter( W )</h1>
      <p> When WakeWaiter is called with an agent signifier _W_, then the following steps are taken. </p>
      <emu-alg>
        1. Assert: The calling agent is in the futex critical section.
        1. Assert: _W_ is on some global list of waiters
        1. Wake the agent _W_
      </emu-alg>
    </emu-clause>

  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1>Function Properties of the Atomics Object</h1>

    <emu-clause id="Atomics.add">
      <h1>Atomics.add( typedArray, index, value )</h1>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be ToNumber(_value_)
        1. ReturnIfAbrupt(_value_).
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be the value of _typedArray_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_
        1. Let _G_ be SharedDataBlockID(_buffer_'s [[SharedArrayBufferData]] internal slot)
        1. With atomic access to ( _G_, _indexedPosition_, _elementSize_ ), do:
          1. Let _r_ be the result of GetValueFromBuffer( _buffer_, _indexedPosition_, _elementType_ )
          1. Compute: Let _w_ be _r_ + _v_
          1. Call SetValueInBuffer( _buffer_, _indexedPosition_, _elementType_, _w_ )
        1. Return _r_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.and">
      <h1>Atomics.and( typedArray, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _r_ &amp; _v_.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.compareExchange">
      <h1>Atomics.compareExchange( typedArray, index, expectedValue, replacementValue )</h1>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _expected_ be ToNumber(_expectedValue_)
        1. ReturnIfAbrupt(_expected_)
        1. Let _replacement_ be ToNumber(_replacedValue_)
        1. ReturnIfAbrupt(_replacement_)
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _convOp_ be the conversion operation specified in Table 49 for _arrayTypeName_
        1. Let _x_ be _convOp_ ( _expected_ )
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be the value of _typedArray_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_
        1. Let _G_ be SharedDataBlockID(_buffer_'s [[SharedArrayBufferData]] internal slot)
        1. With atomic access to ( _G_, _indexedPosition_, _elementType_ ), do:
          1. Let _r_ be GetValueFromBuffer( _buffer_, _indexedPosition_, _elementType_ )
          1. If _r_ is the same number value as _x_ then:
            1. Call SetValueInBuffer( _buffer_, _indexedPosition_, _elementType_, _replacement_ )
        1. Return _r_
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1>Atomics.exchange( typedArray, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _v_.</p>
    </emu-clause>

    <emu-clause id="Atomics.futexWait">
      <h1>Atomics.futexWait( typedArray, index, value, timeout )</h1>
      <p> Atomics.futexWait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_, ~true~)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be the result of ToInt32(_value_).
        1. ReturnIfAbrupt(_v_)
        1. If _timeout_ is not provided or is ~undefined~ then let _t_ be +Infinity.  Otherwise:
          1. Let _q_ be the result of ToNumber(_timeout_)
          1. ReturnIfAbrupt(_q_)
          1. If _q_ is NaN then let _t_ be +Infinity, otherwise let _t_ be max(0, _q_).
        1. Let _bufferVal_ be the value of the internal [[SharedArrayBufferData]] property of _buffer_.
        1. Let _G_ be SharedDataBlockID(_bufferVal_)
        1. Within the futex critical section do:
          1. Let _w_ be Atomics.load(_typedArray_, _i_)
          1. If _v_ does not equal _w_ then:
            1. Return the original value of ~Atomics.NOTEQUAL~.
          1. Let _W_ be AgentSignifier().
          1. Call AddWaiter(_W_, _G_, _i_)
          1. Let awoken = Suspend(_W_, _t_)
          1. Call RemoveWaiter(_W_, _G_, _i_)
        1. If awoken is ~true~ then return the original value of ~Atomics.OK~.
        1. Return the original value of ~Atomics.TIMEDOUT~.
      </emu-alg>

      <emu-note>
        <p> The name "futex" comes from Linux, where it means "fast user-space mutex".  Linux has wait/wake system calls with names and functionality similar to what's defined here. The mechanism described here is however not Linux-dependent in any way. </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.futexWake">
      <h1>Atomics.futexWake( typedArray, index, count )</h1>
      <p> Atomics.futexWake wakes up some agents that are sleeping in the wait queue.  The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray( _typedArray_, ~true~ )
        1. ReturnIfAbrupt( _buffer_ )
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt( _i_ )
        1. Let _tmp_ be ToInteger( _count_ )
        1. ReturnIfAbrupt( _tmp_ )
        1. Let _c_ be max( +0, _tmp_ ).
        1. Let _bufferVal_ be the value of the internal [[SharedArrayBufferData]] property of _buffer_.
        1. Let _G_ be SharedDataBlockID( _bufferVal_ )
        1. Let _n_ = 0
        1. Within the futex critical section do:
          1. Let _S_ be RemoveWaiters( _G_, _i_ )
          1. While _c_ &gt; 0 and _S_ is not the empty list:
            1. Let _W_ be the first agent in _S_
            1. Remove _W_ from the front of _S_
            1. Call WakeWaiter( _W_ )
            1. Subtract 1 from _c_
            1. Add 1 to _n_
        1. Return _n_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.futexWakeOrRequeue">
      <h1>Atomics.futexWakeOrRequeue( typedArray, index1, count, index2, value )</h1>
      <p> Atomics.futexWake wakes up some agents that are sleeping in the wait queue and moves other waiting agents to the back of the queue.  The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_, ~true~)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index1_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _tmp_ be ToInteger(_count_)
        1. ReturnIfAbrupt(_tmp_)
        1. Let _c_ be max(+0,_tmp_)
        1. Let _j_ be ValidateAtomicAccess( _typedArray_, _index2_ )
        1. ReturnIfAbrupt(_j_)
        1. Let _v_ be ToInt32(_value_)
        1. Let _bufferVal_ be the value of the internal [[SharedArrayBufferData]] property of _buffer_
        1. Let _G_ be SharedDataBlockID(_bufferVal_)
        1. Let _n_ = 0
        1. Within the futex critical section do:
          1. Let _w_ be Atomics.load(_typedArray_, _i_)
          1. If _v_ does not equal _w_ then:
            1. Return the original value of ~Atomics.NOTEQUAL~
          1. Let _S_ be RemoveWaiters(_G_, _i_)
          1. While _c_ &gt; 0 and _S_ is not the empty list:
            1. Let _W_ be the first agent in _S_
            1. Remove _W_ from the front of _S_
            1. Call WakeWaiter(_W_)
            1. Subtract 1 from _c_
            1. Add 1 to _n_
          1. While _S_ is not the empty list:
            1. Let _W_ be the first agent in _S_
            1. Remove _W_ from the front of _S_
            1. Call AddWaiter(_W_, _G_, _j_)
        1. Return _n_.
      </emu-alg>        

      <emu-note>
        <p> Atomics.futexWaitOrRequeue is an optimization that helps programs avoid a "thundering herd" problem when many agents are woken and compete for a lock (as in a broadcast). </p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1>Atomics.isLockFree( size )</h1>

      <emu-alg>
        1. Let _n_ be ToInteger(_size_)
        1. ReturnIfAbrupt(_n_)
        1. If _n_ is not the initial value of the BYTES_PER_ELEMENT property of some TypedArray then return ~false~
        1. If the atomic step of an atomic operation (compareExchange, load, store, add, sub, and, or, xor, or exchange) on a datum of size _n_ bytes will be performed without the calling agent acquiring a lock outside the _n_ bytes comprising the datum then return ~true~
        1. Return ~false~
      </emu-alg>

      <p>If Atomics.isLockFree(k) returns a value <em>v</em> at some point in some agent then every other invocation of Atomics.isLockFree(k) in that agent must return <em>v</em>.</p>

      <p>If Atomics.isLockFree(k) returns a value <em>v</em> in some agent then every invocation of Atomics.isLockFree(k) in any agent in the same cluster as the first agent must also return <em>v</em>.</p>

      <emu-note>
        <p> Atomics.isLockFree() is an optimization primitive.  High-performance algorithms will use it to determine whether to use locks or atomic operations in critical sections.  If an atomic primitive is not lock-free then it is often more efficient for an algorithm to provide its own locking.</P>
      </emu-note>

      <emu-note>
        <p>The return value for a given argument is not necessarily a constant on a given piece of hardware, but also reflects implementation choices that can vary over time and across engines.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1>Atomics.load( typedArray, index )</h1>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be the value of _typedArray_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_
        1. Let _G_ be SharedDataBlockID(_buffer_'s [[SharedArrayBufferData]] internal slot)
        1. With atomic access to ( _G_, _indexedPosition_, _elementSize_ ), do:
          1. Let _r_ be the result of GetValueFromBuffer( _buffer_, _indexedPosition_, _elementType_ )
        1. Return _r_
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1>Atomics.or( typedArray, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _r_ | _v_.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.store">
      <h1>Atomics.store( typedArray, index, value )</h1>
      <p> The following steps are taken: </p>
      <emu-alg>
        1. Let _buffer_ be ValidateSharedIntegerTypedArray(_typedArray_)
        1. ReturnIfAbrupt(_buffer_)
        1. Let _i_ be ValidateAtomicAccess( _typedArray_, _index_ )
        1. ReturnIfAbrupt(_i_)
        1. Let _v_ be ToNumber(_value_)
        1. ReturnIfAbrupt(_v_)
        1. Let _arrayTypeName_ be the value of _typedArray_'s [[TypedArrayName]] internal slot
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be the value of _typedArray_’s [[ByteOffset]] internal slot.
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_
        1. Let _G_ be SharedDataBlockID(_buffer_'s [[SharedArrayBufferData]] internal slot)
        1. With atomic access to ( _G_, _indexedPosition_, _elementSize_ ), do:
          1. Call SetValueInBuffer( _buffer_, _indexedPosition_, _elementType_, _v_ )
        1. Return _v_
      </emu-alg>
    </emu-clause>
    
    <emu-clause id="Atomics.sub">
      <h1>Atomics.sub( typedArray, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _r_ - _v_.</p>
    </emu-clause>
    
    <emu-clause id="Atomics.xor">
      <h1>Atomics.xor( typedArray, index, value )</h1>
      <p> Use the same algorithm as for Atomics.add but in the "Compute" step let _w_ be _r_ ^ _v_.</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1>Web browser embedding (informative)</h1>

  <emu-clause id="WebBrowserEmbedding.Agents">
    <h1>Agent mapping</h1>
    <p> In a web browser setting, the <em>agents</em> comprise a document's main thread environment and worker thread environments.  At a minimum, normal Web Workers must be supported.  (In some browsers, ServiceWorkers and Shared Workers may be technically incapable of receiving shared memory segments due to process separation.) </p>

  </emu-clause>
  
  <emu-clause id="WebBrowserEmbedding.WorkerSemantics">
    <h1>Clarifications and changes to Web Worker semantics</h1>

    <emu-note>
      <p> Several of these issues have been reported as bugs against the WHATWG spec, <a href='https://www.w3.org/Bugs/Public/show_bug.cgi?id=29039'>see this bug report</a>. </p>
    </emu-note>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Start">
      <h1>Actions to start a worker</h1>
      <p> (Clarification) The only action required to start a worker is to call "new Worker()". </p>
      <p> (Compatible change) If a worker cannot be started for reasons of resource exhaustion (notably, no threads available, including arbitrary implementation limits on the number of threads) then an exception must be thrown. </p>
      <emu-note>
        <p> Some browsers currently violate those requirements. </p>
        <ul>
          <li> In current Firefox, a worker is not actually created until the parent has returned to its event loop and allowed the event loop to process runnables related to the worker creation.
          <li> In current Firefox, there is a per-domain limit on the number of workers.  An attempt to create a worker will silently not start the worker if the limit has been reached; the worker will be queued and started when another worker has terminated.
        </ul>
        <p> If an agent creates a worker and then -- if the worker is not started because the agent does not return to its event loop or because the worker is not assigned a thread -- the agent goes to sleep on a location waiting for the worker to wake it, there will be a deadlock. </p>
        <p> There are other error situations during worker startup that can't necessarily be signaled synchronously, notably, a load error on the URL.  Those have to be signaled via an event callback, or the creating agent must poll the state of the worker to see if it enters an error state (see more below on the state). </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Jobs">
      <h1>Events and scripts run in a worker as ES6 jobs</h1>
      <p> (Clarification) ECMAscript code running in a worker runs as an ES6 job, and scheduling of work in a Worker happens by the rules of ES6 jobs.</p>
      <emu-note>
        <p> Thus the forward-progress guarantee of jobs also applies to workers. </p>
      </emu-note>
    </emu-clause>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.LicenseToKill">
      <h1>Curtail the license to kill</h1>
      <p> (Compatible change) Workers may be killed by the browser only for specific reasons.  These reasons are TBD but include evicting the owning page from the history and closing the owning page.  These reasons do not include workers that 'run too long'. </p>
      <emu-note>
        <p> Currently the WHATWG spec allows the browser to kill any worker at any time.  The purpose of the rule is probably a combination of the need to stop runaway scripts (without the normal slow-script dialog) and the need to remove workers once a page is evicted from the browser cache or a tab is closed.  However, the wording is overly broad.  Also, common uses of workers for computation conflict with the ability to detect 'runaway' agents:</p>
        <ul>
          <li> The worker may perform a genuinely long-running computation
          <li> The worker will have its own user-implemented 'event' loop, communicating synchronously through shared memory; it will not use the browser's event loop
        </ul>
      </emu-note>
    </emu-clause>

    <emu-clause id="WebBrowserEmbedding.WorkerSemantics.Introspection">
      <h1>Termination detection</h1>
      <p> (Compatible(?) change) The worker object should have a read-only property called "state" whose value represents the state of the worker (eg a string naming the state).  One state could be "terminated", indicating the worker is dead. </p>
      <emu-note>
        <p> (Spec draft note) There appears to be no way at present to directly determine whether a Worker has terminated. </p>
      </emu-note>
      <emu-note>
        <p> (Spec draft note) Possible complementary mechanisms include throwing an exception when a message is sent to a terminated worker, and to send an error event to the creating agent when a worker is killed. </p>
      </emu-note>
    </emu-clause>

  </emu-clause>
  
  <emu-clause id="WebBrowserEmbedding.MemoryModel">
    <h1>Agent communication semantics</h1>

    <p>Agent-to-agent communication extends the happens-before relation of the program, as follows:</p>

    <ul>
      <li>The call to the Worker constructor in the parent happens-before the execution of the main script in the worker.
      <li>The termination of a worker happens-before the parent of the worker (or any other agent) can determine that the worker has terminated.
      <li>A postMessage to a worker happens-before the event fires in the worker.
    </ul>

  </emu-clause>

  <emu-clause id="WebBrowserEmbedding.Termination">
    <h1>Agent termination</h1>
    <p>If a worker is terminated by a call to its terminate method while it is blocked in a call to futexWait then the worker is first woken (removed from any wait queue) and then immediately terminated (the wakeup is not observed by the caller of futexWait).  There are no provisions for cleaning up locked state unless the browser supports a close handler.</p>

    <p>If a worker is terminated for any other reason, such as the user agent reloading or closing the window or frame, and the worker is blocked in a call to futexWait when it is terminated, then the worker is first woken (removed from any wait queue) and then immediately terminated (the wakeup is not observed by the caller of futexWait).  However, after the running script has been terminated the worker's close handler(s) will be run as if the wait had not been aborted.</p>

    <p> Some corner cases are unresolved:</p>
    <ul>
      <li> If Service Workers have access to shared memory then it is possible for a service worker to wait on an action from another agent, say, a document's main thread.  But if the document in question is suspended (because the user is navigating away from the document) then the service worker may never be woken: the document may remain suspended and may eventually be evicted from the history.
    </ul>
        
  </emu-clause>
  
  <emu-clause id="WebBrowserEmbedding.CloneAndTransfer">
    <h1>Transmitting and Cloning SharedArrayBuffers and Views</h1>

    <p> SharedArrayBuffers and TypedArrays that view SharedArrayBuffers can be transmitted from one worker to another using postMessage() and are handled by the HTML5 structured clone algorithm as follows.</p>

    <p>When a SharedArrayBuffer input object is cloned in the originating agent the result is a new SharedArrayBuffer object in the receiving agent that references the same Shared Data Block as the input object.  The input object must be present in the transfer map for the clone operation; if not, a standard clone exception will be thrown.</p>

    <p>When a SharedArrayBuffer object is cloned its Shared Data Block is not detached (SharedArrayBuffers are never detached).</p>

    <p>A Shared Data Block remains accessible so long as at least one SharedArrayBuffer object references it in some agent.</p>

    <p>When a TypedArray object that is a view on a SharedArrayBuffer is cloned the result is a new TypedArray object of the same element type.  The "buffer" property of the new TypedArray will reference a clone of the input object's "buffer" property.  The input object's "buffer" property must be present in the transfer map for the clone, or a standard clone exception will be thrown.</p>

  </emu-clause>

</emu-clause>
