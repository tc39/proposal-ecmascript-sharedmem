<!-- -*- indent-tabs-mode: nil -*-

     Process this file with ../format.sh to produce shmem.html.  See comments in that file.
-->
<!doctype html>
<meta charset="utf8">
<pre class=metadata>
  title: ECMAScript Shared Memory and Atomics
  stage: 2
  contributors: Mozilla, Inc.
</pre>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<p>Some algorithms and semantics in this proposal are presented as modifications to existing ES262 algorithms and semantics.  The base revision of ES262 for the modifications (here denoted "ES7") is currently f35248729043089b47ccf29e4c47559386f5f6fd (2016-06-29).  At the moment, ES7 (ES2016) section numbering differs from ES6 (ES2015) only for TypedArrays (section 22.2).</p>

<emu-intro id="intro">
<h1>Introduction</h1>

<p>This proposal adds a simple form of shared memory to ECMAScript.
Shared memory is being exposed in the form of a new SharedArrayBuffer
type; the existing TypedArray and DataView types are adapted in such a way
that they can be used to create views on shared memory.  The new
global Atomics object provides atomic operations on shared memory
locations, including operations that can be used to create blocking
synchronization primitives.  Though not a part of this specification,
we intend for the role of "threads" to be played by Web Workers in web
browser environments.<p>

<p>At this time the proposal adds only low-level primitives to
ECMAScript; we expect the developer community to put together
abstractions that are useful in specific domains.</p>

<p>The work has been driven by the following use cases: <p>

<ul>
  <li>Support for threaded code in programs written in other
  languages that are translated to asm.js or plain JS or a combination
  of the two, notably C and C++ but also other, safe, languages.

  <li>Support for hand-written JS or JS+asm.js that makes use of
  multiprocessing facilities for select tasks, such as image
  processing, asset management, or game AI.
</ul>

<p>The proposal makes only very basic assumptions about the required
hardware and should be broadly implementable with good performance.
Prototype implementations of the API are available in Firefox and in
Google Chrome.</p>

<p>This specification constitutes a restatement and formalization of
an earlier
work, <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf">the
spec document for which</a> also contains additional rationale,
background information, discussions, implementation notes, and
comments.</p>

<p>Changelog:</p>
<ul>
  <li>2016-10-25 -- Fix Tear Free Aligned Reads to distinguish TypedArray vs DataView provenance instead of just alignment.
  <li>2016-10-25 -- Model candidate executions explicitly with evaluation semantics that can read all possible values; model events as Records.
  <li>2016-10-24 -- Fix RMW events to correctly return the read value instead of the modified value.
  <li>2016-10-24 -- Add Tear Free Aligned Reads requirement to valid executions; fixed Access Atomicity to impart that the memory model only solves ordering of events and that access atomicity is an orthogonal property.
  <li>2016-10-24 -- Rewrote memory model, again, to be axiomatic.
  <li>2016-07-22 -- Editorial fixes.
  <li>2016-07-21 -- Replace [[SharedArrayBufferData]] and [[SharedArrayBufferByteLength]] with [[ArrayBufferData]] and [[ArrayBufferByteLength]]; remove specialization that was based on the removed properties and instead use type checks with IsSharedArrayBuffer in ArrayBuffer, SharedArrayBuffer, and Atomics methods; spec that Shared Data Blocks are distinguishable (by unspecified means) from regular Data Blocks and use this to defined IsSharedArrayBuffer.
  <li>2016-07-20 -- Editorial fix: clarify the operator passed to AtomicFetchOp.
  <li>2016-07-13 -- Editorial fixes.
  <li>2016-07-11 -- Rewrote the memory model section, which introduced separate access functions for shared memory, and caused many other changes.
  <li>2016-07-05 -- Rewrote (and shrunk) the informative Web Browser Embedding section so that it only addresses the requirements of this spec, not how HTML ought to evolve.
  <li>2016-07-05 -- Rephrased the wait/wake mutual exclusion in terms of critical sections named by (G,i), as the old specification was too strong.
  <li>2016-06-30 -- Algorithms that are modified relative to their ES262 forms include more context and are more clearly marked, and there's a defined ES262 base revision for those modifications.  Updated section references to reference that revision.
  <li>(Older changelog removed)
</ul>

</emu-intro>

<emu-clause id="Overview">
  <h1>Overview (<a href="https://tc39.github.io/ecma262/#sec-overview">ES7 4</a>)</h1>
  <emu-clause id="Overview.Overview">
    <h1>ECMAScript Overview (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-overview">ES7 4.2</a>)</h1>
    <p>In the third paragraph, include <b>SharedArrayBuffer</b> after <b>ArrayBuffer</b>.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1>ECMAScript Data Types and Values (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">ES7 6</a>)</h1>

  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1>ECMAScript Language Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types">ES7 6.1</a>)</h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1>The Number Type (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types-number-type">ES7 6.1.6</a>)</h1>
      <p>In the NOTE, include <b>SharedArrayBuffer</b> along with <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1>The Object Type (<a href="https://tc39.github.io/ecma262/#sec-object-type">ES7 6.1.7</a>)</h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1>Well-Known Intrinsic Objects (<a href="https://tc39.github.io/ecma262/#sec-well-known-intrinsic-objects">ES7 6.1.7.4</a>)</h1>
        <p>In table 7, include rows for %Atomics%, %SharedArrayBuffer%, and %SharedArrayBufferPrototype% in the manner of the row for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="DataTypesValues.SpecTypes">
    <h1>ECMAScript Specification Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-specification-types">ES7 6.2</a>)</h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1>Data blocks (<a href="https://tc39.github.io/ecma262/#sec-data-blocks">ES7 6.2.6</a>)</h1>
      <p>Insert the following paragraphs after the third:</p>

      <p>A data block that resides in memory that can be referenced from multiple agents concurrently is designated a <dfn>Shared Data Block</dfn>.  A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that is <em>address-free</em>: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of locations in memory that the block represents.  Shared Data Blocks can also be distinguished from Data Blocks.</p>

      <p>The semantics of Shared Data Blocks is defined using Shared Data Block events by the Atomics memory model. Abstract operations below act as the interface between evaluation semantics and the event semantics of the memory model. The operations thus introduce ReadSharedMemory, WriteSharedMemory, and ReadModifyWriteSharedMemory events. Because of the axiomatic nature of the memory model, the values of these events are not known until the set of all events is known. The operations thus also nondeterministically read any possible Number value of a particular type during evaluation. The events introduced during an evaluation form a graph. The event graph together with the nondeterministically chosen values and other relations defined in the memory model form a candidate execution. The memory model does not admit all candidate executions; the allowed candidate executions are called valid executions, or simply executions. There is at least one valid execution for a given evaluation.</p>

      <p>A Shared Data Block event are modeled by Records, defined in the Atomics memory model. The <dfn>current candidate execution</dfn> is a candidate execution agreed upon by all agents in an agent cluster during evaluation.</p>

      <emu-note>
        <p>One may think of the evaluation semantics of ECMAScript as a generating function for candidate executions. The memory model then prunes invalid executions from the set of candidate executions. A single-agent ECMAScript program that does not use SharedArrayBuffer (and, for simplicity, ignoring other sources of nondeterminism such as `Math.random()`) always has exactly one candidate execution, which is also a valid execution. A multi-agent ECMAScript program that uses SharedArrayBuffer has many candidate executions and at least one valid execution.</p>
      </emu-note>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" aoid="CopyDataBlockBytes">
        <h1>CopyDataBlockBytes( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (<a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">ES7 6.2.6.2</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>When the abstract operation CopyDataBlockBytes is called, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _fromBlock_ and _toBlock_ are distinct Data Block <ins>or Shared Data Block</ins> values.
          1. Assert: _fromIndex_, _toIndex_, and _count_ are integer values &ge; 0.
          1. Let _fromSize_ be the number of bytes in _fromBlock_.
          1. Assert: _fromIndex_+_count_ &le; _fromSize_.
          1. Let _toSize_ be the number of bytes in _toBlock_.
          1. Assert: _toIndex_+_count_ &le; _toSize_.
          1. Repeat, while _count_&gt;0
            1. <del>Set _toBlock_[_toIndex_] to the value of _fromBlock_[_fromIndex_].</del><br><ins>If _fromBlock_ is a Shared Data Block then
              1. <ins>Let _bytes_ be a List of length *1* that contains a nondeterministically chosen byte value.</ins>
              1. <ins>Add ReadSharedMemory{[[Order]]: `"Unordered"`, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: *1*} to the current candidate execution's [[EventSet]].</ins>
              1. <ins>Add WriteSharedMemory{[[Order]]: `"Unordered"`, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: *1*, [[Payload]]: _bytes[0]_} to the current candidate execution's [[EventSet]].</ins>
            1. <ins>Otherwise, set _toBlock_[_toIndex_] to _fromBlock_[_fromIndex_].</inbs>
            1. Increment _toIndex_ and _fromIndex_ each by 1.
            1. Decrement _count_ by 1.
          1. Return NormalCompletion(~empty~).
        </emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" aoid="CreateSharedByteDataBlock">
        <h1>CreateSharedByteDataBlock( _size_ )</h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg>
          1. Assert: _size_ >= 0.
          1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.
          1. For each index _i_ of _db_:
            1. Add WriteSharedMemory{[[Order]]: `"Init"`, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: *1*, [[Payload]]: *0*} to the current candidate execution's [[EventSet]].
          1. Return _db_.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1>Executable Code and Execution Contexts (<a href="https://tc39.github.io/ecma262/#sec-executable-code-and-execution-contexts">ES7 8</a>)</h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">

    <h1>Jobs and Job Queues (<a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">ES7 8.4</a>)</h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1>Forward Progress Guarantees</h1>
      <p>The forward progress guarantee is provided by <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1>Agents (AMENDMENTS)</h1>

    <p>Add the following properties to the <dfn>Agent Record</dfn> (which is provided by <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>):</p>

    <emu-table id="table-agent-record" caption="Agent Record Fields">
      <table>
        <tbody>
          <tr>
            <th>Field name</th>
            <th>Value</th>
            <th>Meaning</th>
         </tr>
          <tr>
            <td>[[Signifier]]</td>
            <td>A value that admits equality testing</td>
            <td>Uniquely identifies the agent within its agent cluster.</td>
         </tr>
          <tr>
            <td>[[IsLockFree1]]</td>
            <td>Boolean</td>
            <td>True if and only if atomic operations on one-byte values are lock-free.</td>
         </tr>
          <tr>
            <td>[[IsLockFree2]]</td>
            <td>Boolean</td>
            <td>True if and only if atomic operations on two-byte values are lock-free.</td>
         </tr>
       </tbody>
     </table>
    </emu-table>

    <p>Once the values of [[Signifier]], [[IsLockFree1]], and
    [[IsLockFree2]] have been observed by any agent in the agent
    cluster they cannot change.</p>

    <emu-note>
      <p>The values of [[IsLockFree1]] and [[IsLockFree2]] are not
        necessarily determined by the hardware, but may also reflect
        implementation choices that can vary over time and between
        ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic
        operations are always lock-free.</p>

      <p>Formally, atomic operations are lock-free if, infinitely
        often, some atomic operation finishes in a finite number of
        program steps.  In practice, if an atomic operation is
        implemented with any type of lock the operation is not
        lock-free.  Lock-free does not imply wait-free: there is no
        upper bound on how many machine steps may be required to
        complete a lock-free atomic operation.</p>

      <p>That an atomic access of size <em>n</em> is lock-free does
        not imply anything about the (perceived) atomicity of
        non-atomic accesses of size <em>n</em>, specifically,
        non-atomic accesses may still be performed as a sequence of
        several separate memory accesses.  See ReadSharedMemory and
        WriteSharedMemory for details.</p>
    </emu-note>

  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1>Agent Clusters (NEW)</h1>

    <p>An <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory.</p>

    <emu-note>
      <p>Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        SharedArrayBuffer objects can be shared among the agents in
        the cluster.</p>

      <p>There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster.</p>
    </emu-note>

    <p>Every agent belongs to exactly one agent cluster.</p>

    <emu-note>
      <p>The agents in a cluster need not all be alive at some
	particular point in time.  If agent <b>A</b> creates another
	agent <b>B</b>, after which <b>A</b> terminates and <b>B</b>
	creates agent <b>C</b>, the three agents are in the same
	cluster if <b>A</b> could share some memory with <b>B</b>
	and <b>B</b> could share some memory with <b>C</b>.</p>
    </emu-note>

    <p>All agents within a cluster must have the same value for
      the [[LittleEndian]] property in their respective Agent Records.</p>

    <emu-note>
      <p>If different agents within an agent cluster have different
        values of [[LittleEndian]] it becomes hard to use shared
        memory for multi-byte data.</p>
    </emu-note>

    <p>All agents within a cluster must have the same values for
      the [[IsLockFree1]] property in their respective Agent Records; similarly for
      the [[IsLockFree2]] property.</p>

    <p>All agents within a cluster must have different values for
      the [[Signifier]] property in their respective Agent Records.</p>

    <p>An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation.</p>

    <p>An embedding may deactivate (stop forward progress) or
      activate (resume forward progress) an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must not
      leave some agents in the cluster active while other agents in
      the cluster are deactivated indefinitely.</p>

    <emu-note>
      <p>The purpose of the preceding restriction is to avoid a
        situation where an agent deadlocks or starves because another
        agent has been suspended.  For example, if a DOM SharedWorker
        shares memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve.</p>

      <p>The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding.</p>
    </emu-note>

    <p>An embedding may terminate an agent without any of the agent's
      cluster's other agents' prior knowledge or cooperation.  If an
      agent is terminated not by programmatic action of its own or of
      another agent in the cluster but by forces external to the
      cluster, then the embedding must choose one of two strategies:
      Either terminate all the agents in the cluster, or provide
      reliable APIs that allow the agents in the cluster to coordinate
      so that at least one remaining member of the cluster will be
      able to detect the termination, with the termination data
      containing enough information to identify the agent that was
      terminated.</p>

    <emu-note>
      <p>Examples of that type of termination are: operating systems
        or users terminating agents that are running in separate
        processes; the embedding itself terminating an agent that is
        running in-process with the other agents when per-agent
        resource accounting indicates that the agent is runaway.</p>
    </emu-note>

    <emu-note>
      <p>This proposal additionally suggests (see later text) that if
        termination is signaled then the signal creates a
        synchronizes-with edge in the memory ordering.</p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

</emu-clause>

<emu-clause id="GlobalObject">
  <h1>The Global Object (<a href="https://tc39.github.io/ecma262/#sec-global-object">ES7 18</a>)</h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1>Constructor Properties of the Global Object (<a href="https://tc39.github.io/ecma262/#sec-constructor-properties-of-the-global-object">ES7 18.3</a>)</h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1>SharedArrayBuffer</h1>
      <p>Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1>Atomics</h1>
      <p>Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items )
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1>Indexed Collections (<a href="https://tc39.github.io/ecma262/#sec-indexed-collections">ES7 22</a>)</h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1>TypedArray Objects (<a href="https://tc39.github.io/ecma262/#sec-typedarray-objects">ES7 22.2</a>)</h1>

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1>Properties of the %TypedArrayPrototype% object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-%typedarrayprototype%-object">ES7 22.2.3</a>)</h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1>%TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-overloaded-offset">ES7 22.2.3.23</a>)</h1>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1>%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">ES7 22.2.3.23.1</a>)</h1>
          <p>This algorithm is modified as follows:</p>

          <p>In the call to SetValueInBuffer, pass *true* as the fourth argument to indicate that the operation is performed on a TypedArray.</p>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1>%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-typedarray-offset">ES7 22.2.3.23.2</a>)</h1>
          <p>This algorithm is modified as follows:</p>
          <p>Sets multiple values in this _TypedArray_, reading the values from the _typedArray_ argument object. The optional _offset_ value indicates the first element index in this _TypedArray_ where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg>
            1. Assert: _typedArray_ has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"></emu-xref> applies.
            1. Let _target_ be the *this* value.
            1. If Type(_target_) is not Object, throw a *TypeError* exception.
            1. If _target_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
            1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.
            1. Let _targetOffset_ be ? ToInteger(_offset_).
            1. If _targetOffset_ &lt; 0, throw a *RangeError* exception.
            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_targetBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetLength_ be _target_.[[ArrayLength]].
            1. Let _srcBuffer_ be _typedArray_.[[ViewedArrayBuffer]].
            1. If IsDetachedBuffer(_srcBuffer_) is *true*, throw a *TypeError* exception.
            1. Let _targetName_ be the String value of _target_.[[TypedArrayName]].
            1. Let _targetType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _targetName_.
            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].
            1. Let _srcName_ be the String value of _typedArray_.[[TypedArrayName]].
            1. Let _srcType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcElementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _srcName_.
            1. Let _srcLength_ be _typedArray_.[[ArrayLength]].
            1. Let _srcByteOffset_ be _typedArray_.[[ByteOffset]].
            1. If _srcLength_ + _targetOffset_ &gt; _targetLength_, throw a *RangeError* exception.
            1. <ins>If both IsSharedArrayBuffer(_srcBuffer_) and IsSharedArrayBuffer(_targetBuffer_) are *true*, then let _same_ be *true* if _srcBuffer_.[[ArrayBufferData]] equals _targetBuffer_.[[ArrayBufferData]]; otherwise let _same_ be SameValue(_srcBuffer_, _targetBuffer_).</ins>
            1. <del>If SameValue(_srcBuffer_, _targetBuffer_)</del> <ins>_same_</ins> is *true*, then
              1. Let _srcBuffer_ be ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcLength_, %ArrayBuffer%).
              1. NOTE: %ArrayBuffer% is used to clone _srcBuffer_ because is it known to not have any observable side-effects.
              1. Let _srcByteIndex_ be 0.
            1. Else, let _srcByteIndex_ be _srcByteOffset_.
            1. Let _targetByteIndex_ be _targetOffset_ &times; _targetElementSize_ + _targetByteOffset_.
            1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ &times; _srcLength_.
            1. If SameValue(_srcType_, _targetType_) is *true*, then
              1. NOTE: If _srcType_ and _targetType_ are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.
              1. Repeat, while _targetByteIndex_ &lt; _limit_
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, `"Uint8"`, <ins>*true*</ins>).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, `"Uint8"`, <ins>*true*</ins>, _value_).
                1. ...
            1. Else,
              1. Repeat, while _targetByteIndex_ &lt; _limit_
                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, <ins>*true*</ins>).
                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, <ins>*true*</ins>, _value_).
                1. ...
            1. Return *undefined*.
          </emu-alg>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.slice">
          <h1>%TypedArray%.prototype.slice( _start_, _end_ ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice">ES7 22.2.3.24</a>)</h1>
          <p>This algorithm is modified as follows:</p>

          <p>In the calls to GetValueFromBuffer and SetValueInBuffer, pass *true* as the fourth argument to indicate that the operations are
            performed on a TypedArray.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="IndexedCollections.TypedArray.constructors">
      <h1>The %TypedArray% constructors (<a href="https://tc39.github.io/ecma262/#sec-typedarray-constructors">ES7 22.2.4</a>)</h1>

      <!-- es6num="22.2.1.3" -->
      <emu-clause id="sec-typedarray-typedarray">
        <h1>_TypedArray_ ( _typedArray_ ) (<a href="https://tc39.github.io/ecma262/#sec-typedarray-typedarray">ES7 22.2.4.3</a>)</h1>

        <p>This algorithm is modified as follows:</p>

        <p>In the calls to GetValueFromBuffer and SetValueInBuffer, pass *true* as the fourth argument to indicate that the operations are performed on a TypedArray.</p>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1>Structured Data (<a href="https://tc39.github.io/ecma262/#sec-structured-data">ES7 24</a>)</h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1>ArrayBuffer Objects (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer-objects">ES7 24.1</a>)</h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1>Abstract Operations for ArrayBuffer (<a href="https://tc39.github.io/ecma262/#sec-abstract-operations-for-arraybuffer-objects">ES7 24.1.1</a>)</h1>

      <emu-clause id="sec-detacharraybuffer" aoid="DetachArrayBuffer">
        <h1>DetachArrayBuffer ( _arrayBuffer_ ) (<a href="https://tc39.github.io/ecma262/#sec-detacharraybuffer">ES7 24.1.1.3</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation DetachArrayBuffer with argument _arrayBuffer_ performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_arrayBuffer_) is Object and it has [[ArrayBufferData]] and [[ArrayBufferByteLength]] internal slots.
          1. <ins>Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.</ins>
          1. ...
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.RawBytesToNumber" aoid="RawBytesToNumber">
        <h1><ins>RawBytesToNumber( _type_, _rawBytes_, _isLittleEndian_ )</ins></h1>
        <p>This is a new abstract operation.</p>
        <p><ins>The abstract operation RawBytesToNumber takes three parameters, a String _type_, a List _rawBytes_, and a Boolean _isLittleEndian_.</ins></p>
        <emu-alg>
          1. <ins>If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.</ins>
          1. <ins>If _type_ is `"Float32"`, then</ins>
            1. <ins>Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.</ins>
            1. <ins>If _value_ is an IEEE 754-2008 binary32 NaN value, return the *NaN* Number value.</ins>
            1. <ins>Return the Number value that corresponds to _value_.</ins>
          1. <ins>If _type_ is `"Float64"`, then</ins>
            1. <ins>Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.</ins>
            1. <ins>If _value_ is an IEEE 754-2008 binary64 NaN value, return the *NaN* Number value.</ins>
            1. <ins>Return the Number value that corresponds to _value_.</ins>
          1. <ins>If the first code unit of _type_ is `"U"`, then</ins>
            1. <ins>Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.</ins>
          1. <ins>Else,</ins>
            1. <ins>Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length _elementSize_ &times; 8.</ins>
          1. <ins>Return the Number value that corresponds to _intValue_.</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1>GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, <ins>_isTypedArray_, _order_</ins> [, _isLittleEndian_] ) (<a href="https://tc39.github.io/ecma262/#sec-getvaluefrombuffer">ES7 24.1.1.5</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation GetValueFromBuffer takes <del>four</del><ins>six</ins> parameters, an ArrayBuffer <ins>or SharedArrayBuffer</ins> _arrayBuffer_, an integer _byteIndex_, a String _type_, <ins>a Boolean _isTypedArray_, a String _order_,</ins> and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>
        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.
          1. <del>Let _rawValue_ be a List of _elementSize_ containing, in order, the _elementSize_ sequence of bytes starting with _block_[_byteIndex_].</del><br><ins>If IsSharedArrayBuffer(_arrayBuffer_) is *true* then</ins>
            1. <ins>Let _noTear_ be *true* if _isTypedArray_ is *true* and _type_ is `"Int8"`, `"Uint8"`, `"Int16"`, `"Uint16"`, `"Int32"`, or `"Uint32"`, otherwise *false*.
            1. <ins>Add ReadSharedMemory{[[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_} to the current candidate execution's [[EventSet]].</ins>
            1. <ins>Let _rawValue_ be a List of length _elementSize_ of nondeterministically chosen byte values.</ins>
          1. <ins>Else, let _rawValue_ be a List containing, in order, the _elementSize_ sequence of bytes starting with _block_[_byteIndex_].</ins>
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to <del>either *true* or *false*. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the SetValueInBuffer abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's Agent Record</ins>.
          1. <del>If _isLittleEndian_ is *false*, reverse the order of the elements of _rawValue_.</del><br><ins>Let _value_ be RawBytesToNumber(_type_, _rawValue_, _isLittleEndian_).</ins>
          1. <del>If _type_ is `"Float32"`, then</del>
            1. <del>Let _value_ be the byte elements of _rawValue_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.</del>
            1. <del>If _value_ is an IEEE 754-2008 binary32 NaN value, return the *NaN* Number value.</del>
            1. <del>Return the Number value that corresponds to _value_.</del>
          1. <del>If _type_ is `"Float64"`, then</del>
            1. <del>Let _value_ be the byte elements of _rawValue_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.</del>
            1. <del>If _value_ is an IEEE 754-2008 binary64 NaN value, return the *NaN* Number value.</del>
            1. <del>Return the Number value that corresponds to _value_.</del>
          1. <del>If the first code unit of _type_ is `"U"`, then</del>
            1. <del>Let _intValue_ be the byte elements of _rawValue_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.</del>
          1. <del>Else,</del>
            1. <del>Let _intValue_ be the byte elements of _rawValue_ concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length _elementSize_ &times; 8.</del>
          1. <del>Return the Number value that corresponds to _intValue_.</del> <ins>Return _value_.</ins>
        </emu-alg>

        <p>All existing uses of the form GetValueFromBuffer(_arrayBuffer_, _byteIndex_, _type_, _isLittleEndian_) in TypedArray methods and abstract operations are changed to <ins>GetValueFromBuffer(_arrayBuffer_, _byteIndex_, _type_, *true*, `"Unordered"`, _isLittleEndian_).</ins></p>
        <p>All existing uses of the form GetValueFromBuffer(_arrayBuffer_, _byteIndex_, _type_, _isLittleEndian_) in non-TypedArray methods and abstract operations are changed to <ins>GetValueFromBuffer(_arrayBuffer_, _byteIndex_, _type_, *false*, `"Unordered"`, _isLittleEndian_).</ins></p>
        <p>All existing uses of the form GetValueFromBuffer(_arrayBuffer_, _byteIndex_, _type_) in TypedArray methods and abstract operations are changed to <ins>GetValueFromBuffer(_arrayBuffer_, _byteIndex_, _type_, *true*, `"Unordered"`).</ins></p>
        <p>All existing uses of the form GetValueFromBuffer(_arrayBuffer_, _byteIndex_, _type_) in non-TypedArray methods and abstract operations are changed to <ins>GetValueFromBuffer(_arrayBuffer_, _byteIndex_, _type_, *false*, `"Unordered"`).</ins></p>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.NumberToRawBytes" aoid="NumberToRawBytes">
        <h1><ins>NumberToRawBytes( _type_, _value_, _isLittleEndian_ )</ins></h1>
        <p><ins>The abstract operation NumberToRawBytes takes three parameters, a String _type_, a Number _value_, and a Boolean _isLittleEndian_.</ins></p>
        <emu-alg>
          1. <ins>If _type_ is `"Float32"`, then</ins>
            1. <ins>Set _rawBytes_ to a List containing the 4 bytes that are the result of converting _value_ to IEEE 754-2008 binary32 format using &ldquo;Round to nearest, ties to even&rdquo; rounding mode. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawValue_ may be set to any implementation chosen IEEE 754-2008 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.</ins>
          1. <ins>Else if _type_ is `"Float64"`, then</ins>
            1. <ins>Set _rawBytes_ to a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of _value_. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawValue_ may be set to any implementation chosen IEEE 754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.</ins>
          1. <ins>Else,</ins>
            1. <ins>Let _n_ be the Number value of the Element Size specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.</ins>
            1. <ins>Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.</ins>
            1. <ins>Let _intValue_ be _convOp_(_value_).</ins>
            1. <ins>If _intValue_ &ge; 0, then</ins>
              1. <ins>Let _rawBytes_ be a List containing the _n_-byte binary encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</ins>
            1. <ins>Else,</ins>
              1. <ins>Let _rawBytes_ be a List containing the _n_-byte binary 2's complement encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</ins>
          1. <ins>Return _rawBytes_.</ins>
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1>SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, <ins>_isTypedArray_, _order_</ins> [, _isLittleEndian_] ) (<a href="https://tc39.github.io/ecma262/#sec-setvalueinbuffer">ES7 24.1.1.6</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation SetValueInBuffer takes <del>five</del><ins>seven</ins> parameters, an ArrayBuffer <ins>or SharedArrayBuffer</ins> _arrayBuffer_, an integer _byteIndex_, a String _type_, a Number _value_, <ins>a Boolean _isTypedArray_, a String _order_,</ins> and optionally a Boolean _isLittleEndian_. This operation performs the following steps:</p>

        <emu-alg>
          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.
          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.
          1. Assert: _byteIndex_ is an integer value &ge; 0.
          1. Assert: Type(_value_) is Number.
          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].
          1. Assert: _block_ is not *undefined*.
          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to <del>either *true* or *false*. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's Agent Record</ins>.
          1. <del>If _type_ is `"Float32"`, then</del><br><ins>Let _rawBytes_ be NumberToRawBytes(_type_, _value_, _isLittleEndian_).</ins>
            1. <del>Set _rawBytes_ to a List containing the 4 bytes that are the result of converting _value_ to IEEE 754-2008 binary32 format using &ldquo;Round to nearest, ties to even&rdquo; rounding mode. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawValue_ may be set to any implementation chosen IEEE 754-2008 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.</del>
          1. <del>Else if _type_ is `"Float64"`, then</del>
            1. <del>Set _rawBytes_ to a List containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of _value_. If _isLittleEndian_ is *false*, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If _value_ is *NaN*, _rawValue_ may be set to any implementation chosen IEEE 754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.</del>
          1. <del>Else,</del>
            1. <del>Let _n_ be the Number value of the Element Size specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.</del>
            1. <del>Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.</del>
            1. <del>Let _intValue_ be _convOp_(_value_).</del>
            1. <del>If _intValue_ &ge; 0, then</del>
              1. <del>Let _rawBytes_ be a List containing the _n_-byte binary encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</del>
            1. <del>Else,</del>
              1. <del>Let _rawBytes_ be a List containing the _n_-byte binary 2's complement encoding of _intValue_. If _isLittleEndian_ is *false*, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</del>
          1. <del>Store the individual bytes of _rawBytes_ into _block_, in order, starting at _block_[_byteIndex_].</del><br><ins>If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then</ins>
            1. <ins>Let _noTear_ be *true* if _isTypedArray_ is *true* and _type_ is `"Int8"`, `"Uint8"`, `"Int16"`, `"Uint16"`, `"Int32"`, or `"Uint32"`, otherwise *false*.
            1. <ins>Add WriteSharedMemory{[[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_} to the current candidate execution's [[EventSet]].</ins>
          1. <ins>Else, store the individual bytes of _rawBytes_ into _block_, in order, starting at _block_[_byteIndex_].</ins>
          1. Return NormalCompletion(*undefined*).
        </emu-alg>

        <p>All existing uses of the form SetValueInBuffer(_arrayBuffer_, _byteIndex_, _type_, _value_, _isLittleEndian_) in TypedArray methods and abstract operations are changed to <ins>SetValueInBuffer(_arrayBuffer_, _byteIndex_, _type_, _value_, *true*, `"Unordered"`, _isLittleEndian_).</ins></p>
        <p>All existing uses of the form SetValueInBuffer(_arrayBuffer_, _byteIndex_, _type_, _value_, _isLittleEndian_) in non-TypedArray methods and abstract operations are changed to <ins>SetValueInBuffer(_arrayBuffer_, _byteIndex_, _type_, _value_, *false*, `"Unordered"`, _isLittleEndian_).</ins></p>
        <p>All existing uses of the form SetValueInBuffer(_arrayBuffer_, _byteIndex_, _type_, _value_) in TypedArray methods and abstract operations are changed to <ins>SetValueInBuffer(_arrayBuffer_, _byteIndex_, _type_, _value_, *true*, `"Unordered"`).</ins></p>
        <p>All existing uses of the form SetValueInBuffer(_arrayBuffer_, _byteIndex_, _type_, _value_) in non-TypedArray methods and abstract operations are changed to <ins>SetValueInBuffer(_arrayBuffer_, _byteIndex_, _type_, _value_, *false*, `"Unordered"`).</ins></p>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetModifySetValueInBuffer" aoid="GetModifySetValueInBuffer">
        <h1><ins>GetModifySetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, _op_ [, _isLittleEndian_] )</ins></h1>
        <p>This is a new abstract operation.</p>
        <p><ins>The abstract operation GetModifySetValueInBuffer takes six parameters, An ArrayBuffer or SharedArrayBuffer _arrayBuffer_, a nonnegative integer _byteIndex_, a String _type_, a semantic function _op_, a Number _value_, and optionally a Boolean _isLittleEndian_. This operation performs the following steps given a valid execution _execution_ (see the Atomics memory model):</ins></p>

        <emu-alg>
          1. <ins>Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.</ins>
          1. <ins>Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.</ins>
          1. <ins>Assert: _byteIndex_ is an integer value &ge; 0.</ins>
          1. <ins>Assert: Type(_value_) is Number.</ins>
          1. <ins>Let _block_ be _arrayBuffer_.[[ArrayBufferData]].</ins>
          1. <ins>Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for Element Type _type_.</ins>
          1. <ins>If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] internal slot of the surrounding agent's Agent Record.</ins>
          1. <ins>Let _rawBytes_ be NumberToRawBytes(_type_, _value_, _isLittleEndian_).</ins>
          1. <ins>Assert: IsSharedArrayBuffer(_arrayBuffer_) is *true*.</ins>
          1. <ins>Add ReadModifyWriteSharedMemory{[[Order]]: `"SeqCst"`, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_} to the current candidate execution's [[EventSet]].</ins>
          1. <ins>Let _rawBytesRead_ be the a List of length _elementSize_ of nondeterministically chosen byte values.</ins>
          1. <ins>Let _value_ be RawBytesToNumber(_type_, _rawBytesRead_, _isLittleEndian_).</ins>
          1. <ins>Return _value_.</ins>
        </emu-alg>
      </emu-clause>
    </emu-clause> <!-- abstract -->

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1>Properties of the ArrayBuffer Prototype Object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-arraybuffer-prototype-object">ES7 24.1.4</a>)</h1>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1>get ArrayBuffer.prototype.byteLength (<a href="https://tc39.github.io/ecma262/#sec-get-arraybuffer.prototype.bytelength">ES7 24.1.4.1</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>`ArrayBuffer.prototype.byteLength` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. <ins>If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.</ins>
          1. ...
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1>ArrayBuffer.prototype.slice ( _start_, _end_ ) (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice">ES7 24.1.4.3</a>)</h1>
        <p>This algorithm is modified as follows:</p>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. <ins>If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.</ins>
          1. ...
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1>SharedArrayBuffer Objects</h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1>Abstract Operations for SharedArrayBuffer</h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1>AllocateSharedArrayBuffer( _constructor_, _byteLength_ )</h1>
        <p>The abstract operation AllocateSharedArrayBuffer with arguments _constructor_ and _byteLength_ is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg>
          1. Let _obj_ be ? OrdinaryCreateFromConstructor(constructor, "%SharedArrayBufferPrototype%", «‍[[ArrayBufferData]], [[ArrayBufferByteLength]]» ).
          1. Assert: _byteLength_ is a nonnegative integer.
          1. Let _block_ be ? CreateSharedByteDataBlock(_byteLength_).
          1. Set _obj_.[[ArrayBufferData]] to _block_.
          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.
          1. Return _obj_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer" aoid="IsSharedArrayBuffer">
        <h1>IsSharedArrayBuffer( _obj_ )</h1>
        <p>IsSharedArrayBuffer tests whether an object that is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either is a SharedArrayBuffer or a subtype of it.  It performs the following steps:</p>
        <emu-alg>
          1. Assert: Type(_obj_) is Object and it has an [[ArrayBufferData]] internal slot.
          1. Let _bufferData_ be _obj_.[[ArrayBufferData]].
          1. If _bufferData_ is *null* or *undefined* then return *false*.
          1. If _bufferData_ is a Data Block then return *false*.
          1. Assert: _bufferData_ is a Shared Data Block.
          1. Return *true*.
        </emu-alg>
      </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1>The SharedArrayBuffer Constructor</h1>
      <p>The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the `SharedArrayBuffer` property of the global object. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner.</p>

      <p>The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an `extends` clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a `super` call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the `SharedArrayBuffer.prototype` built-in methods.</p>

      <emu-note>
        <p>Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[ArrayBufferData]] slot is never *null* or *undefined*.</p>
      </emu-note>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1>SharedArrayBuffer( _length_ )</h1>
        <p>SharedArrayBuffer called with argument _length_ performs the following steps:</p>
        <emu-alg>
          1. If NewTarget is *undefined*, throw a *TypeError* exception.
          1. Let _numberLength_ be ? ToNumber(_length_).
          1. Let _byteLength_ be ToLength(_numberLength_).
          1. If SameValueZero(_numberLength_, _byteLength_) is *false*, throw a *RangeError* exception.
          1. Return AllocateSharedArrayBuffer(NewTarget, _byteLength_).
        </emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1>Properties of the SharedArrayBuffer constructor</h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object %FunctionPrototype% (q.v.).</p>

      <p>Besides its `length` property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1>SharedArrayBuffer.prototype</h1>
        <p>The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</P>
        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1>get SharedArrayBuffer [ @@species ]</h1>
        <p>`SharedArrayBuffer[@@species]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>
        <emu-alg>
          1. Return the *this* value.
        </emu-alg>
        <p>The value of the name property of this function is "`get [Symbol.species]`".</p>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1>Properties of the SharedArrayBuffer prototype object</h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object %ObjectPrototype% (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1>get SharedArrayBuffer.prototype.byteLength</h1>

        <p>SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:</p>

        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have a [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _length_ be _O_.[[ArrayBufferByteLength]].
          1. Return _length_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1>SharedArrayBuffer.prototype.constructor</h1>
        <p>The initial value of `SharedArrayBuffer.prototype.constructor` is the intrinsic object %SharedArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1>SharedArrayBuffer.prototype.slice( _start_, _end_ )</h1>
        <p>The following steps are taken:</p>
        <emu-alg>
          1. Let _O_ be the *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.
          1. Let _len_ be _O_.[[ArrayBufferByteLength]].
          1. Let _relativeStart_ be ? ToInteger(_start_).
          1. If _relativeStart_ &lt; 0, let first be max((_len_ + _relativeStart_), 0); else let first be min(_relativeStart_, _len_).
          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToInteger(_end_).
          1. If _relativeEnd_ &lt; 0, let _final_ be max((_len_ + _relativeEnd_), 0); else let _final_ be min(_relativeEnd_, _len_).
          1. Let _newLen_ be max(_final_ - _first_, 0).
          1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).
          1. Let _new_ be ? Construct(_ctor_, «newLen»).
          1. If _new_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.
          1. If _new_.[[ArrayBufferByteLength]] &lt; _newLen_, throw a *TypeError* exception.
          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].
          1. Let _toBuf_ be _new_.[[ArrayBufferData]].
          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).
          1. Return _new_.
        </emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1>SharedArrayBuffer.prototype[ @@toStringTag ]</h1>
        <p>The initial value of the @@toStringTag property is the String value `"SharedArrayBuffer"`.</p>

        <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1>Properties of the SharedArrayBuffer instances</h1>

      <p>SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have an [[ArrayBufferData]] internal slot and a [[ArrayBufferByteLength]] internal slot.</p>

      <emu-note>
        <p>SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.</p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1>The Atomics Object</h1>

  <p>The Atomics object is the <dfn>%Atomics%</dfn> intrinsic object and the initial value of the `Atomics` property of the global object. The Atomics object is a single ordinary object.</p>
  <p>The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let agents wait for and dispatch primitive events.  When used with discipline, the Atomics functions allow multi-agent programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs.  The rules that govern shared-memory communication are provided by the <dfn>memory model</dfn>, defined below.</p>
  <p>The value of the [[Prototype]] internal slot of the Atomics object is the intrinsic object %ObjectPrototype%.</p>
  <p>The Atomics object is not a function object. It does not have a [[Construct]] internal method; it is not possible to use the Atomics object as a constructor with the `new` operator. The Atomics object also does not have a [[Call]] internal method; it is not possible to invoke the Atomics object as a function.</p>

  <emu-clause id="MemoryModel">
    <h1>Memory Model</h1>

    <p>The memory consistency model, or memory model, specifies the possible orderings of Shared Data Block events, arising via accessing TypedArray instances backed by a SharedArrayBuffer and via methods on the Atomics object. When the program has no data races (defined more precisely below), the ordering of events appears as sequentially consistent, i.e., as an interleaving of actions from each agent. When the program has data races, shared memory operations may appear sequentially inconsistent. For example, programs may exhibit causality-violating behavior and other astonishments. These astonishments arise from compiler transforms and the design of CPUs (e.g., out-of-order execution and speculation). The memory model defines both the precise conditions under which a program exhibits sequentially consistent behavior as well as the allowable effects of data races.</p>

    <p>The memory model is defined as relational constraints on events introduced by abstract operations on SharedArrayBuffer or by methods on the Atomics object during an evaluation.</p>

    <emu-note>
      <p>This section provides an axiomatic model on events introduced by the abstract operations on SharedArrayBuffers. It bears stressing that the model is not expressible algorithmically, unlike the rest of this specification. The nondeterministic introduction of events by abstract operations is the interface between the operational semantics of ECMAScript evaluation and the denotational semantics of the axiomatic memory model. The semantics of these events is defined by considering graphs of all events in an evaluation. These are neither Static Semantics nor Runtime Semantics. There is no demonstrated algorithmic implementation, but instead a set of constraints that determine if a particular event graph is allowed or disallowed.</p>

      <p>(Spec draft note) Acknowledgement: The description of many fundamentals and sequentially consistent and unordered orderings are inspired by the LLVM memory model.</p>
    </emu-note>

    <emu-clause id="MemoryModel.Fundamentals">
      <h1>Fundamentals</h1>

      <p>Shared memory accesses (reads and writes) are divided into two groups, atomic accesses and data accesses, defined below. Atomic accesses are sequentially consistent, i.e., there is a total ordering of events agreed upon by all agents in an agent cluster. Non-atomic accesses do not have a total ordering agreed upon by all agents, i.e., unordered.</p>

      <emu-note>
        <p>No orderings weaker than sequentially consistent and stronger than unordered, such as release-acquire, are supported.</p>
      </emu-note>

      <p>A <dfn>Shared Data Block event</dfn> is either a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory Record.</p>

      <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory Event Fields">
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Order]]</td>
              <td>`"SeqCst"`, `"Unordered"`, or `"Init"`.</td>
              <td>The weakest ordering guaranteed by the memory model for the event.</td>
            </tr>
            <tr>
              <td>[[NoTear]]</td>
              <td>A Boolean</td>
              <td>Whether this event is allowed to read from multiple write events on the equal range.</td>
            </tr>
            <tr>
              <td>[[Block]]</td>
              <td>A Shared Data Block</td>
              <td>The block the event operates on.</td>
            </tr>
            <tr>
              <td>[[ByteIndex]]</td>
              <td>A nonnegative integer</td>
              <td>The byte address of the read in [[Block]].</td>
            </tr>
            <tr>
              <td>[[ElementSize]]</td>
              <td>A nonnegative integer</td>
              <td>The size of the read.</td>
            </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory Event Fields">
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Order]]</td>
              <td>`"SeqCst"`, `"Unordered"`, or `"Init"`.</td>
              <td>The weakest ordering guaranteed by the memory model for the event.</td>
            </tr>
            <tr>
              <td>[[NoTear]]</td>
              <td>A Boolean</td>
              <td>Whether this event is allowed to be read from multiple read events on the equal range.</td>
            </tr>
            <tr>
              <td>[[Block]]</td>
              <td>A Shared Data Block</td>
              <td>The block the event operates on.</td>
            </tr>
            <tr>
              <td>[[ByteIndex]]</td>
              <td>A nonnegative integer</td>
              <td>The byte address of the write in [[Block]].</td>
            </tr>
            <tr>
              <td>[[ElementSize]]</td>
              <td>A nonnegative integer</td>
              <td>The size of the write.</td>
            </tr>
            <tr>
              <td>[[Payload]]</td>
              <td>A List</td>
              <td>The List of byte values to be read by other events.</td>
            </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory Event Fields">
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Order]]</td>
              <td>`"SeqCst"`</td>
              <td>Read-modify-write events are always sequentially consistent.</td>
            </tr>
            <tr>
              <td>[[NoTear]]</td>
              <td>*true*</td>
              <td>Read-modify-write events cannot tear.</td>
            </tr>
            <tr>
              <td>[[Block]]</td>
              <td>A Shared Data Block</td>
              <td>The block the event operates on.</td>
            </tr>
            <tr>
              <td>[[ByteIndex]]</td>
              <td>A nonnegative integer</td>
              <td>The byte address of the read-modify-write in [[Block]].</td>
            </tr>
            <tr>
              <td>[[ElementSize]]</td>
              <td>A nonnegative integer</td>
              <td>The size of the write.</td>
            </tr>
            <tr>
              <td>[[Payload]]</td>
              <td>A List</td>
              <td>The List of byte values to be passed to [[ModifyOp]].</td>
            </tr>
            <tr>
              <td>[[ModifyOp]]</td>
              <td>A semantic function</td>
              <td>A pure semantic function that returns a modified List of byte values from a read List of byte values and [[Payload]].</td>
            </tr>
          </tbody>
        </table>
      </emu-table>

      <p>These events are introduced by an abstract operation or by a Function property on the Atomics object. Additionally, Shared Data Block events include host-specific events.</p>

      <p>Let the <dfn>range</dfn> of a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event be the List of contiguous integers from its _byteIndex_ to _byteIndex_+_elementSize_-1. Two events' ranges are equal when the events have the same _block_, and the ranges are element-wise equal. Two events' ranges are overlapping when the events have the same _block_, the ranges are not equal and their intersection is non-empty. Two events' ranges are disjoint when the events do not have the same _block_ or their ranges their neither equal nor overlapping.</p>

      <emu-note>
        <p>Examples of host-specific synchronizing events that should be accounted for are: sending a SharedArrayBuffer from one agent to another (e.g., by `postMessage` in a browser), starting and stopping agents, and communicating within the agent cluster via channels other than shared memory.</p>
      </emu-note>

      <p>Shared Data Block events are ordered within candidate executions by the relations defined mutually recursively below.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.CandidateExecutions">
      <h1>Candidate Executions</h1>
      <p>A <dfn>candidate execution</dfn> of the evaluation of an agent cluster is a Record with the following fields.</p>
      <emu-table id="table-candidate-execution-records" caption="Candidate Execution Record Fields">
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[EventSet]]</td>
              <td>A set of Shared Data Block events.</td>
              <td>Events introduced by GetValueFromBuffer, SetValueInBuffer, GetModifySetValueInBuffer, or host-specific operations (e.g., `postMessage`) during the evaluation.</td>
            </tr>
            <tr>
              <td>[[ChosenValues]]</td>
              <td>A function from events to Lists.</td>
              <td>Maps ReadSharedMemory or ReadModifyWriteSharedMemory events to the List of byte values chosen nondeterministically during the evaluation.</td>
            </tr>
            <tr>
              <td>[[AgentOrders]]</td>
              <td>A function from agents to agent-order relations.</td>
              <td>Maps an agent to its agent-order, defined below.</td>
            </tr>
            <tr>
              <td>[[HostSynchronizesWith]]</td>
              <td>A host-synchronizes-with relation.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[SynchronizesWith]]</td>
              <td>A synchronizes-with relation.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[HappensBefore]]</td>
              <td>A happens-before relation.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[ReadsBytesFrom]]</td>
              <td>A reads-bytes-from function.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[ReadsFrom]]</td>
              <td>A reads-from relation.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[DependsOn]]</td>
              <td>A depends-on relation.</td>
              <td>Defined below.</td>
            </tr>
          </tbody>
        </table>
      </emu-table>

      <emu-note>
        <p>Because happens-before is a superset of agent-order, candidate executions are consistent with the single-thread evaluation semantics of ECMA262.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.AgentOrder" aoid="agent-order">
      <h1>agent-order</h1>
      <p>For a candidate execution _execution_, the total introduction order over the subset of events introduced by a particular agent in _execution_.[[EventSet]] during evaluation.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.HostSynchronizesWith" aoid="host-synchronizes-with">
      <h1>host-synchronizes-with</h1>
      <p>For a candidate execution _execution_, a relation between pairs of host-specific events in _execution_.[[EventSet]].</p>
      <emu-note>
        <p>The host-synchronizes-with relation allows the host to provide additional synchronization mechanisms, such as `postMessage` between HTML workers.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.SynchronizesWith" aoid="synchronizes-with">
      <h1>synchronizes-with</h1>
      <p>For a candidate execution _execution_, _execution_.[[SynchronizesWith]] is the least relation such that the following conditions hold.</p>

      <emu-alg>
        1. Let synchronizes-with be _execution_.[[SynchronizesWith]].
        1. Let reads-from be _execution_.[[ReadsFrom]].
        1. Let host-synchronizes-with be _execution_.[[HostSynchronizesWith]].
        1. For each pair of events _R_ and _W_ in _execution_.[[EventSet]] such that _R_.[[Order]] is `"SeqCst"` and _R_ reads-from _W_:
          1. Assert: _R_ is a ReadSharedMemory or ReadModifyWriteSharedMemory event.
          1. Assert: _W_ is a WriteSharedMemory or ReadModifyWriteSharedMemory event.
          1. If _W_.[[Order]] is `"SeqCst"` and _R_ and _W_ have equal ranges then _W_ synchronizes-with _R_.
          1. Otherwise, if _W_ has _order_ `"Init"` then
            1. Let _allInitReads_ be *true*.
            1. For each event _V_ such that _R_ reads-from _V_:
              1. If _V_.[[Order]] is not `"Init"` then set _allInitReads_ to *false*.
            1. If _allInitReads_ is *true* then _W_ synchronizes-with _R_.
        1. For each pair of events _E_ and _D_ in _execution_.[[EventSet]]:
          1. If _E_ host-synchronizes-with _D_ then _E_ synchronizes-with _D_.
      </emu-alg>

      <emu-note>
        <p>Owing to convention, write events synchronizes-with read events, instead of read events synchronizes-with write events.</p>
      </emu-note>

      <emu-note>
        <p>Not all `"SeqCst"` events related by reads-from are related by synchronizes-with. Only events that also have equal ranges are related by synchronizes-with.</p>
      </emu-note>

      <emu-note>
        <p>For an event _R_ and a event _W_ such _W_ synchronizes-with _R_, _R_ may reads-from other writes than _W_.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.HappensBefore" aoid="happens-before">
      <h1>happens-before</h1>
      <p>For a candidate execution _execution_, _execution_.[[HappensBefore]] is the least partial order such that the following conditions hold.</p>

      <emu-alg>
        1. Let happens-before be _execution_.[[HappensBefore]].
        1. Let synchronizes-with be _execution_.[[SynchronizesWith]].
        1. For each pair of events _E_ and _D_ in _execution_.[[EventSet]]:
          1. For each agent _a_ in the agent cluster:
            1. Let agent-order be _execution_.[[AgentOrders]](a).
            1. If _E_ is agent-order before _D_ in _a_ then _E_ happens-before _D_.
            1. If _E_ synchronizes-with _D_ then _E_ happens-before _D_.
            1. If there is an event _F_ such that _E_ happens-before _F_ and _F_ happens-before _D_ then _E_ happens-before _D_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.ReadBytesFrom" aoid="reads-bytes-from">
      <h1>reads-bytes-from</h1>
      <p>For a candidate execution _execution_, _execution_.[[ReadsBytesFrom]] is a function such that the following conditions hold.</p>

      <emu-alg>
        1. Let reads-bytes-from be _execution_.[[ReadsBytesFrom]].
        1. Let happens-before be _execution_.[[HappensBefore]].
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ in _execution_.[[EventSet]]:
          1. There is a List of length equal to _R_.[[ElementSize]] of WriteSharedMemory or ReadModifyWriteSharedMemory events _Ws_ such that _R_ reads-bytes-from _Ws_.
          1. Let _byteLocation_ be _R_.[[ByteIndex]].
          1. For each element _W_ of _Ws_ in List order:
            1. _W_ has _byteLocation_ in its range, and
            1. It is not the case that _R_ happens-before _W_, and
            1. There is no WriteSharedMemory or ReadModifyWriteSharedMemory event _V_ that has _byteLocation_ in its range such that _W_ happens-before _V_ and _V_ happens-before _R_.
            1. Increment _byteLocation_ by 1.
      </emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.ReadsFrom" aoid="reads-from">
      <h1>reads-from</h1>
      <p>For a candidate execution _execution_, _execution_.[[ReadsFrom]] is the least relation such that the following conditions hold.</p>

      <emu-alg>
        1. Let reads-from be _execution_.[[ReadsFrom]].
        1. Let reads-bytes-from be _execution_.[[ReadsBytesFrom]].
        1. For each pair of events _R_ and _W_ in _execution_.[[EventSet]]:
          1. If _R_ reads-bytes-from a List of WriteSharedMemory events _Ws_ that contains _W_ then _R_ reads-from _W_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.InitialValue">
      <h1>Initial Values</h1>
      <p>For a candidate execution _execution_, for each byte location _b_ in a Shared Data Block _block_, there is a WriteSharedMemory{[[Order]]: `"Init"`, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _b_, [[ElementSize]]: *1*, [[Payload]]: *0*} such that it happens-before all other Shared Data Block events with _b_ in their ranges in _execution_.[[EventSet]].</p>
    </emu-clause>

    <emu-clause id="MemoryModel.DependsOn" aoid="depends-on">
      <h1>depends-on</h1>
      <p>For a candidate execution _execution_, a host-provided relation on events in _execution_.[[EventSet]] that is consistent with the agent-order of each agent in the agent cluster that captures semantic data and control dependencies between events.</p>

      <emu-note>
        <p>The dependence relation may differ between implementations of ECMAScript. For instance, one implementation may provide a syntactic dependence relation that overapproximates semantic dependences.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.ComposeWriteEventBytes" aoid="ComposeWriteEventBytes">
      <h1>ComposeWriteEventBytes( _execution_, _block_, _byteIndex_, _Ws_ )</h1>
      <p>The abstraction operation ComposeWriteEventBytes takes four arguments, a candidate execution _execution_, a Shared Data Block _block_, a nonnegative integer _byteIndex_, and a List _Ws_.</p>
      <p>It returns a List using the following steps.</p>

      <emu-alg>
        1. Let _byteLocation_ be _byteIndex_.
        1. Let _bytesRead_ be an empty List.
        1. For each element _W_ of _Ws_ in List order:
          1. Assert: _W_ has _byteLocation_ in its range.
          1. If _W_ is a WriteSharedMemory event then
            1. Let _byte_ be _W_.[[Payload]][_byteLocation_].
          1. Else,
            1. Assert: _W_ is a ReadModifyWriteSharedMemory event.
            1. Let _bytesRead_ be ValueOfReadEvent(_execution_, _W_).
            1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytesRead_, _W_.[[Payload]]).
            1. Let _byte_ be _bytesModified_[_byteLocation_].
          1. Append _byte_ to _bytesRead_.
          1. Increment _byteLocation_ by 1.
        1. Return _bytesRead_.
      </emu-alg>

      <emu-note>
        <p>The semantic function [[ModifyOp]] is given by the function properties on the Atomics object that introduce ReadModifyWriteSharedMemory events.</p>
      </emu-note>

      <emu-note>
        <p>This subroutine composes a List of write events into a List of byte values. It is used in the event semantics of ReadSharedMemory and ReadModifyWriteSharedMemory events.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.ValueOfReadEvent" aoid="ValueOfReadEvent">
      <h1>ValueOfReadEvent( _execution_, _R_ )</h1>
      <p>The abstract operation ValueOfReadEvent takes two arguments, a candidate execution _execution_ and a Shared Data Block event _R_.</p>
      <p>It returns a List using the following steps.</p>

      <emu-alg>
        1. Assert: _R_ is a ReadSharedMemory or ReadModifyWriteSharedMemory event.
        1. Let reads-from be _execution_.[[ReadsFrom]].
        1. Let _Ws_ be the List of events such that _R_ reads-from _Ws_.
        1. Assert: _Ws_ has length equal to _R_.[[ElementSize]].
        1. Return ComposeWriteEventBytes(_execution_, _R_.[[Block]], _R_.[[ByteIndex]], _Ws_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.ValidChosenReads">
      <h1>Valid Chosen Reads</h1>
      <p>A candidate execution _execution_ has valid chosen reads if the following conditions hold.</p>

      <emu-alg>
        1. For each ReadSharedMemory and ReadModifyWriteSharedMemory event _R_ in _execution_.[[EventSet]]:
           1. _execution_.[[ChosenValues]](_R_) is equal to ValueOfReadEvent(_execution_, _R_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.NoOutOfThinAirReads">
      <h1>No Out of Thin Air Reads</h1>
      <p>A candidate execution has no out of thin air reads if there is no cycle in the union of the relations _execution_.[[ReadsFrom]] and _execution_.[[DependsOn]].</p>

      <emu-note>
        <p>Out of thin air reads is an artifact of memory models rather than implementation reality. For other languages with similar memory models, thin air reads have not been observed on any known hardware nor due to any known compiler transform.</p>
      </emu-note>

      <emu-note>
        <p>(Spec draft notes)</p>
        <p>This is intentionally underspecified. Precisely capturing and forbidding OOTA is currently an open problem.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.TearFreeAlignedReads">
      <h1>Tear Free Reads</h1>
      <p>A candidate execution _execution_ has tear free reads if the following conditions hold.</p>
      <emu-alg>
        1. Let reads-from be _execution_.[[ReadsFrom]].
        1. For each ReadSharedMemory or ReadModifyWriteSharedMemory event _R_ in _execution_.[[EventSet]]:
          1. If _R_.[[NoTear]] is *true* then
            1. Assert that the remainder of _R_.[[ByteIndex]] ÷ _R_.[[ElementSize]] is *0*.
            1. For each event _W_ such that _R_ reads-from _W_ and _W_.[[NoTear]] value is *true*:
              1. If _R_ and _W_ have equal ranges then there is no _V_ such that _V_ and _W_ have equal range, _V_.[[NoTear]] is *true*, _W_ is not _V_, and _R_ reads-from _V_.
      </emu-alg>

      <emu-note>
        <p>Intuitively, this requirement says when a memory range is accessed in an aligned fashion via a TypedArray instead of a DataView, a single write event on that range must "win" when in a data race with other write events with equal ranges. More precisely, this requirement says an aligned read event cannot read a value composed of bytes from multiple, different write events all with equal ranges. It is possible, however, for an aligned read event to read from multiple write events with overlapping ranges. See Access Atomicity below.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.MemoryOrder" aoid="memory-order">
      <h1>memory-order</h1>
      <p>For a candidate execution _execution_, _memory-order_ is a total order on the subset of `"SeqCst"` or `"Init"` events in _execution_.[[EventSet]] such that the following conditions hold.</p>

      <emu-alg>
        1. Let happens-before be _execution_.[[HappensBefore]].
        1. Let synchronizes-with be _execution_.[[SynchronizesWith]].
        1. For each pair of events _E_ and _D_ in the subset of events with [[Order]] `"SeqCst"` or `"Init"` in _execution_.[[EventSet]]:
          1. If _E_ happens-before _D_ then _E_ is memory-order before _D_.
          1. If _E_ synchronizes-with _D_ then
            1. Assert: _D_ has _order_ `"SeqCst"`.
            1. There is no WriteSharedMemory or ReadModifyWriteSharedMemory event _W_ in _execution_.[[EventSet]] with equal range as _D_ such that _E_ is memory-order before _W_ and _W_ is memory-order before _D_.
            1. NOTE: This clause constrains `"SeqCst"` events on equal ranges, not all `"SeqCst"` events.
      </emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.SequentiallyConsistentAtomics">
      <h1>Sequentially Consistent Atomics</h1>
      <p>A candidate execution has sequentially consistent atomics if it admits a memory-order.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.ValidExecutions">
      <h1>Valid Executions</h1>
      <p>A candidate execution _execution_ is a valid execution (or simply an "execution") if the following conditions hold.</p>

      <emu-alg>
        1. _execution_ has valid chosen reads, and
        1. _execution_ has no out of thin air reads, and
        1. _execution_ has tear free reads, and
        1. _execution_ has sequentially consistent atomics.
      </emu-alg>

      <p>All programs have at least one valid execution.</p>

      <emu-note>
        <p>The candidate execution where all events are interleaved and a read event always reads from the set of most recent write events is always admitted as a valid execution. That is, the execution where all events are treated as if they were `"SeqCst"` is always admitted.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.Races" aoid="race">
      <h1>Races</h1>
      <p>For an execution _execution_, two events _E_ and _D_ in _execution_.[[EventSet]] are in a race if the following conditions hold.</p>

      <emu-alg>
        1. Let happens-before be _execution_.[[HappensBefore]].
        1. Let reads-from be _execution_.[[ReadsFrom]].
        1. It is not the case that _E_ happens-before _D_ or _D_ happens-before _E_, and
        1. If _E_ and _D_ are both WriteSharedMemory or ReadModifyWriteSharedMemory events then
          1. _E_ and _D_ do not have disjoint ranges.
        1. Otherwise:
          1. _E_ reads-from _D_ or _D_ reads-from _E_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.DataRaces" aoid="data race">
      <h1>Data Races</h1>
      <p>For an execution _execution_, two events _E_ and _D_ in _execution_.[[EventSet]] are in a data race if the following conditions hold.</p>

      <emu-alg>
        1. _E_ and _D_ are in a race in _execution_, and
        1. At least one of _E_ or _D_ does not have [[Order]] `"SeqCst"` or _E_ and _D_ have overlapping ranges.
      </emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.DRF" aoid="data race free">
      <h1>Data Race Freedom</h1>
      <p>An execution _execution_ is data race free if there are no two events in _execution_.[[EventSet]] that are in a data race.</p>
      <p>A program is data race free if all its executions are data race free.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.AccessAtomicity">
      <h1>Access Atomicity (informative)</h1>

      <p>In an execution, a ReadSharedMemory or ReadModifyWriteSharedMemory event is access atomic when it reads-from a single WriteSharedMemory event or ReadModifyWriteSharedMemory event.</p>

      <p>The Tear Free Reads requirement does not guarantee access atomicity for non-atomic events. Consider the following program where `U8` and `U16` are aliased 1-byte and 2-byte views on the same Shared Data Block and `a` and `b` represent the same memory address (scaled appropriately for the data type).</p>

      <pre>   W1: U16[a] = 1; W2: U8[b] = 2;
|| W3: U16[a] = 3;
||  R: observe(U16[a]);</pre>

      <p>A candidate execution where all the following hold is a valid execution.</p>

      <ul>
        <li>`R` reads-from `W1`</li>
        <li>`R` reads-from `W2`</li>
      </ul>

      <p>`R` reads a value composed of bytes from `W1` and `W2`, and is thus not access atomic. At the same time, it does not read-from both `W2` and `W3`, and thus is tear free.</p>

      <p>Similarly, neither the synchronizes-with relation, the Sequentially Consistent Atomics requirement guarantees access atomicity for atomic events. Both are concerned with ordering of atomic operations on equal ranges, but it is possible to have sequentially consistent equal-ranged atomics without access atomicity. For example, consider the following program where `U8` and `U16` are aliased 1-byte and 2-byte views on the same Shared Data Block.</p>

      <pre>   W1: Atomics.store(U16, a, 1); W2: Atomics.store(U8, b, 2);
|| W3: Atomics.store(U16, a, 3);
||  R: observe(Atomics.load(U16, a));</pre>

      <p>A candidate execution where all of the following hold is a valid execution.</p>

      <ul>
        <li>`R` synchronizes-with `W1`</li>
        <li>`R` reads-from `W1`</li>
        <li>`R` reads-from `W2`</li>
        <li>`W1` is memory-order before `W2` and `W2` is memory-order before `R` and `R` is memory-order before `W3`</li>
      </ul>

      <p>`W2` is allowed to come between `W1` and `R` in memory-order because it and `R` do not have equal ranges. Thus, `R` may read a value composed of bytes written by both `W1` and `W2`.</p>

      <p>Finally, data race freedom and sequential consistency do not imply access atomicity. Consider the following program with a single agent.</p>

      <pre>W1: Atomics.store(U16, a, 1); W2: Atomics.store(U8, b, 2); R: observe(Atomics.load(U16, a));</pre>

      <p>The only valid execution is as follows.</p>

      <ul>
        <li>`R` synchronizes-with `W1`</li>
        <li>`R` reads-from `W1`</li>
        <li>`R` reads-from `W2`</li>
        <li>`W1` is memory-order before `W2` and `W2` is memory-order before `R`</li>
      </ul>

      <p>All valid executions of the program are data race free, since there is a single thread. But `R` is not access atomic since it reads-from multiple events.</p>

      <p>The central problem the memory model solves is the ordering of memory events. The SharedArrayBuffer API's lack of type discipline and allowance of overlapping accesses makes access atomicity an orthogonal property from event ordering.</p>
      <p>A program wishing to avoid reasoning about access atomicity or wishing to guarantee all its aligned and atomic accesses are access atomic should avoid accesses on overlapping ranges. When a program does not use address ranges in an overlapping fashion, aligned and atomic accesses are access atomic.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.SeqCst">
      <h1>Sequential Consistency (informative)</h1>
      <p>The memory model guarantees sequential consistency of all events for data race free programs.</p>
      <emu-note>
        <p>A formal proof of the property requires the host to provide a depends-on relation that prohibits out of thin air reads.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="AtomicsMethods">
    <h1>Methods</h1>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1>ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )</h1>
      <emu-alg>
        1. If Type(_typedArray_) is not Object, throw a *TypeError* exception.
        1. If _typedArray_ does not have a [[TypedArrayName]] internal slot, throw a *TypeError* exception.
        1. Let _typeName_ be _typedArray_.[[TypedArrayName]].
        1. If _onlyInt32_ is *true* then
          1. If _typeName_ is not `"Int32Array"` then throw a *TypeError* exception.
        1. Else,
          1. If _typeName_ is not `"Int8Array"`, `"Uint8Array"`, `"Int16Array"`, `"Uint16Array"`, `"Int32Array"`, or `"Uint32Array"` then throw a *TypeError* exception.
        1. If _typedArray_ does not have a [[ViewedArrayBuffer]] internal slot, throw a *TypeError* exception.
        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].
        1. If Type(_buffer_) is not Object, throw a *TypeError* exception.
        1. If _buffer_ does not have an [[ArrayBufferData]] internal slot, throw a *TypeError* exception.
        1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.
        1. Return _buffer_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1>ValidateAtomicAccess( _typedArray_, _requestIndex_ )</h1>
      <p>Perform the following steps:</p>
      <emu-alg>
        1. Assert: _typedArray_ is an Object that has a [[ViewedArrayBuffer]] internal slot.
        1. Let _numberIndex_ be ? ToNumber(_requestIndex_).
        1. Let _accessIndex_ be ToInteger(_numberIndex_).
        1. If _numberIndex_ &ne; _accessIndex_, throw a *RangeError* exception.
        1. Let _length_ be _typedArray_.[[ArrayLength]].
        1. If _accessIndex_ &lt; 0 or _accessIndex_ &ge; _length_, throw a *RangeError* exception.
        1. Return _accessIndex_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1>AgentSignifier( )</h1>
      <p>When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg>
        1. Let _AR_ be the Agent Record of the <em>surrounding agent</em>.
        1. Let _W_ be _AR_.[[Signifier]].
        1. Return _W_.
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.AgentCanSuspend" aoid="AgentCanSuspend">
      <h1>AgentCanSuspend( )</h1>
      <p>When AgentCanSuspend is called without arguments then the following steps are taken.</p>
      <emu-alg>
        1. Let _AR_ be the Agent Record of the <em>surrounding agent</em>.
        1. Let _B_ be _AR_.[[CanBlock]].
        1. Return _B_.
      </emu-alg>

      <emu-note>
        <p>In some environments it may not be reasonable for a given agent to suspend.  For example,
          in a web browser environment, it may be reasonable to disallow suspending a document's main event
          handling thread, while still allowing workers' event handling threads to suspend.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="GetWaiterList" aoid="GetWaiterList">
      <h1>GetWaiterList( _block_, _i_ )</h1>
      <p>A <dfn>WaiterList</dfn> is a semantic object that contains an ordered list of those agents that are waiting on a location (_block_, _i_) in shared memory; _block_ is a Shared Data Block and _i_ a byte offset into the memory of _block_.</p>
      <p>The agent cluster has a store of WaiterList objects; the store is indexed by (_block_, _i_).  WaiterLists are agent-independent: a lookup in the store of WaiterLists by (_block_, _i_) will result in the same WaiterList object in any agent in the agent cluster.</p>
      <p>Operations on a WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and waking agents on the list -- may only be performed by agents that have entered the WaiterList's critical section.</p>
      <p>When GetWaiterList is called with Shared Data Block _block_ and nonnegative integer _i_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: _block_ is a Shared Data Block.
        1. Assert: _i_ and _i_+3 are valid byte offsets within the memory of _block_.
        1. Assert: _i_ is divisible by 4.
        1. Return the WaiterList that is referenced by the pair (_block_, _i_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="EnterCriticalSection" aoid="EnterCriticalSection">
      <h1>EnterCriticalSection( _WL_ )</h1>
      <p>When EnterCriticalSection is called with WaiterList _WL_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is not in the critical section for any WaiterList.
        1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).
      </emu-alg>
    </emu-clause>

    <emu-clause id="LeaveCriticalSection" aoid="LeaveCriticalSection">
      <h1>LeaveCriticalSection( _WL_ )</h1>
      <p>When LeaveCriticalSection is called with WaiterList _WL_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Leave the critical section for _WL_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1>AddWaiter( _WL_, _W_ )</h1>
      <p>When AddWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Assert: _W_ is not on the list of waiters in any WaiterList.
        1. Add _W_ to the end of the list of waiters in _WL_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1>RemoveWaiter( _WL_, _W_ )</h1>
      <p>When RemoveWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Assert: _W_ is on the list of waiters in _WL_.
        1. Remove _W_ from the list of waiters in _WL_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1>RemoveWaiters( _WL_, _c_ )</h1>
      <p>When RemoveWaiters is called with WaiterList _WL_ and nonnegative integer _c_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Let _L_ be the empty list.
        1. Let _S_ be a reference to the list of waiters in _WL_.
        1. While _c_ &gt; 0 and _S_ is not the empty list:
          1. Let _W_ be the first waiter in _S_.
          1. Add _W_ to the end of _L_.
          1. Remove _W_ from _S_.
          1. Subtract 1 from _c_.
        1. Return _L_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1>Suspend( _WL_, _W_, _timeout_ )</h1>
      <p>When Suspend is called with WaiterList _WL_, agent signifier _W_, and nonnegative, non-*NaN* Number _timeout_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Assert: _W_ is equal to AgentSignifier().
        1. Assert: _W_ is on the list of waiters in _WL_.
        1. Assert: AgentCanSuspend() is equal to true.
        1. Perform LeaveCriticalSection(_WL_) and suspend _W_ for up to _timeout_ milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost.  _W_ can wake up either because the timeout expired or because it was woken explicitly by another agent calling WakeWaiter(_WL_, _W_), and not for any other reasons at all.
        1. Perform EnterCriticalSection(_WL_).
        1. If _W_ was woken explicitly by another agent calling WakeWaiter(_WL_, _W_), then return *true*.
        1. Return *false*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1>WakeWaiter( _WL_, _W_ )</h1>
      <p>When WakeWaiter is called with WaiterList _WL_ and agent signifier _W_, then the following steps are taken.</p>
      <emu-alg>
        1. Assert: The calling agent is in the critical section for _WL_.
        1. Assert: _W_ is on the list of waiters in _WL_.
        1. Wake the agent _W_.
      </emu-alg>

      <emu-note>
        <p>The embedding may delay waking _W_, eg for resource management reasons, but _W_ must eventually be woken in order to guarantee forward progress.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="Atomics.ReadModifyWrite" aoid="AtomicReadModifyWrite">
      <h1>AtomicReadModifyWrite( _typedArray_, _index_, _value_, _op_ )</h1>
      <p>AtomicReadModifyWrite is a semantic function that atomically loads a value, combines it with another value, and stores the result of the combination.  It returns the loaded value.  It is parameterized by the (pure) combining operation _op_ that takes two List of byte values arguments and returns a List of byte values.  The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _v_ be ? ToInteger(_value_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Return GetModifySetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _value_, _op_).
      </emu-alg>
    </emu-clause>
  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1>Function Properties of the Atomics Object</h1>

    <emu-clause id="Atomics.add">
      <h1>Atomics.add( _typedArray_, _index_, _value_ )</h1>
      <p>Let `add` denote a semantic function of two List of byte values arguments that applies the addition operation to the Number values corresponding to the List of byte values arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicReadModifyWrite(_typedArray_, _index_, _value_, `add`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.and">
      <h1>Atomics.and( _typedArray_, _index_, _value_ )</h1>
      <p>Let `and` denote a semantic function of two List of byte values arguments that applies the bitwise-and operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicReadModifyWrite(_typedArray_, _index_, _value_, `and`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.compareExchange">
      <h1>Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )</h1>
      <p>Let `compareExchange` denote a semantic function of two List of byte values arguments that returns the second argument if the first argument is element-wise equal to the List of byte values corresponding to _expectedValue_.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicReadModifyWrite(_typedArray_, _index_, _replacementValue_, `compareExchange`);
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1>Atomics.exchange( _typedArray_, _index_, _value_ )</h1>
      <p>Let `second` denote a semantic function of two List of byte values arguments that returns its second argument.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicReadModifyWrite(_typedArray_, _index_, _value_, `second`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1>Atomics.isLockFree( _size_ )</h1>

      <emu-alg>
        1. Let _n_ be ? ToInteger(_size_).
        1. Let _AR_ be the Agent Record of the <em>surrounding agent</em>.
        1. If _n_ equals 1 then return _AR_.[[IsLockFree1]].
        1. If _n_ equals 2 then return _AR_.[[IsLockFree2]].
        1. If _n_ equals 4 then return *true*.
        1. Return *false*.
      </emu-alg>

      <emu-note>
        <p>Atomics.isLockFree() is an optimization primitive.  The
          intuition is that if the atomic step of an atomic primitive
          (`compareExchange`, `load`, `store`, `add`, `sub`, `and`,
          `or`, `xor`, or `exchange`) on a datum of size _n_ bytes
          will be performed without the calling agent acquiring a lock
          outside the _n_ bytes comprising the datum, then
          Atomics.isLockFree(_n_) will return *true*.
          High-performance algorithms will use Atomics.isLockFree to
          determine whether to use locks or atomic operations in
          critical sections.  If an atomic primitive is not lock-free
          then it is often more efficient for an algorithm to provide
          its own locking.</p>

        <p>Atomics.isLockFree(4) always returns *true* as that can be
          supported on all known relevant hardware.  Being able to
          assume this will generally simplify programs.</p>

      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1>Atomics.load( _typedArray_, _index_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in <emu-xref href="#table-49"></emu-xref> for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Return GetValueFromBuffer(_buffer_, _indexedPosition_, _elementType_, *true*, `"SeqCst"`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1>Atomics.or( _typedArray_, _index_, _value_ )</h1>
      <p>Let `or` denote a semantic function of two List of byte values arguments that applies the bitwise-or operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicReadModifyWrite(_typedArray_, _index_, _value_, `or`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.store">
      <h1>Atomics.store( _typedArray_, _index_, _value_ )</h1>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _v_ be ? ToInteger(_value_).
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _elementSize_ be the Number value of the Element Size value specified in Table 49 for _arrayTypeName_.
        1. Let _elementType_ be the String value of the Element Type value in Table 49 for _arrayTypeName_.
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; _elementSize_) + _offset_.
        1. Perform SetValueInBuffer(_buffer_, _indexedPosition_, _elementType_, _v_, *true*, `"SeqCst"`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.sub">
      <h1>Atomics.sub( _typedArray_, _index_, _value_ )</h1>
      <p>Let `subtract` denote a semantic function of two List of byte values arguments that applies the subtraction operation to the Number values corresponding to the List of byte values arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicReadModifyWrite(_typedArray_, _index_, _value_, `subtract`).
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.wait">
      <h1>Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )</h1>
      <p>Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. Let _v_ be ? ToInt32(_value_).
        1. If _timeout_ is not provided or is *undefined* then let _t_ be *+&infin;*.  Otherwise:
          1. Let _q_ be ? ToNumber(_timeout_).
          1. If _q_ is *NaN* then let _t_ be *+&infin;*, otherwise let _t_ be max(0, _q_).
        1. Let _B_ be AgentCanSuspend().
        1. If _B_ is *false* then throw a *TypeError* exception.
        1. Let _bufferVal_ be _buffer_.[[ArrayBufferData]].
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_.
        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
        1. Perform EnterCriticalSection(_WL_).
        1. Let _w_ be Atomics.load(_typedArray_, _i_).
        1. If _v_ does not equal _w_ then
          1. Perform LeaveCriticalSection(_WL_).
          1. Return the string `"not-equal"`.
        1. Let _W_ be AgentSignifier().
        1. Perform AddWaiter(_WL_, _W_).
        1. Let awoken be Suspend(_WL_, _W_, _t_).
        1. Perform RemoveWaiter(_WL_, _W_).
        1. Perform LeaveCriticalSection(_WL_).
        1. If awoken is *true* then return the string `"ok"`.
        1. Return the string `"timed-out"`.
      </emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.wake">
      <h1>Atomics.wake( _typedArray_, _index_, _count_ )</h1>
      <p>Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken:</p>
      <emu-alg>
        1. Let _buffer_ be ? ValidateSharedIntegerTypedArray(_typedArray_, *true*).
        1. Let _i_ be ? ValidateAtomicAccess(_typedArray_, _index_).
        1. If _count_ is not provided or is *undefined* then let _c_ be *+&infin;*.  Otherwise:
          1. Let _tmp_ be ? ToInteger(_count_).
          1. Let _c_ be max(*+0*, _tmp_).
        1. Let _bufferVal_ be _buffer_.[[ArrayBufferData]].
        1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].
        1. Let _offset_ be _typedArray_.[[ByteOffset]].
        1. Let _indexedPosition_ be (_i_ &times; 4) + _offset_.
        1. Let _WL_ be GetWaiterList(_block_, _indexedPosition_).
        1. Let _n_ be 0.
        1. Perform EnterCriticalSection(_WL_).
        1. Let _S_ be RemoveWaiters(_WL_, _c_).
        1. While _S_ is not the empty list:
          1. Let _W_ be the first agent in _S_.
          1. Remove _W_ from the front of _S_.
          1. Perform WakeWaiter(_WL_, _W_).
          1. Add 1 to _n_.
        1. Perform LeaveCriticalSection(_WL_).
        1. Return _n_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.xor">
      <h1>Atomics.xor( _typedArray_, _index_, _value_ )</h1>
      <p>Let `xor` denote a semantic function of two List of byte values arguments that applies the bitwise-xor operation element-wise to the two arguments and returns a List of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg>
        1. Return AtomicReadModifyWrite(_typedArray_, _index_, _value_, `xor`).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="CompilerTransforms">
    <h1>Compiler Transform Guidelines</h1>
    <p>Given a host-defined notion of observable behavior of programs, the following restrictions apply to compiler transforms for non-atomics operations.</p>

    <ul>
      <li>An API call introducing a single Shared Data Block event that affects observable behavior cannot be transformed into API calls introducing multiple Shared Data Block events.
      <li>API calls introducing WriteSharedMemory or ReadModifyWriteSharedMemory events that affect observable behavior may not have their ranges narrowed.
      <li>API calls introducing WriteSharedMemory or ReadModifyWriteSharedMemory events that affect observable behavior may not be removed.
      <li>API calls introducing WriteSharedMemory or ReadModifyWriteSharedMemory events that both affect observable behavior and would not have otherwise arisen may not be introduced.
    </ul>

    <emu-note>
      <p>API calls introducing Shared Data Block events may be introduced, elided, or merged if they do not affect observable behavior of the program. For example, nonbinding prefetches of cache lines, assuming correctness of invalidations, are allowed. Contrastingly, rematerializing an observable read is not. For example, the following two programs are not equivalent.</p>

      <pre>let x = M[a]; if (x) observe(x);</pre>

      <p>and</p>

      <pre>if (M[a]) observe(M[a]);</pre>
    </emu-note>

    <p>The following additional restrictions apply to compiler transforms for atomic operations.</p>

    <ul>
      <li>API calls introducing `"SeqCst"` events that affect observable behavior may not be reordered.
    </ul>

    <p>The following additional restriction apply to compiler transforms for data race free programs.</p>

    <ul>
      <li>API calls introducing Shared Data Block events that do not affect observable behavior may not be transformed to API calls that result in shared memory events that affect observable behavior.
    </ul>

    <emu-note>
      <p>(Spec draft note): This proviso is intended to prohibit transforms that leak information.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="Codegen">
    <h1>Code Generation Guidelines</h1>
    <p>For architectures with memory models no weaker than those of ARM or Power, non-atomic stores and loads may be compiled to bare stores and loads on the target architecture. Atomic stores and loads may be compiled down to instructions that guarantee sequential consistency. If no such instructions exist, memory barriers are to be employed, such as placing barriers on both sides of a bare store or load. Read-modify-write operations may be compiled to read-modify-write instructions on the target architectrue, such as `LOCK`-prefixed instructions on x86 and load-link/store-conditional instructions on ARM.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1>Web browser embedding (informative)</h1>

  <p>This section outlines how the Shared Memory and Atomics
    specification fits into the current web ecosystem with the minimum
    amount of change to that ecosystem.  This section is not part of
    the proposal, it is informative only.</p>

  <p>In a web browser an <em>agent</em> is an HTML <em>event
    loop</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">[here]</a>.
    The event loop is realized as either a main thread (which may be
    shared among tabs, as it is in Firefox) or some type of worker
    thread.  The event loops are running jobs in the sense of ES262,
    and the forward-progress requirement of this specification
    (section&nbsp;3.1.1) is generally met as long as each agent has
    its own dedicated operating system thread or shared-thread agents
    can't block.</p>

  <p>Browsers will typically let agents that run on the browser's
    main thread have [[CanBlock]] equal to *false*, to prevent blocking the
    UI and to allow the main thread to do work on behalf of other
    threads.</p>

  <p>Normal ("dedicated") `Worker`s must be supported as agents for
    this proposal to make much sense.</p>

  <p>Memory will be shared among agents by using `postMessage` to
    transmit SharedArrayBuffer objects or TypedArray objects that
    have SharedArrayBuffer buffers; this requires an extension to
    the Structured Clone mechanism.  There is agreement on the general
    syntax and semantics for that extension.</p>

  <p>Agent-to-agent communication extends the synchronizes-with relation
    of the program, as follows:</p>

  <ul>
    <li>The call to the `Worker` constructor in the parent
      synchronizes-with the execution of the main script in the worker.

    <li>(Worker termination is not directly observable in current
      browsers, but this is a moot point; see below.)

    <li>A `postMessage` to another agent synchronizes-with the event
      that fires in the agent.
 </ul>

  <p>So long as the browser does not allow a `ServiceWorker` or
    `SharedWorker` ("non-page worker") to share memory with a `Worker`
    it will not violate the suspend/wake cohort rule of this
    specification (section&nbsp;3.3).  The restriction on sharing
    memory can be implemented in the extension to the Structured Clone
    mechanism.  For example, a non-page worker may simply not be
    allowed to receive shared memory (leading to a null value or an
    error signal).  There is not yet any agreement on this point, but
    it is clear that the restriction must be on the receiving side of
    the communication, as the sender may be sending on a `MessagePort`
    that is not yet connected, but may in the future be connected to
    either a valid or invalid recipient.</p>

  <p>At the moment, I believe dedicated workers are in the same
    process as their owning tab in all browsers, so if the process
    crashes then the workers will crash too.  I also don't know any
    reason a browser should forcibly terminate a worker except when a
    tab is closed.  In sum, the termination signaling requirement of
    this specification (section&nbsp;3.3) is probably met by existing
    browsers.</p>

  <p>The web platform should evolve to serve the shared memory use
    case better: by incorporating inspectable worker state and worker
    lifecycle events, and by tightening the wording in the HTML spec
    (currently the browser is allowed to kill a worker at any time for
    any reason, which is not quite what we want).  WebIDL should
    evolve to allow Web APIs to be described as to when they can and
    cannot receive shared memory parameters.  However, only an
    extension to the Structured Clone algorithm is needed to support
    the Shared Memory and Atomics specification in practice on current
    browsers.</p>

</emu-clause>
