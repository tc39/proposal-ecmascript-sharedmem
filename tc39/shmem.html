<!doctype html>
<head><meta charset="utf-8">
<title>ECMAScript Shared Memory and Atomics</title><script type="application/json" id="menu-search-biblio">[{"type":"clause","id":"intro","aoid":null,"title":"Introduction","number":"","namespace":"<no location>","location":"","key":"Introduction"},{"type":"clause","id":"Overview","aoid":null,"title":"Overview (ES7 4)","number":"1","namespace":"<no location>","location":"","key":"Overview (ES7 4)"},{"type":"clause","id":"Overview.Overview","aoid":null,"title":"ECMAScript Overview (ES7 4.2)","number":"1.1","namespace":"<no location>","location":"","key":"ECMAScript Overview (ES7 4.2)"},{"type":"clause","id":"DataTypesValues","aoid":null,"title":"ECMAScript Data Types and Values (ES7 6)","number":"2","namespace":"<no location>","location":"","key":"ECMAScript Data Types and Values (ES7 6)"},{"type":"clause","id":"DataTypesValues.LanguageTypes","aoid":null,"title":"ECMAScript Language Types (ES7 6.1)","number":"2.1","namespace":"<no location>","location":"","key":"ECMAScript Language Types (ES7 6.1)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Number","aoid":null,"title":"The Number Type (ES7 6.1.6)","number":"2.1.1","namespace":"<no location>","location":"","key":"The Number Type (ES7 6.1.6)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Object","aoid":null,"title":"The Object Type (ES7 6.1.7)","number":"2.1.2","namespace":"<no location>","location":"","key":"The Object Type (ES7 6.1.7)"},{"type":"clause","id":"DataTypesValues.LanguageTypes.Object.Intrinsic","aoid":null,"title":"Well-Known Intrinsic Objects (ES7 6.1.7.4)","number":"2.1.2.1","namespace":"<no location>","location":"","key":"Well-Known Intrinsic Objects (ES7 6.1.7.4)"},{"type":"clause","id":"DataTypesValues.SpecTypes","aoid":null,"title":"ECMAScript Specification Types (ES7 6.2)","number":"2.2","namespace":"<no location>","location":"","key":"ECMAScript Specification Types (ES7 6.2)"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks","aoid":null,"title":"Data blocks (ES7 6.2.6)","number":"2.2.1","namespace":"<no location>","location":"","key":"Data blocks (ES7 6.2.6)"},{"type":"op","aoid":"CopyDataBlockBytes","refId":"DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes","location":"","key":"CopyDataBlockBytes"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes","aoid":"CopyDataBlockBytes","title":"CopyDataBlockBytes( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)","number":"2.2.1.1","namespace":"<no location>","location":"","key":"CopyDataBlockBytes( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)"},{"type":"op","aoid":"CreateSharedByteDataBlock","refId":"DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock","location":"","key":"CreateSharedByteDataBlock"},{"type":"clause","id":"DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock","aoid":"CreateSharedByteDataBlock","title":"CreateSharedByteDataBlock( _size_ )","number":"2.2.1.2","namespace":"<no location>","location":"","key":"CreateSharedByteDataBlock( _size_ )"},{"type":"clause","id":"ExecutableCodeAndContexts","aoid":null,"title":"Executable Code and Execution Contexts (ES7 8)","number":"3","namespace":"<no location>","location":"","key":"Executable Code and Execution Contexts (ES7 8)"},{"type":"clause","id":"ExecutableCodeAndContexts.JobsAndJobQueues","aoid":null,"title":"Jobs and Job Queues (ES7 8.4)","number":"3.1","namespace":"<no location>","location":"","key":"Jobs and Job Queues (ES7 8.4)"},{"type":"clause","id":"ExecutableCodeAndContexts.JobsAndJobQueues.Progress","aoid":null,"title":"Forward Progress Guarantees","number":"3.1.1","namespace":"<no location>","location":"","key":"Forward Progress Guarantees"},{"type":"clause","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agents (AMENDMENTS)","number":"3.2","namespace":"<no location>","location":"","key":"Agents (AMENDMENTS)"},{"type":"clause","id":"ExecutableCodeAndContexts.AgentCluster","aoid":null,"title":"Agent Clusters (NEW)","number":"3.3","namespace":"<no location>","location":"","key":"Agent Clusters (NEW)"},{"type":"clause","id":"GlobalObject","aoid":null,"title":"The Global Object (ES7 18)","number":"4","namespace":"<no location>","location":"","key":"The Global Object (ES7 18)"},{"type":"clause","id":"GlobalObject.ConstructorProps","aoid":null,"title":"Constructor Properties of the Global Object (ES7 18.3)","number":"4.1","namespace":"<no location>","location":"","key":"Constructor Properties of the Global Object (ES7 18.3)"},{"type":"clause","id":"GlobalObject.ConstructorProps.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer","number":"4.1.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer"},{"type":"clause","id":"GlobalObject.ConstructorProps.Atomics","aoid":null,"title":"Atomics","number":"4.1.2","namespace":"<no location>","location":"","key":"Atomics"},{"type":"clause","id":"IndexedCollections","aoid":null,"title":"Indexed Collections (ES7 22)","number":"5","namespace":"<no location>","location":"","key":"Indexed Collections (ES7 22)"},{"type":"clause","id":"IndexedCollections.TypedArray","aoid":null,"title":"TypedArray Objects (ES7 22.2)","number":"5.1","namespace":"<no location>","location":"","key":"TypedArray Objects (ES7 22.2)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype","aoid":null,"title":"Properties of the %TypedArrayPrototype% object (ES7 22.2.3)","number":"5.1.1","namespace":"<no location>","location":"","key":"Properties of the %TypedArrayPrototype% object (ES7 22.2.3)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.set","aoid":null,"title":"%TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)","number":"5.1.1.1","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.setFromTypedArray","aoid":null,"title":"%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)","number":"5.1.1.1.1","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.setFromTypedArray","aoid":null,"title":"%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)","number":"5.1.1.1.2","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)"},{"type":"clause","id":"IndexedCollections.TypedArray.prototype.slice","aoid":null,"title":"%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)","number":"5.1.1.1.3","namespace":"<no location>","location":"","key":"%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)"},{"type":"clause","id":"IndexedCollections.TypedArray.constructors","aoid":null,"title":"The %TypedArray% constructors (ES7 22.2.4)","number":"5.1.2","namespace":"<no location>","location":"","key":"The %TypedArray% constructors (ES7 22.2.4)"},{"type":"clause","id":"sec-typedarray-typedarray","aoid":null,"title":"_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)","number":"5.1.2.1","namespace":"<no location>","location":"","key":"_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)"},{"type":"clause","id":"StructuredData","aoid":null,"title":"Structured Data (ES7 24)","number":"6","namespace":"<no location>","location":"","key":"Structured Data (ES7 24)"},{"type":"clause","id":"StructuredData.ArrayBuffer","aoid":null,"title":"ArrayBuffer Objects (ES7 24.1)","number":"6.1","namespace":"<no location>","location":"","key":"ArrayBuffer Objects (ES7 24.1)"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for ArrayBuffer (ES7 24.1.1)","number":"6.1.1","namespace":"<no location>","location":"","key":"Abstract Operations for ArrayBuffer (ES7 24.1.1)"},{"type":"op","aoid":"DetachArrayBuffer","refId":"sec-detacharraybuffer","location":"","key":"DetachArrayBuffer"},{"type":"clause","id":"sec-detacharraybuffer","aoid":"DetachArrayBuffer","title":"DetachArrayBuffer ( _arrayBuffer_ ) (ES7 24.1.1.3)","number":"6.1.1.1","namespace":"<no location>","location":"","key":"DetachArrayBuffer ( _arrayBuffer_ ) (ES7 24.1.1.3)"},{"type":"op","aoid":"RawBytesToNumber","refId":"StructuredData.ArrayBuffer.abstract.RawBytesToNumber","location":"","key":"RawBytesToNumber"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.RawBytesToNumber","aoid":"RawBytesToNumber","title":"RawBytesToNumber( _type_, _rawBytes_, _isLittleEndian_ )","number":"6.1.1.2","namespace":"<no location>","location":"","key":"RawBytesToNumber( _type_, _rawBytes_, _isLittleEndian_ )"},{"type":"op","aoid":"GetValueFromBuffer","refId":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","location":"","key":"GetValueFromBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.GetValueFromBuffer","aoid":"GetValueFromBuffer","title":"GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _order_ [, _isLittleEndian_] ) (ES7 24.1.1.5)","number":"6.1.1.3","namespace":"<no location>","location":"","key":"GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _order_ [, _isLittleEndian_] ) (ES7 24.1.1.5)"},{"type":"op","aoid":"NumberToRawBytes","refId":"StructuredData.ArrayBuffer.abstract.NumberToRawBytes","location":"","key":"NumberToRawBytes"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.NumberToRawBytes","aoid":"NumberToRawBytes","title":"NumberToRawBytes( _type_, _value_, _isLittleEndian_ )","number":"6.1.1.4","namespace":"<no location>","location":"","key":"NumberToRawBytes( _type_, _value_, _isLittleEndian_ )"},{"type":"op","aoid":"SetValueInBuffer","refId":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","location":"","key":"SetValueInBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.SetValueInBuffer","aoid":"SetValueInBuffer","title":"SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, _isTypedArray_, _order_ [, _isLittleEndian_] ) (ES7 24.1.1.6)","number":"6.1.1.5","namespace":"<no location>","location":"","key":"SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, _isTypedArray_, _order_ [, _isLittleEndian_] ) (ES7 24.1.1.6)"},{"type":"op","aoid":"GetModifySetValueInBuffer","refId":"StructuredData.ArrayBuffer.abstract.GetModifySetValueInBuffer","location":"","key":"GetModifySetValueInBuffer"},{"type":"clause","id":"StructuredData.ArrayBuffer.abstract.GetModifySetValueInBuffer","aoid":"GetModifySetValueInBuffer","title":"GetModifySetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, _op_ [, _isLittleEndian_] )","number":"6.1.1.6","namespace":"<no location>","location":"","key":"GetModifySetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, _op_ [, _isLittleEndian_] )"},{"type":"clause","id":"sec-properties-of-the-arraybuffer-prototype-object","aoid":null,"title":"Properties of the ArrayBuffer Prototype Object (ES7 24.1.4)","number":"6.1.2","namespace":"<no location>","location":"","key":"Properties of the ArrayBuffer Prototype Object (ES7 24.1.4)"},{"type":"clause","id":"sec-get-arraybuffer.prototype.bytelength","aoid":null,"title":"get ArrayBuffer.prototype.byteLength (ES7 24.1.4.1)","number":"6.1.2.1","namespace":"<no location>","location":"","key":"get ArrayBuffer.prototype.byteLength (ES7 24.1.4.1)"},{"type":"clause","id":"sec-arraybuffer.prototype.slice","aoid":null,"title":"ArrayBuffer.prototype.slice ( _start_, _end_ ) (ES7 24.1.4.3)","number":"6.1.2.2","namespace":"<no location>","location":"","key":"ArrayBuffer.prototype.slice ( _start_, _end_ ) (ES7 24.1.4.3)"},{"type":"clause","id":"StructuredData.SharedArrayBuffer","aoid":null,"title":"SharedArrayBuffer Objects","number":"6.2","namespace":"<no location>","location":"","key":"SharedArrayBuffer Objects"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract","aoid":null,"title":"Abstract Operations for SharedArrayBuffer","number":"6.2.1","namespace":"<no location>","location":"","key":"Abstract Operations for SharedArrayBuffer"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer","aoid":null,"title":"AllocateSharedArrayBuffer( _constructor_, _byteLength_ )","number":"6.2.1.1","namespace":"<no location>","location":"","key":"AllocateSharedArrayBuffer( _constructor_, _byteLength_ )"},{"type":"op","aoid":"IsSharedArrayBuffer","refId":"StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer","location":"","key":"IsSharedArrayBuffer"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer","aoid":"IsSharedArrayBuffer","title":"IsSharedArrayBuffer( _obj_ )","number":"6.2.1.2","namespace":"<no location>","location":"","key":"IsSharedArrayBuffer( _obj_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor","aoid":null,"title":"The SharedArrayBuffer Constructor","number":"6.2.1.3","namespace":"<no location>","location":"","key":"The SharedArrayBuffer Constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.withLength","aoid":null,"title":"SharedArrayBuffer( _length_ )","number":"6.2.1.3.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer( _length_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties","aoid":null,"title":"Properties of the SharedArrayBuffer constructor","number":"6.2.1.4","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties.prototype","aoid":null,"title":"SharedArrayBuffer.prototype","number":"6.2.1.4.1","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.constructor.properties.get_species","aoid":null,"title":"get SharedArrayBuffer [ @@species ]","number":"6.2.1.4.2","namespace":"<no location>","location":"","key":"get SharedArrayBuffer [ @@species ]"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype","aoid":null,"title":"Properties of the SharedArrayBuffer prototype object","number":"6.2.1.5","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer prototype object"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.get_byteLength","aoid":null,"title":"get SharedArrayBuffer.prototype.byteLength","number":"6.2.1.5.1","namespace":"<no location>","location":"","key":"get SharedArrayBuffer.prototype.byteLength"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.constructor","aoid":null,"title":"SharedArrayBuffer.prototype.constructor","number":"6.2.1.5.2","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype.constructor"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.slice","aoid":null,"title":"SharedArrayBuffer.prototype.slice( _start_, _end_ )","number":"6.2.1.5.3","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype.slice( _start_, _end_ )"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.prototype.toString","aoid":null,"title":"SharedArrayBuffer.prototype[ @@toStringTag ]","number":"6.2.1.5.4","namespace":"<no location>","location":"","key":"SharedArrayBuffer.prototype[ @@toStringTag ]"},{"type":"clause","id":"StructuredData.SharedArrayBuffer.instances","aoid":null,"title":"Properties of the SharedArrayBuffer instances","number":"6.2.1.6","namespace":"<no location>","location":"","key":"Properties of the SharedArrayBuffer instances"},{"type":"clause","id":"AtomicsObject","aoid":null,"title":"The Atomics Object","number":"6.3","namespace":"<no location>","location":"","key":"The Atomics Object"},{"type":"clause","id":"MemoryModel","aoid":null,"title":"Memory Model","number":"6.3.1","namespace":"<no location>","location":"","key":"Memory Model"},{"type":"clause","id":"MemoryModel.Relations","aoid":null,"title":"The Set and Relation Specification Types","number":"6.3.1.1","namespace":"<no location>","location":"","key":"The Set and Relation Specification Types"},{"type":"clause","id":"MemoryModel.Fundamentals","aoid":null,"title":"Fundamentals","number":"6.3.1.2","namespace":"<no location>","location":"","key":"Fundamentals"},{"type":"clause","id":"MemoryModel.AgentEventsRecords","aoid":null,"title":"Agent Events Records","number":"6.3.1.3","namespace":"<no location>","location":"","key":"Agent Events Records"},{"type":"clause","id":"MemoryModel.ChosenValueRecords","aoid":null,"title":"Chosen Value Records","number":"6.3.1.4","namespace":"<no location>","location":"","key":"Chosen Value Records"},{"type":"clause","id":"MemoryModel.CandidateExecutions","aoid":null,"title":"Candidate Executions","number":"6.3.1.5","namespace":"<no location>","location":"","key":"Candidate Executions"},{"type":"op","aoid":"EventSet","refId":"MemoryModel.EventSet","location":"","key":"EventSet"},{"type":"clause","id":"MemoryModel.EventSet","aoid":"EventSet","title":"EventSet( _execution_ )","number":"6.3.1.6","namespace":"<no location>","location":"","key":"EventSet( _execution_ )"},{"type":"op","aoid":"agent-order","refId":"MemoryModel.AgentOrder","location":"","key":"agent-order"},{"type":"clause","id":"MemoryModel.AgentOrder","aoid":"agent-order","title":"agent-order","number":"6.3.1.7","namespace":"<no location>","location":"","key":"agent-order"},{"type":"op","aoid":"host-synchronizes-with","refId":"MemoryModel.HostSynchronizesWith","location":"","key":"host-synchronizes-with"},{"type":"clause","id":"MemoryModel.HostSynchronizesWith","aoid":"host-synchronizes-with","title":"host-synchronizes-with","number":"6.3.1.8","namespace":"<no location>","location":"","key":"host-synchronizes-with"},{"type":"op","aoid":"synchronizes-with","refId":"MemoryModel.SynchronizesWith","location":"","key":"synchronizes-with"},{"type":"clause","id":"MemoryModel.SynchronizesWith","aoid":"synchronizes-with","title":"synchronizes-with","number":"6.3.1.9","namespace":"<no location>","location":"","key":"synchronizes-with"},{"type":"op","aoid":"happens-before","refId":"MemoryModel.HappensBefore","location":"","key":"happens-before"},{"type":"clause","id":"MemoryModel.HappensBefore","aoid":"happens-before","title":"happens-before","number":"6.3.1.10","namespace":"<no location>","location":"","key":"happens-before"},{"type":"op","aoid":"reads-bytes-from","refId":"MemoryModel.ReadBytesFrom","location":"","key":"reads-bytes-from"},{"type":"clause","id":"MemoryModel.ReadBytesFrom","aoid":"reads-bytes-from","title":"reads-bytes-from","number":"6.3.1.11","namespace":"<no location>","location":"","key":"reads-bytes-from"},{"type":"op","aoid":"reads-from","refId":"MemoryModel.ReadsFrom","location":"","key":"reads-from"},{"type":"clause","id":"MemoryModel.ReadsFrom","aoid":"reads-from","title":"reads-from","number":"6.3.1.12","namespace":"<no location>","location":"","key":"reads-from"},{"type":"op","aoid":"depends-on","refId":"MemoryModel.DependsOn","location":"","key":"depends-on"},{"type":"clause","id":"MemoryModel.DependsOn","aoid":"depends-on","title":"depends-on","number":"6.3.1.13","namespace":"<no location>","location":"","key":"depends-on"},{"type":"op","aoid":"ComposeWriteEventBytes","refId":"MemoryModel.ComposeWriteEventBytes","location":"","key":"ComposeWriteEventBytes"},{"type":"clause","id":"MemoryModel.ComposeWriteEventBytes","aoid":"ComposeWriteEventBytes","title":"ComposeWriteEventBytes( _execution_, _block_, _byteIndex_, _Ws_ )","number":"6.3.1.14","namespace":"<no location>","location":"","key":"ComposeWriteEventBytes( _execution_, _block_, _byteIndex_, _Ws_ )"},{"type":"op","aoid":"ValueOfReadEvent","refId":"MemoryModel.ValueOfReadEvent","location":"","key":"ValueOfReadEvent"},{"type":"clause","id":"MemoryModel.ValueOfReadEvent","aoid":"ValueOfReadEvent","title":"ValueOfReadEvent( _execution_, _R_ )","number":"6.3.1.15","namespace":"<no location>","location":"","key":"ValueOfReadEvent( _execution_, _R_ )"},{"type":"clause","id":"MemoryModel.ValidChosenReads","aoid":null,"title":"Valid Chosen Reads","number":"6.3.1.16","namespace":"<no location>","location":"","key":"Valid Chosen Reads"},{"type":"clause","id":"MemoryModel.NoOutOfThinAirReads","aoid":null,"title":"No Out of Thin Air Reads","number":"6.3.1.17","namespace":"<no location>","location":"","key":"No Out of Thin Air Reads"},{"type":"clause","id":"MemoryModel.TearFreeAlignedReads","aoid":null,"title":"Tear Free Reads","number":"6.3.1.18","namespace":"<no location>","location":"","key":"Tear Free Reads"},{"type":"op","aoid":"memory-order","refId":"MemoryModel.MemoryOrder","location":"","key":"memory-order"},{"type":"clause","id":"MemoryModel.MemoryOrder","aoid":"memory-order","title":"memory-order","number":"6.3.1.19","namespace":"<no location>","location":"","key":"memory-order"},{"type":"clause","id":"MemoryModel.SequentiallyConsistentAtomics","aoid":null,"title":"Sequentially Consistent Atomics","number":"6.3.1.20","namespace":"<no location>","location":"","key":"Sequentially Consistent Atomics"},{"type":"clause","id":"MemoryModel.ValidExecutions","aoid":null,"title":"Valid Executions","number":"6.3.1.21","namespace":"<no location>","location":"","key":"Valid Executions"},{"type":"op","aoid":"race","refId":"MemoryModel.Races","location":"","key":"race"},{"type":"clause","id":"MemoryModel.Races","aoid":"race","title":"Races","number":"6.3.1.22","namespace":"<no location>","location":"","key":"Races"},{"type":"op","aoid":"data race","refId":"MemoryModel.DataRaces","location":"","key":"data race"},{"type":"clause","id":"MemoryModel.DataRaces","aoid":"data race","title":"Data Races","number":"6.3.1.23","namespace":"<no location>","location":"","key":"Data Races"},{"type":"op","aoid":"data race free","refId":"MemoryModel.DRF","location":"","key":"data race free"},{"type":"clause","id":"MemoryModel.DRF","aoid":"data race free","title":"Data Race Freedom","number":"6.3.1.24","namespace":"<no location>","location":"","key":"Data Race Freedom"},{"type":"clause","id":"MemoryModel.AccessAtomicity","aoid":null,"title":"Access Atomicity (informative)","number":"6.3.1.25","namespace":"<no location>","location":"","key":"Access Atomicity (informative)"},{"type":"clause","id":"MemoryModel.SeqCst","aoid":null,"title":"Sequential Consistency (informative)","number":"6.3.1.26","namespace":"<no location>","location":"","key":"Sequential Consistency (informative)"},{"type":"clause","id":"AtomicsMethods","aoid":null,"title":"Methods","number":"6.3.2","namespace":"<no location>","location":"","key":"Methods"},{"type":"op","aoid":"ValidateSharedIntegerTypedArray","refId":"Atomics.ValidateSharedIntegerTypedArray","location":"","key":"ValidateSharedIntegerTypedArray"},{"type":"clause","id":"Atomics.ValidateSharedIntegerTypedArray","aoid":"ValidateSharedIntegerTypedArray","title":"ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )","number":"6.3.2.1","namespace":"<no location>","location":"","key":"ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )"},{"type":"op","aoid":"ValidateAtomicAccess","refId":"Atomics.ValidateAtomicAccess","location":"","key":"ValidateAtomicAccess"},{"type":"clause","id":"Atomics.ValidateAtomicAccess","aoid":"ValidateAtomicAccess","title":"ValidateAtomicAccess( _typedArray_, _requestIndex_ )","number":"6.3.2.2","namespace":"<no location>","location":"","key":"ValidateAtomicAccess( _typedArray_, _requestIndex_ )"},{"type":"op","aoid":"AgentSignifier","refId":"Atomics.AgentSignifier","location":"","key":"AgentSignifier"},{"type":"clause","id":"Atomics.AgentSignifier","aoid":"AgentSignifier","title":"AgentSignifier( )","number":"6.3.2.3","namespace":"<no location>","location":"","key":"AgentSignifier( )"},{"type":"op","aoid":"AgentCanSuspend","refId":"Atomics.AgentCanSuspend","location":"","key":"AgentCanSuspend"},{"type":"clause","id":"Atomics.AgentCanSuspend","aoid":"AgentCanSuspend","title":"AgentCanSuspend( )","number":"6.3.2.4","namespace":"<no location>","location":"","key":"AgentCanSuspend( )"},{"type":"op","aoid":"GetWaiterList","refId":"GetWaiterList","location":"","key":"GetWaiterList"},{"type":"clause","id":"GetWaiterList","aoid":"GetWaiterList","title":"GetWaiterList( _block_, _i_ )","number":"6.3.2.5","namespace":"<no location>","location":"","key":"GetWaiterList( _block_, _i_ )"},{"type":"op","aoid":"EnterCriticalSection","refId":"EnterCriticalSection","location":"","key":"EnterCriticalSection"},{"type":"clause","id":"EnterCriticalSection","aoid":"EnterCriticalSection","title":"EnterCriticalSection( _WL_ )","number":"6.3.2.6","namespace":"<no location>","location":"","key":"EnterCriticalSection( _WL_ )"},{"type":"op","aoid":"LeaveCriticalSection","refId":"LeaveCriticalSection","location":"","key":"LeaveCriticalSection"},{"type":"clause","id":"LeaveCriticalSection","aoid":"LeaveCriticalSection","title":"LeaveCriticalSection( _WL_ )","number":"6.3.2.7","namespace":"<no location>","location":"","key":"LeaveCriticalSection( _WL_ )"},{"type":"op","aoid":"AddWaiter","refId":"Atomics.AddWaiter","location":"","key":"AddWaiter"},{"type":"clause","id":"Atomics.AddWaiter","aoid":"AddWaiter","title":"AddWaiter( _WL_, _W_ )","number":"6.3.2.8","namespace":"<no location>","location":"","key":"AddWaiter( _WL_, _W_ )"},{"type":"op","aoid":"RemoveWaiter","refId":"Atomics.RemoveWaiter","location":"","key":"RemoveWaiter"},{"type":"clause","id":"Atomics.RemoveWaiter","aoid":"RemoveWaiter","title":"RemoveWaiter( _WL_, _W_ )","number":"6.3.2.9","namespace":"<no location>","location":"","key":"RemoveWaiter( _WL_, _W_ )"},{"type":"op","aoid":"RemoveWaiters","refId":"Atomics.RemoveWaiters","location":"","key":"RemoveWaiters"},{"type":"clause","id":"Atomics.RemoveWaiters","aoid":"RemoveWaiters","title":"RemoveWaiters( _WL_, _c_ )","number":"6.3.2.10","namespace":"<no location>","location":"","key":"RemoveWaiters( _WL_, _c_ )"},{"type":"op","aoid":"Suspend","refId":"Atomics.Suspend","location":"","key":"Suspend"},{"type":"clause","id":"Atomics.Suspend","aoid":"Suspend","title":"Suspend( _WL_, _W_, _timeout_ )","number":"6.3.2.11","namespace":"<no location>","location":"","key":"Suspend( _WL_, _W_, _timeout_ )"},{"type":"op","aoid":"WakeWaiter","refId":"Atomics.WakeWaiter","location":"","key":"WakeWaiter"},{"type":"clause","id":"Atomics.WakeWaiter","aoid":"WakeWaiter","title":"WakeWaiter( _WL_, _W_ )","number":"6.3.2.12","namespace":"<no location>","location":"","key":"WakeWaiter( _WL_, _W_ )"},{"type":"op","aoid":"AtomicReadModifyWrite","refId":"Atomics.ReadModifyWrite","location":"","key":"AtomicReadModifyWrite"},{"type":"clause","id":"Atomics.ReadModifyWrite","aoid":"AtomicReadModifyWrite","title":"AtomicReadModifyWrite( _typedArray_, _index_, _value_, _op_ )","number":"6.3.2.13","namespace":"<no location>","location":"","key":"AtomicReadModifyWrite( _typedArray_, _index_, _value_, _op_ )"},{"type":"clause","id":"AtomicsObjectFunctionProps","aoid":null,"title":"Function Properties of the Atomics Object","number":"6.3.3","namespace":"<no location>","location":"","key":"Function Properties of the Atomics Object"},{"type":"clause","id":"Atomics.add","aoid":null,"title":"Atomics.add( _typedArray_, _index_, _value_ )","number":"6.3.3.1","namespace":"<no location>","location":"","key":"Atomics.add( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.and","aoid":null,"title":"Atomics.and( _typedArray_, _index_, _value_ )","number":"6.3.3.2","namespace":"<no location>","location":"","key":"Atomics.and( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.compareExchange","aoid":null,"title":"Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )","number":"6.3.3.3","namespace":"<no location>","location":"","key":"Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )"},{"type":"clause","id":"Atomics.exchange","aoid":null,"title":"Atomics.exchange( _typedArray_, _index_, _value_ )","number":"6.3.3.4","namespace":"<no location>","location":"","key":"Atomics.exchange( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.isLockFree","aoid":null,"title":"Atomics.isLockFree( _size_ )","number":"6.3.3.5","namespace":"<no location>","location":"","key":"Atomics.isLockFree( _size_ )"},{"type":"clause","id":"Atomics.load","aoid":null,"title":"Atomics.load( _typedArray_, _index_ )","number":"6.3.3.6","namespace":"<no location>","location":"","key":"Atomics.load( _typedArray_, _index_ )"},{"type":"clause","id":"Atomics.or","aoid":null,"title":"Atomics.or( _typedArray_, _index_, _value_ )","number":"6.3.3.7","namespace":"<no location>","location":"","key":"Atomics.or( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.store","aoid":null,"title":"Atomics.store( _typedArray_, _index_, _value_ )","number":"6.3.3.8","namespace":"<no location>","location":"","key":"Atomics.store( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.sub","aoid":null,"title":"Atomics.sub( _typedArray_, _index_, _value_ )","number":"6.3.3.9","namespace":"<no location>","location":"","key":"Atomics.sub( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"Atomics.wait","aoid":null,"title":"Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )","number":"6.3.3.10","namespace":"<no location>","location":"","key":"Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )"},{"type":"clause","id":"Atomics.wake","aoid":null,"title":"Atomics.wake( _typedArray_, _index_, _count_ )","number":"6.3.3.11","namespace":"<no location>","location":"","key":"Atomics.wake( _typedArray_, _index_, _count_ )"},{"type":"clause","id":"Atomics.xor","aoid":null,"title":"Atomics.xor( _typedArray_, _index_, _value_ )","number":"6.3.3.12","namespace":"<no location>","location":"","key":"Atomics.xor( _typedArray_, _index_, _value_ )"},{"type":"clause","id":"CompilerTransforms","aoid":null,"title":"Compiler Transform Guidelines","number":"6.3.4","namespace":"<no location>","location":"","key":"Compiler Transform Guidelines"},{"type":"clause","id":"Codegen","aoid":null,"title":"Code Generation Guidelines","number":"6.3.5","namespace":"<no location>","location":"","key":"Code Generation Guidelines"},{"type":"clause","id":"WebBrowserEmbedding","aoid":null,"title":"Web browser embedding (informative)","number":"6.4","namespace":"<no location>","location":"","key":"Web browser embedding (informative)"},{"type":"clause","id":"sec-copyright-and-software-license","aoid":null,"title":"Copyright & Software License","number":"A","namespace":"<no location>","location":"","key":"Copyright & Software License"},{"type":"table","id":"table-agent-record","number":1,"caption":"Table 1: Agent Record Fields","namespace":"<no location>","location":"","key":"Table 1: Agent Record Fields"},{"type":"table","id":"table-readsharedmemory-fields","number":2,"caption":"Table 2: ReadSharedMemory Event Fields","namespace":"<no location>","location":"","key":"Table 2: ReadSharedMemory Event Fields"},{"type":"table","id":"table-writesharedmemory-fields","number":3,"caption":"Table 3: WriteSharedMemory Event Fields","namespace":"<no location>","location":"","key":"Table 3: WriteSharedMemory Event Fields"},{"type":"table","id":"table-rmwsharedmemory-fields","number":4,"caption":"Table 4: ReadModifyWriteSharedMemory Event Fields","namespace":"<no location>","location":"","key":"Table 4: ReadModifyWriteSharedMemory Event Fields"},{"type":"table","id":"table-agent-events-records","number":5,"caption":"Table 5: Agent Events Record Fields","namespace":"<no location>","location":"","key":"Table 5: Agent Events Record Fields"},{"type":"table","id":"table-chosen-value-records","number":6,"caption":"Table 6: Chosen Value Record Fields","namespace":"<no location>","location":"","key":"Table 6: Chosen Value Record Fields"},{"type":"table","id":"table-candidate-execution-records","number":7,"caption":"Table 7: Candidate Execution Record Fields","namespace":"<no location>","location":"","key":"Table 7: Candidate Execution Record Fields"},{"type":"term","term":"Shared Data Block","refId":"DataTypesValues.SpecTypes.DataBlocks","namespace":"<no location>","location":"","key":"Shared Data Block"},{"type":"term","term":"Agent Record","refId":"ExecutableCodeAndContexts.AgentCluster","namespace":"<no location>","location":"","key":"Agent Record"},{"type":"term","term":"%Atomics%","refId":"AtomicsObject","namespace":"<no location>","location":"","key":"%Atomics%"},{"type":"term","term":"memory model","refId":"AtomicsObject","namespace":"<no location>","location":"","key":"memory model"},{"type":"term","term":"Set","refId":"MemoryModel.Relations","namespace":"<no location>","location":"","key":"Set"},{"type":"term","term":"Relation","refId":"MemoryModel.Relations","namespace":"<no location>","location":"","key":"Relation"},{"type":"term","term":"partial order","refId":"MemoryModel.Relations","namespace":"<no location>","location":"","key":"partial order"},{"type":"term","term":"total order","refId":"MemoryModel.Relations","namespace":"<no location>","location":"","key":"total order"},{"type":"term","term":"Shared Data Block event","refId":"MemoryModel.Fundamentals","namespace":"<no location>","location":"","key":"Shared Data Block event"},{"type":"term","term":"range","refId":"MemoryModel.Fundamentals","namespace":"<no location>","location":"","key":"range"},{"type":"term","term":"Agent Events Record","refId":"MemoryModel.AgentEventsRecords","namespace":"<no location>","location":"","key":"Agent Events Record"},{"type":"term","term":"Chosen Value Record","refId":"MemoryModel.ChosenValueRecords","namespace":"<no location>","location":"","key":"Chosen Value Record"},{"type":"term","term":"candidate execution","refId":"MemoryModel.CandidateExecutions","namespace":"<no location>","location":"","key":"candidate execution"},{"type":"term","term":"WaiterList","refId":"GetWaiterList","namespace":"<no location>","location":"","key":"WaiterList"}]</script></head><body><div id="menu-toggle">☰</div><div id="menu"><div id="menu-search"><input type="text" id="menu-search-box" placeholder="Search..."><div id="menu-search-results" class="inactive"></div></div><div id="menu-toc"><ol class="toc"><li><span class="item-toggle-none"></span><a href="#intro" title="Introduction"><span class="secnum"></span> Introduction</a></li><li><span class="item-toggle">◢</span><a href="#Overview" title="Overview (ES7 4)"><span class="secnum">1</span> Overview (ES7 4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Overview.Overview" title="ECMAScript Overview (ES7 4.2)"><span class="secnum">1.1</span> ECMAScript Overview (ES7 4.2)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues" title="ECMAScript Data Types and Values (ES7 6)"><span class="secnum">2</span> ECMAScript Data Types and Values (ES7 6)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes" title="ECMAScript Language Types (ES7 6.1)"><span class="secnum">2.1</span> ECMAScript Language Types (ES7 6.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Number" title="The Number Type (ES7 6.1.6)"><span class="secnum">2.1.1</span> The Number Type (ES7 6.1.6)</a></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.LanguageTypes.Object" title="The Object Type (ES7 6.1.7)"><span class="secnum">2.1.2</span> The Object Type (ES7 6.1.7)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic" title="Well-Known Intrinsic Objects (ES7 6.1.7.4)"><span class="secnum">2.1.2.1</span> Well-Known Intrinsic Objects (ES7 6.1.7.4)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes" title="ECMAScript Specification Types (ES7 6.2)"><span class="secnum">2.2</span> ECMAScript Specification Types (ES7 6.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#DataTypesValues.SpecTypes.DataBlocks" title="Data blocks (ES7 6.2.6)"><span class="secnum">2.2.1</span> Data blocks (ES7 6.2.6)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" title="CopyDataBlockBytes( _toBlock_, _toIndex_, _fromBlock_, _fromIndex_, _count_ ) (ES7 6.2.6.2)"><span class="secnum">2.2.1.1</span> CopyDataBlockBytes( <var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var> ) (ES7 6.2.6.2)</a></li><li><span class="item-toggle-none"></span><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" title="CreateSharedByteDataBlock( _size_ )"><span class="secnum">2.2.1.2</span> CreateSharedByteDataBlock( <var>size</var> )</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts" title="Executable Code and Execution Contexts (ES7 8)"><span class="secnum">3</span> Executable Code and Execution Contexts (ES7 8)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues" title="Jobs and Job Queues (ES7 8.4)"><span class="secnum">3.1</span> Jobs and Job Queues (ES7 8.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress" title="Forward Progress Guarantees"><span class="secnum">3.1.1</span> Forward Progress Guarantees</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agents (AMENDMENTS)"><span class="secnum">3.2</span> Agents (AMENDMENTS)</a></li><li><span class="item-toggle-none"></span><a href="#ExecutableCodeAndContexts.AgentCluster" title="Agent Clusters (NEW)"><span class="secnum">3.3</span> Agent Clusters (NEW)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#GlobalObject" title="The Global Object (ES7 18)"><span class="secnum">4</span> The Global Object (ES7 18)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#GlobalObject.ConstructorProps" title="Constructor Properties of the Global Object (ES7 18.3)"><span class="secnum">4.1</span> Constructor Properties of the Global Object (ES7 18.3)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer" title="SharedArrayBuffer"><span class="secnum">4.1.1</span> SharedArrayBuffer</a></li><li><span class="item-toggle-none"></span><a href="#GlobalObject.ConstructorProps.Atomics" title="Atomics"><span class="secnum">4.1.2</span> Atomics</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections" title="Indexed Collections (ES7 22)"><span class="secnum">5</span> Indexed Collections (ES7 22)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray" title="TypedArray Objects (ES7 22.2)"><span class="secnum">5.1</span> TypedArray Objects (ES7 22.2)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype" title="Properties of the %TypedArrayPrototype% object (ES7 22.2.3)"><span class="secnum">5.1.1</span> Properties of the %TypedArrayPrototype% object (ES7 22.2.3)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.prototype.set" title="%TypedArray%.prototype.set( _overloaded_ [ , _offset_ ] ) (ES7 22.2.3.23)"><span class="secnum">5.1.1.1</span> %TypedArray%.prototype.set( <var>overloaded</var> [ , <var>offset</var> ] ) (ES7 22.2.3.23)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray" title="%TypedArray%.prototype.set( _array_ [, _offset_ ] ) (ES7 22.2.3.23.1)"><span class="secnum">5.1.1.1.1</span> %TypedArray%.prototype.set( <var>array</var> [, <var>offset</var> ] ) (ES7 22.2.3.23.1)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray" title="%TypedArray%.prototype.set( _typedArray_ [, _offset_ ] ) (ES7 22.2.3.23.2)"><span class="secnum">5.1.1.1.2</span> %TypedArray%.prototype.set( <var>typedArray</var> [, <var>offset</var> ] ) (ES7 22.2.3.23.2)</a></li><li><span class="item-toggle-none"></span><a href="#IndexedCollections.TypedArray.prototype.slice" title="%TypedArray%.prototype.slice( _start_, _end_ ) (ES7 22.2.3.24)"><span class="secnum">5.1.1.1.3</span> %TypedArray%.prototype.slice( <var>start</var>, <var>end</var> ) (ES7 22.2.3.24)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#IndexedCollections.TypedArray.constructors" title="The %TypedArray% constructors (ES7 22.2.4)"><span class="secnum">5.1.2</span> The %TypedArray% constructors (ES7 22.2.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-typedarray-typedarray" title="_TypedArray_ ( _typedArray_ ) (ES7 22.2.4.3)"><span class="secnum">5.1.2.1</span> <var>TypedArray</var> ( <var>typedArray</var> ) (ES7 22.2.4.3)</a></li></ol></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData" title="Structured Data (ES7 24)"><span class="secnum">6</span> Structured Data (ES7 24)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer" title="ArrayBuffer Objects (ES7 24.1)"><span class="secnum">6.1</span> ArrayBuffer Objects (ES7 24.1)</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.ArrayBuffer.abstract" title="Abstract Operations for ArrayBuffer (ES7 24.1.1)"><span class="secnum">6.1.1</span> Abstract Operations for ArrayBuffer (ES7 24.1.1)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-detacharraybuffer" title="DetachArrayBuffer ( _arrayBuffer_ ) (ES7 24.1.1.3)"><span class="secnum">6.1.1.1</span> DetachArrayBuffer ( <var>arrayBuffer</var> ) (ES7 24.1.1.3)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.RawBytesToNumber" title="RawBytesToNumber( _type_, _rawBytes_, _isLittleEndian_ )"><span class="secnum">6.1.1.2</span> RawBytesToNumber( <var>type</var>, <var>rawBytes</var>, <var>isLittleEndian</var> )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" title="GetValueFromBuffer( _arrayBuffer_, _byteIndex_, _type_, _isTypedArray_, _order_ [, _isLittleEndian_] ) (ES7 24.1.1.5)"><span class="secnum">6.1.1.3</span> GetValueFromBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isTypedArray</var>, <var>order</var> [, <var>isLittleEndian</var>] ) (ES7 24.1.1.5)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.NumberToRawBytes" title="NumberToRawBytes( _type_, _value_, _isLittleEndian_ )"><span class="secnum">6.1.1.4</span> NumberToRawBytes( <var>type</var>, <var>value</var>, <var>isLittleEndian</var> )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer" title="SetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, _isTypedArray_, _order_ [, _isLittleEndian_] ) (ES7 24.1.1.6)"><span class="secnum">6.1.1.5</span> SetValueInBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>isTypedArray</var>, <var>order</var> [, <var>isLittleEndian</var>] ) (ES7 24.1.1.6)</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.ArrayBuffer.abstract.GetModifySetValueInBuffer" title="GetModifySetValueInBuffer( _arrayBuffer_, _byteIndex_, _type_, _value_, _op_ [, _isLittleEndian_] )"><span class="secnum">6.1.1.6</span> GetModifySetValueInBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>op</var> [, <var>isLittleEndian</var>] )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#sec-properties-of-the-arraybuffer-prototype-object" title="Properties of the ArrayBuffer Prototype Object (ES7 24.1.4)"><span class="secnum">6.1.2</span> Properties of the ArrayBuffer Prototype Object (ES7 24.1.4)</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#sec-get-arraybuffer.prototype.bytelength" title="get ArrayBuffer.prototype.byteLength (ES7 24.1.4.1)"><span class="secnum">6.1.2.1</span> get ArrayBuffer.prototype.byteLength (ES7 24.1.4.1)</a></li><li><span class="item-toggle-none"></span><a href="#sec-arraybuffer.prototype.slice" title="ArrayBuffer.prototype.slice ( _start_, _end_ ) (ES7 24.1.4.3)"><span class="secnum">6.1.2.2</span> ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> ) (ES7 24.1.4.3)</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer" title="SharedArrayBuffer Objects"><span class="secnum">6.2</span> SharedArrayBuffer Objects</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.abstract" title="Abstract Operations for SharedArrayBuffer"><span class="secnum">6.2.1</span> Abstract Operations for SharedArrayBuffer</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer" title="AllocateSharedArrayBuffer( _constructor_, _byteLength_ )"><span class="secnum">6.2.1.1</span> AllocateSharedArrayBuffer( <var>constructor</var>, <var>byteLength</var> )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer" title="IsSharedArrayBuffer( _obj_ )"><span class="secnum">6.2.1.2</span> IsSharedArrayBuffer( <var>obj</var> )</a></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor" title="The SharedArrayBuffer Constructor"><span class="secnum">6.2.1.3</span> The SharedArrayBuffer Constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.withLength" title="SharedArrayBuffer( _length_ )"><span class="secnum">6.2.1.3.1</span> SharedArrayBuffer( <var>length</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.constructor.properties" title="Properties of the SharedArrayBuffer constructor"><span class="secnum">6.2.1.4</span> Properties of the SharedArrayBuffer constructor</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype" title="SharedArrayBuffer.prototype"><span class="secnum">6.2.1.4.1</span> SharedArrayBuffer.prototype</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species" title="get SharedArrayBuffer [ @@species ]"><span class="secnum">6.2.1.4.2</span> get SharedArrayBuffer [ @@species ]</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#StructuredData.SharedArrayBuffer.prototype" title="Properties of the SharedArrayBuffer prototype object"><span class="secnum">6.2.1.5</span> Properties of the SharedArrayBuffer prototype object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength" title="get SharedArrayBuffer.prototype.byteLength"><span class="secnum">6.2.1.5.1</span> get SharedArrayBuffer.prototype.byteLength</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.constructor" title="SharedArrayBuffer.prototype.constructor"><span class="secnum">6.2.1.5.2</span> SharedArrayBuffer.prototype.constructor</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.slice" title="SharedArrayBuffer.prototype.slice( _start_, _end_ )"><span class="secnum">6.2.1.5.3</span> SharedArrayBuffer.prototype.slice( <var>start</var>, <var>end</var> )</a></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.prototype.toString" title="SharedArrayBuffer.prototype[ @@toStringTag ]"><span class="secnum">6.2.1.5.4</span> SharedArrayBuffer.prototype[ @@toStringTag ]</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#StructuredData.SharedArrayBuffer.instances" title="Properties of the SharedArrayBuffer instances"><span class="secnum">6.2.1.6</span> Properties of the SharedArrayBuffer instances</a></li></ol></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObject" title="The Atomics Object"><span class="secnum">6.3</span> The Atomics Object</a><ol class="toc"><li><span class="item-toggle">◢</span><a href="#MemoryModel" title="Memory Model"><span class="secnum">6.3.1</span> Memory Model</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#MemoryModel.Relations" title="The Set and Relation Specification Types"><span class="secnum">6.3.1.1</span> The Set and Relation Specification Types</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.Fundamentals" title="Fundamentals"><span class="secnum">6.3.1.2</span> Fundamentals</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.AgentEventsRecords" title="Agent Events Records"><span class="secnum">6.3.1.3</span> Agent Events Records</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.ChosenValueRecords" title="Chosen Value Records"><span class="secnum">6.3.1.4</span> Chosen Value Records</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.CandidateExecutions" title="Candidate Executions"><span class="secnum">6.3.1.5</span> Candidate Executions</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.EventSet" title="EventSet( _execution_ )"><span class="secnum">6.3.1.6</span> EventSet( <var>execution</var> )</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.AgentOrder" title="agent-order"><span class="secnum">6.3.1.7</span> agent-order</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.HostSynchronizesWith" title="host-synchronizes-with"><span class="secnum">6.3.1.8</span> host-synchronizes-with</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.SynchronizesWith" title="synchronizes-with"><span class="secnum">6.3.1.9</span> synchronizes-with</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.HappensBefore" title="happens-before"><span class="secnum">6.3.1.10</span> happens-before</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.ReadBytesFrom" title="reads-bytes-from"><span class="secnum">6.3.1.11</span> reads-bytes-from</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.ReadsFrom" title="reads-from"><span class="secnum">6.3.1.12</span> reads-from</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.DependsOn" title="depends-on"><span class="secnum">6.3.1.13</span> depends-on</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.ComposeWriteEventBytes" title="ComposeWriteEventBytes( _execution_, _block_, _byteIndex_, _Ws_ )"><span class="secnum">6.3.1.14</span> ComposeWriteEventBytes( <var>execution</var>, <var>block</var>, <var>byteIndex</var>, <var>Ws</var> )</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.ValueOfReadEvent" title="ValueOfReadEvent( _execution_, _R_ )"><span class="secnum">6.3.1.15</span> ValueOfReadEvent( <var>execution</var>, <var>R</var> )</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.ValidChosenReads" title="Valid Chosen Reads"><span class="secnum">6.3.1.16</span> Valid Chosen Reads</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.NoOutOfThinAirReads" title="No Out of Thin Air Reads"><span class="secnum">6.3.1.17</span> No Out of Thin Air Reads</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.TearFreeAlignedReads" title="Tear Free Reads"><span class="secnum">6.3.1.18</span> Tear Free Reads</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.MemoryOrder" title="memory-order"><span class="secnum">6.3.1.19</span> memory-order</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.SequentiallyConsistentAtomics" title="Sequentially Consistent Atomics"><span class="secnum">6.3.1.20</span> Sequentially Consistent Atomics</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.ValidExecutions" title="Valid Executions"><span class="secnum">6.3.1.21</span> Valid Executions</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.Races" title="Races"><span class="secnum">6.3.1.22</span> Races</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.DataRaces" title="Data Races"><span class="secnum">6.3.1.23</span> Data Races</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.DRF" title="Data Race Freedom"><span class="secnum">6.3.1.24</span> Data Race Freedom</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.AccessAtomicity" title="Access Atomicity (informative)"><span class="secnum">6.3.1.25</span> Access Atomicity (informative)</a></li><li><span class="item-toggle-none"></span><a href="#MemoryModel.SeqCst" title="Sequential Consistency (informative)"><span class="secnum">6.3.1.26</span> Sequential Consistency (informative)</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsMethods" title="Methods"><span class="secnum">6.3.2</span> Methods</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateSharedIntegerTypedArray" title="ValidateSharedIntegerTypedArray(_typedArray_ [, _onlyInt32_] )"><span class="secnum">6.3.2.1</span> ValidateSharedIntegerTypedArray(<var>typedArray</var> [, <var>onlyInt32</var>] )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ValidateAtomicAccess" title="ValidateAtomicAccess( _typedArray_, _requestIndex_ )"><span class="secnum">6.3.2.2</span> ValidateAtomicAccess( <var>typedArray</var>, <var>requestIndex</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentSignifier" title="AgentSignifier( )"><span class="secnum">6.3.2.3</span> AgentSignifier( )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AgentCanSuspend" title="AgentCanSuspend( )"><span class="secnum">6.3.2.4</span> AgentCanSuspend( )</a></li><li><span class="item-toggle-none"></span><a href="#GetWaiterList" title="GetWaiterList( _block_, _i_ )"><span class="secnum">6.3.2.5</span> GetWaiterList( <var>block</var>, <var>i</var> )</a></li><li><span class="item-toggle-none"></span><a href="#EnterCriticalSection" title="EnterCriticalSection( _WL_ )"><span class="secnum">6.3.2.6</span> EnterCriticalSection( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#LeaveCriticalSection" title="LeaveCriticalSection( _WL_ )"><span class="secnum">6.3.2.7</span> LeaveCriticalSection( <var>WL</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.AddWaiter" title="AddWaiter( _WL_, _W_ )"><span class="secnum">6.3.2.8</span> AddWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiter" title="RemoveWaiter( _WL_, _W_ )"><span class="secnum">6.3.2.9</span> RemoveWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.RemoveWaiters" title="RemoveWaiters( _WL_, _c_ )"><span class="secnum">6.3.2.10</span> RemoveWaiters( <var>WL</var>, <var>c</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.Suspend" title="Suspend( _WL_, _W_, _timeout_ )"><span class="secnum">6.3.2.11</span> Suspend( <var>WL</var>, <var>W</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.WakeWaiter" title="WakeWaiter( _WL_, _W_ )"><span class="secnum">6.3.2.12</span> WakeWaiter( <var>WL</var>, <var>W</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.ReadModifyWrite" title="AtomicReadModifyWrite( _typedArray_, _index_, _value_, _op_ )"><span class="secnum">6.3.2.13</span> AtomicReadModifyWrite( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>op</var> )</a></li></ol></li><li><span class="item-toggle">◢</span><a href="#AtomicsObjectFunctionProps" title="Function Properties of the Atomics Object"><span class="secnum">6.3.3</span> Function Properties of the Atomics Object</a><ol class="toc"><li><span class="item-toggle-none"></span><a href="#Atomics.add" title="Atomics.add( _typedArray_, _index_, _value_ )"><span class="secnum">6.3.3.1</span> Atomics.add( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.and" title="Atomics.and( _typedArray_, _index_, _value_ )"><span class="secnum">6.3.3.2</span> Atomics.and( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.compareExchange" title="Atomics.compareExchange( _typedArray_, _index_, _expectedValue_, _replacementValue_ )"><span class="secnum">6.3.3.3</span> Atomics.compareExchange( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.exchange" title="Atomics.exchange( _typedArray_, _index_, _value_ )"><span class="secnum">6.3.3.4</span> Atomics.exchange( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.isLockFree" title="Atomics.isLockFree( _size_ )"><span class="secnum">6.3.3.5</span> Atomics.isLockFree( <var>size</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.load" title="Atomics.load( _typedArray_, _index_ )"><span class="secnum">6.3.3.6</span> Atomics.load( <var>typedArray</var>, <var>index</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.or" title="Atomics.or( _typedArray_, _index_, _value_ )"><span class="secnum">6.3.3.7</span> Atomics.or( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.store" title="Atomics.store( _typedArray_, _index_, _value_ )"><span class="secnum">6.3.3.8</span> Atomics.store( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.sub" title="Atomics.sub( _typedArray_, _index_, _value_ )"><span class="secnum">6.3.3.9</span> Atomics.sub( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.wait" title="Atomics.wait( _typedArray_, _index_, _value_, _timeout_ )"><span class="secnum">6.3.3.10</span> Atomics.wait( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.wake" title="Atomics.wake( _typedArray_, _index_, _count_ )"><span class="secnum">6.3.3.11</span> Atomics.wake( <var>typedArray</var>, <var>index</var>, <var>count</var> )</a></li><li><span class="item-toggle-none"></span><a href="#Atomics.xor" title="Atomics.xor( _typedArray_, _index_, _value_ )"><span class="secnum">6.3.3.12</span> Atomics.xor( <var>typedArray</var>, <var>index</var>, <var>value</var> )</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#CompilerTransforms" title="Compiler Transform Guidelines"><span class="secnum">6.3.4</span> Compiler Transform Guidelines</a></li><li><span class="item-toggle-none"></span><a href="#Codegen" title="Code Generation Guidelines"><span class="secnum">6.3.5</span> Code Generation Guidelines</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#WebBrowserEmbedding" title="Web browser embedding (informative)"><span class="secnum">6.4</span> Web browser embedding (informative)</a></li></ol></li><li><span class="item-toggle-none"></span><a href="#sec-copyright-and-software-license" title="Copyright &amp; Software License"><span class="secnum">A</span> Copyright &amp; Software License</a></li></ol></div></div><h1 class="version">Stage 2 Draft / October 29, 2016</h1><h1 class="title">ECMAScript Shared Memory and Atomics</h1>
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">

<p>Some algorithms and semantics in this proposal are presented as modifications to existing ES262 algorithms and semantics.  The base revision of ES262 for the modifications (here denoted "ES7") is currently f35248729043089b47ccf29e4c47559386f5f6fd (2016-06-29).  At the moment, ES7 (ES2016) section numbering differs from ES6 (ES2015) only for TypedArrays (section 22.2).</p>

<emu-intro id="intro">
<h1><span class="secnum"></span>Introduction<span class="utils"><span class="anchor"><a href="#intro">#</a></span></span></h1>

<p>This proposal adds a simple form of shared memory to ECMAScript.
Shared memory is being exposed in the form of a new SharedArrayBuffer
type; the existing TypedArray and DataView types are adapted in such a way
that they can be used to create views on shared memory.  The new
global Atomics object provides atomic operations on shared memory
locations, including operations that can be used to create blocking
synchronization primitives.  Though not a part of this specification,
we intend for the role of "threads" to be played by Web Workers in web
browser environments.</p><p>

</p><p>At this time the proposal adds only low-level primitives to
ECMAScript; we expect the developer community to put together
abstractions that are useful in specific domains.</p>

<p>The work has been driven by the following use cases:  </p><p>

</p><ul>
  <li>Support for threaded code in programs written in other
  languages that are translated to asm.js or plain JS or a combination
  of the two, notably C and C++ but also other, safe, languages. 

  </li><li>Support for hand-written JS or JS+asm.js that makes use of
  multiprocessing facilities for select tasks, such as image
  processing, asset management, or game AI.

</li></ul>

<p>The proposal makes only very basic assumptions about the required
hardware and should be broadly implementable with good performance.
Prototype implementations of the API are available in Firefox and in
Google Chrome.</p>

<p>This specification constitutes a restatement and formalization of
an earlier
work,  <a href="https://github.com/tc39/ecmascript_sharedmem/blob/master/historical/Spec_JavaScriptSharedMemoryAtomicsandLocks.pdf">the
spec document for which</a> also contains additional rationale,
background information, discussions, implementation notes, and
comments.</p>

<p>Changelog:</p>
<ul>
  <li>2016-10-25 -- Fix Tear Free Aligned Reads to distinguish TypedArray vs DataView provenance instead of just alignment.
  
  </li><li>2016-10-25 -- Model candidate executions explicitly with evaluation semantics that can read all possible values; model events as Records.
  
  </li><li>2016-10-24 -- Fix RMW events to correctly return the read value instead of the modified value.
  
  </li><li>2016-10-24 -- Add Tear Free Aligned Reads requirement to valid executions; fixed Access Atomicity to impart that the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> only solves ordering of events and that access atomicity is an orthogonal property.
  
  </li><li>2016-10-24 -- Rewrote <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>, again, to be axiomatic.
  
  </li><li>2016-07-22 -- Editorial fixes.
  
  </li><li>2016-07-21 -- Replace [[SharedArrayBufferData]] and [[SharedArrayBufferByteLength]] with [[ArrayBufferData]] and [[ArrayBufferByteLength]]; remove specialization that was based on the removed properties and instead use type checks with <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref> in ArrayBuffer, SharedArrayBuffer, and Atomics methods; spec that Shared Data Blocks are distinguishable (by unspecified means) from regular Data Blocks and use this to defined <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>.
  
  </li><li>2016-07-20 -- Editorial fix: clarify the operator passed to AtomicFetchOp.
  
  </li><li>2016-07-13 -- Editorial fixes.
  
  </li><li>2016-07-11 -- Rewrote the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> section, which introduced separate access functions for shared memory, and caused many other changes.
  
  </li><li>2016-07-05 -- Rewrote (and shrunk) the informative Web Browser Embedding section so that it only addresses the requirements of this spec, not how HTML ought to evolve.
  
  </li><li>2016-07-05 -- Rephrased the wait/wake mutual exclusion in terms of critical sections named by (G,i), as the old specification was too strong.
  
  </li><li>2016-06-30 -- Algorithms that are modified relative to their ES262 forms include more context and are more clearly marked, and there's a defined ES262 base revision for those modifications.  Updated section references to reference that revision.
  
  </li><li>(Older changelog removed)

</li></ul>

</emu-intro>

<emu-clause id="Overview">
  <h1><span class="secnum">1</span>Overview (<a href="https://tc39.github.io/ecma262/#sec-overview">ES7 4</a>)<span class="utils"><span class="anchor"><a href="#Overview">#</a></span></span></h1>
  <emu-clause id="Overview.Overview">
    <h1><span class="secnum">1.1</span>ECMAScript Overview (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-overview">ES7 4.2</a>)<span class="utils"><span class="anchor"><a href="#Overview.Overview">#</a></span></span></h1>
    <p>In the third paragraph, include  <b>SharedArrayBuffer</b> after  <b>ArrayBuffer</b>.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="DataTypesValues">
  <h1><span class="secnum">2</span>ECMAScript Data Types and Values (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">ES7 6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues">#</a></span></span></h1>

  <emu-clause id="DataTypesValues.LanguageTypes">
    <h1><span class="secnum">2.1</span>ECMAScript Language Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types">ES7 6.1</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.LanguageTypes.Number">
      <h1><span class="secnum">2.1.1</span>The Number Type (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-language-types-number-type">ES7 6.1.6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Number">#</a></span></span></h1>
      <p>In the NOTE, include  <b>SharedArrayBuffer</b> along with  <b>ArrayBuffer</b>.</p>
    </emu-clause>
    <emu-clause id="DataTypesValues.LanguageTypes.Object">
      <h1><span class="secnum">2.1.2</span>The Object Type (<a href="https://tc39.github.io/ecma262/#sec-object-type">ES7 6.1.7</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object">#</a></span></span></h1>
      <emu-clause id="DataTypesValues.LanguageTypes.Object.Intrinsic">
        <h1><span class="secnum">2.1.2.1</span>Well-Known Intrinsic Objects (<a href="https://tc39.github.io/ecma262/#sec-well-known-intrinsic-objects">ES7 6.1.7.4</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.LanguageTypes.Object.Intrinsic">#</a></span></span></h1>
        <p>In table 7, include rows for <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">%Atomics%</a></emu-xref>, %SharedArrayBuffer%, and %SharedArrayBufferPrototype% in the manner of the row for ArrayBuffer.</p>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="DataTypesValues.SpecTypes">
    <h1><span class="secnum">2.2</span>ECMAScript Specification Types (<a href="https://tc39.github.io/ecma262/#sec-ecmascript-specification-types">ES7 6.2</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes">#</a></span></span></h1>
    <emu-clause id="DataTypesValues.SpecTypes.DataBlocks">
      <h1><span class="secnum">2.2.1</span>Data blocks (<a href="https://tc39.github.io/ecma262/#sec-data-blocks">ES7 6.2.6</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks">#</a></span></span></h1>
      <p>Insert the following paragraphs after the third:</p>

      <p>A data block that resides in memory that can be referenced from multiple agents concurrently is designated a  <dfn>Shared Data Block</dfn>.  A Shared Data Block has an identity (for the purposes of equality testing Shared Data Block values) that is  <em>address-free</em>: it is tied not to the virtual addresses the block is mapped to in any process, but to the set of locations in memory that the block represents.  Shared Data Blocks can also be distinguished from Data Blocks.</p>

      <p>The semantics of Shared Data Blocks is defined using Shared Data Block events by the Atomics <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>. Abstract operations below act as the interface between evaluation semantics and the event semantics of the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>. The operations thus introduce ReadSharedMemory, WriteSharedMemory, and ReadModifyWriteSharedMemory events. Because of the axiomatic nature of the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>, the values of these events are not known until the set of all events is known. The operations thus also nondeterministically read any possible Number value of a particular type during evaluation. The events introduced during an evaluation form a graph. The event graph together with the nondeterministically chosen values and other relations defined in the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> form a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref>. The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> does not admit all candidate executions; the allowed candidate executions are called valid executions, or simply executions. There is at least one valid execution for a given evaluation.</p>

      <p>A <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">Shared Data Block event</a></emu-xref> are modeled by Records, defined in the Atomics <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>. All agents in an agent cluster share the same <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> record in its <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref>'s [[CandidateExecution] field, which is initialized to an empty <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref>.</p>

      <emu-note><span class="note">Note</span>
        <p>One may think of the evaluation semantics of ECMAScript as a generating function for candidate executions. The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> then prunes invalid executions from the set of candidate executions. A single-agent ECMAScript program that does not use SharedArrayBuffer (and, for simplicity, ignoring other sources of nondeterminism such as <code>Math.random()</code>) always has exactly one <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref>, which is also a valid execution. A multi-agent ECMAScript program that uses SharedArrayBuffer has many candidate executions and at least one valid execution.</p>
      </emu-note>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes" aoid="CopyDataBlockBytes">
        <h1><span class="secnum">2.2.1.1</span>CopyDataBlockBytes( <var>toBlock</var>, <var>toIndex</var>, <var>fromBlock</var>, <var>fromIndex</var>, <var>count</var> ) (<a href="https://tc39.github.io/ecma262/#sec-copydatablockbytes">ES7 6.2.6.2</a>)<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>When the abstract operation CopyDataBlockBytes is called, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>fromBlock</var> and <var>toBlock</var> are distinct <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> <ins>or <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref></ins> values.</li><li>Assert: <var>fromIndex</var>, <var>toIndex</var>, and <var>count</var> are integer values ≥ 0.</li><li>Let <var>fromSize</var> be the number of bytes in <var>fromBlock</var>.</li><li>Assert: <var>fromIndex</var>+<var>count</var> ≤ <var>fromSize</var>.</li><li>Let <var>toSize</var> be the number of bytes in <var>toBlock</var>.</li><li>Assert: <var>toIndex</var>+<var>count</var> ≤ <var>toSize</var>.</li><li>Repeat, while <var>count</var>&gt;0<ol><li><del>Set <var>toBlock</var>[<var>toIndex</var>] to the value of <var>fromBlock</var>[<var>fromIndex</var>].</del><br><ins>If <var>fromBlock</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> then<ol><li><ins>Let <var>execution</var> be the [[CandidateExecution]] field of the <em>surrounding agent</em>'s <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref>.</ins></li><li><ins>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventLists]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</ins></li><li><ins>Let <var>bytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <emu-val>1</emu-val> that contains the nondeterministically chosen byte value.</ins></li><li><ins>Let <var>readEvent</var> be ReadSharedMemory{[[Order]]: <code>"Unordered"</code>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>fromBlock</var>, [[ByteIndex]]: <var>fromIndex</var>, [[ElementSize]]: <emu-val>1</emu-val>}.</ins></li><li><ins>Append <var>readEvent</var> to _eventList.</ins></li><li><ins>Append WriteSharedMemory{[[Order]]: <code>"Unordered"</code>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>toBlock</var>, [[ByteIndex]]: <var>toIndex</var>, [[ElementSize]]: <emu-val>1</emu-val>, [[Payload]]: <var>bytes[0]</var>} to the _eventList.</ins></li><li><ins>Append {[[Event]]: <var>readEvent</var>, [[ChosenValue]]: <var>bytes</var>} to <var>execution</var>.[[ChosenValues]].</ins></li></ol></ins></li><li><ins>Otherwise, set <var>toBlock</var>[<var>toIndex</var>] to <var>fromBlock</var>[<var>fromIndex</var>].</ins></li><li>Increment <var>toIndex</var> and <var>fromIndex</var> each by 1.</li><li>Decrement <var>count</var> by 1.</li></ol></li><li>Return <emu-xref aoid="NormalCompletion"><a href="https://tc39.github.io/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-const>empty</emu-const>).
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock" aoid="CreateSharedByteDataBlock">
        <h1><span class="secnum">2.2.1.2</span>CreateSharedByteDataBlock( <var>size</var> )<span class="utils"><span class="anchor"><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">#</a></span></span></h1>
        <p>When the abstract operation CreateSharedByteDataBlock is called with integer argument size, the following steps are taken:</p>
        <emu-alg><ol><li>Assert: <var>size</var> &gt;= 0.</li><li>Let <var>db</var> be a new <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> value consisting of <var>size</var> bytes. If it is impossible to create such a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>execution</var> be the [[CandidateExecution]] field of the <em>surrounding agent</em>'s <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref>.</li><li>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventLists]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</li><li>For each index <var>i</var> of <var>db</var>:<ol><li>Append WriteSharedMemory{[[Order]]: <code>"Init"</code>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>db</var>, [[ByteIndex]]: <var>i</var>, [[ElementSize]]: <emu-val>1</emu-val>, [[Payload]]: <emu-val>0</emu-val>} to _eventList.</li></ol></li><li>Return <var>db</var>.
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="ExecutableCodeAndContexts">
  <h1><span class="secnum">3</span>Executable Code and Execution Contexts (<a href="https://tc39.github.io/ecma262/#sec-executable-code-and-execution-contexts">ES7 8</a>)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts">#</a></span></span></h1>
  <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues">

    <h1><span class="secnum">3.1</span>Jobs and Job Queues (<a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues">ES7 8.4</a>)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues">#</a></span></span></h1>
    <emu-clause id="ExecutableCodeAndContexts.JobsAndJobQueues.Progress">
      <h1><span class="secnum">3.1.1</span>Forward Progress Guarantees<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.JobsAndJobQueues.Progress">#</a></span></span></h1>
      <p>The forward progress guarantee is provided by  <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>.</p>
    </emu-clause>
  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">3.2</span>Agents (AMENDMENTS)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p>Add the following properties to the  <dfn>Agent Record</dfn> (which is provided by  <a href="https://github.com/tc39/ecma262/pull/522">PR 522 on ES262</a>):</p>

    <emu-table id="table-agent-record" caption="Agent Record Fields"><figure><figcaption>Table 1: Agent Record Fields</figcaption>
      <table>
        <tbody>
          <tr>
            <th>Field name</th>
            <th>Value</th>
            <th>Meaning</th>
          </tr>
          <tr>
            <td>[[Signifier]]</td>
            <td>A value that admits equality testing</td>
            <td>Uniquely identifies the agent within its agent cluster.</td>
          </tr>
          <tr>
            <td>[[LittleEndian]]</td>
            <td>A Boolean</td>
            <td><emu-val>true</emu-val> if the underlying machine is little-endian, <emu-val>false</emu-val> otherwise.</td>
          </tr>
          <tr>
            <td>[[IsLockFree1]]</td>
            <td>A Boolean</td>
            <td><emu-val>true</emu-val> if atomic operations on one-byte values are lock-free, <emu-val>false</emu-val> otherwise.</td>
          </tr>
          <tr>
            <td>[[IsLockFree2]]</td>
            <td>Boolean</td>
            <td><emu-val>true</emu-val> if atomic operations on two-byte values are lock-free, <emu-val>false</emu-val> otherwise.</td>
          </tr>
          <tr>
            <td>[[CandidateExecution]]</td>
            <td>A <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref></td>
            <td>See the Atomics <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>.</td>
          </tr>
       </tbody>
     </table>
    </figure></emu-table>

    <p>Once the values of [[Signifier]], [[IsLockFree1]], and
    [[IsLockFree2]] have been observed by any agent in the agent
    cluster they cannot change.</p>

    <emu-note><span class="note">Note</span>
      <p>The values of [[IsLockFree1]] and [[IsLockFree2]] are not
        necessarily determined by the hardware, but may also reflect
        implementation choices that can vary over time and between
        ECMAScript implementations.</p>

      <p>There is no [[IsLockFree4]] property: 4-byte atomic
        operations are always lock-free.</p>

      <p>Formally, atomic operations are lock-free if, infinitely
        often, some atomic operation finishes in a finite number of
        program steps.  In practice, if an atomic operation is
        implemented with any type of lock the operation is not
        lock-free.  Lock-free does not imply wait-free: there is no
        upper bound on how many machine steps may be required to
        complete a lock-free atomic operation.</p>

      <p>That an atomic access of size  <em>n</em> is lock-free does
        not imply anything about the (perceived) atomicity of
        non-atomic accesses of size  <em>n</em>, specifically,
        non-atomic accesses may still be performed as a sequence of
        several separate memory accesses.  See ReadSharedMemory and
        WriteSharedMemory for details.</p>
    </emu-note>

  </emu-clause>

  <emu-clause id="ExecutableCodeAndContexts.AgentCluster">
    <h1><span class="secnum">3.3</span>Agent Clusters (NEW)<span class="utils"><span class="anchor"><a href="#ExecutableCodeAndContexts.AgentCluster">#</a></span></span></h1>

    <p>An  <em>agent cluster</em> is a maximal set of agents that can
      communicate by operating on shared memory.</p>

    <emu-note><span class="note">Note 1</span>
      <p>Programs within different agents may share memory by
        unspecified means.  At a minimum, the backing memory for
        SharedArrayBuffer objects can be shared among the agents in
        the cluster.</p>

      <p>There may be agents that can communicate by message passing
	that cannot share memory; they are never in the same
	cluster.</p>
    </emu-note>

    <p>Every agent belongs to exactly one agent cluster.</p>

    <emu-note><span class="note">Note 2</span>
      <p>The agents in a cluster need not all be alive at some
	particular point in time.  If agent  <b>A</b> creates another
	agent  <b>B</b>, after which  <b>A</b> terminates and  <b>B</b>
	creates agent  <b>C</b>, the three agents are in the same
	cluster if  <b>A</b> could share some memory with  <b>B</b>
	and  <b>B</b> could share some memory with  <b>C</b>.</p>
    </emu-note>

    <p>All agents within a cluster must have the same value for
      the [[LittleEndian]] property in their respective Agent Records.</p>

    <emu-note><span class="note">Note 3</span>
      <p>If different agents within an agent cluster have different
        values of [[LittleEndian]] it becomes hard to use shared
        memory for multi-byte data.</p>
    </emu-note>

    <p>All agents within a cluster must have the same values for
      the [[IsLockFree1]] property in their respective Agent Records; similarly for
      the [[IsLockFree2]] property.</p>

    <p>All agents within a cluster must have the same value for the [[CandidateExecution]] in their respective Agent Records.</p>

    <p>All agents within a cluster must have different values for
      the [[Signifier]] property in their respective Agent Records.</p>

    <p>An agent cluster is a specification mechanism and need not correspond to
      any particular artefact of an ECMAScript implementation.</p>

    <p>An embedding may deactivate (stop forward progress) or
      activate (resume forward progress) an agent without the agent's
      knowledge or cooperation.  If the embedding does so, it must not
      leave some agents in the cluster active while other agents in
      the cluster are deactivated indefinitely.</p>

    <emu-note><span class="note">Note 4</span>
      <p>The purpose of the preceding restriction is to avoid a
        situation where an agent deadlocks or starves because another
        agent has been suspended.  For example, if a DOM SharedWorker
        shares memory with a regular worker, and the regular worker is
        suspended while it holds a lock (because the web page the
        regular worker is in is pushed into the window history), and
        the SharedWorker tries to acquire the lock, then the
        SharedWorker will be blocked until the regular worker wakes up
        again, if ever.  Meanwhile other workers trying to access the
        SharedWorker from other web pages will starve.</p>

      <p>The implication of the restriction is that it will not be
        possible to share memory between agents that don't belong to
        the same suspend/wake collective within the embedding.</p>
    </emu-note>

    <p>An embedding may terminate an agent without any of the agent's
      cluster's other agents' prior knowledge or cooperation.  If an
      agent is terminated not by programmatic action of its own or of
      another agent in the cluster but by forces external to the
      cluster, then the embedding must choose one of two strategies:
      Either terminate all the agents in the cluster, or provide
      reliable APIs that allow the agents in the cluster to coordinate
      so that at least one remaining member of the cluster will be
      able to detect the termination, with the termination data
      containing enough information to identify the agent that was
      terminated.</p>

    <emu-note><span class="note">Note 5</span>
      <p>Examples of that type of termination are: operating systems
        or users terminating agents that are running in separate
        processes; the embedding itself terminating an agent that is
        running in-process with the other agents when per-agent
        resource accounting indicates that the agent is runaway.</p>
    </emu-note>

    <emu-note><span class="note">Note 6</span>
      <p>This proposal additionally suggests (see later text) that if
        termination is signaled then the signal creates a
        <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> edge in the memory ordering.</p>
    </emu-note>

  </emu-clause> <!-- agent cluster -->

</emu-clause>

<emu-clause id="GlobalObject">
  <h1><span class="secnum">4</span>The Global Object (<a href="https://tc39.github.io/ecma262/#sec-global-object">ES7 18</a>)<span class="utils"><span class="anchor"><a href="#GlobalObject">#</a></span></span></h1>
  <emu-clause id="GlobalObject.ConstructorProps">
    <h1><span class="secnum">4.1</span>Constructor Properties of the Global Object (<a href="https://tc39.github.io/ecma262/#sec-constructor-properties-of-the-global-object">ES7 18.3</a>)<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps">#</a></span></span></h1>
    <emu-clause id="GlobalObject.ConstructorProps.SharedArrayBuffer">
      <h1><span class="secnum">4.1.1</span>SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.SharedArrayBuffer">#</a></span></span></h1>
      <p>Add a new subsection for SharedArrayBuffer, pointing to the appropriate new section (below).</p>
    </emu-clause>
    <emu-clause id="GlobalObject.ConstructorProps.Atomics">
      <h1><span class="secnum">4.1.2</span>Atomics<span class="utils"><span class="anchor"><a href="#GlobalObject.ConstructorProps.Atomics">#</a></span></span></h1>
      <p>Add a new subsection for Atomics, pointing to the appropriate new section (below).</p>
    </emu-clause>
  </emu-clause>
</emu-clause>

<!--
AllocateTypedArray only allocates an ArrayBuffer if length is specified.
These call AllocateTypedArray with a specified length:
  TypedArrayFrom (twice)
   called from:
     %TypedArray% ( object )
     %TypedArray%.from ( source [,mapFn [,thisArg]] )
  %TypedArray%.of ( ...items )
  %TypedArray%.prototype.filter ( callbackFn [, thisArg] )
  %TypedArray%.prototype.slice ( start, end )
  %TypedArray% ()
  %TypedArray% (length)
  -->

<emu-clause id="IndexedCollections">
  <h1><span class="secnum">5</span>Indexed Collections (<a href="https://tc39.github.io/ecma262/#sec-indexed-collections">ES7 22</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections">#</a></span></span></h1>
  <emu-clause id="IndexedCollections.TypedArray">
    <h1><span class="secnum">5.1</span>TypedArray Objects (<a href="https://tc39.github.io/ecma262/#sec-typedarray-objects">ES7 22.2</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray">#</a></span></span></h1>

    <emu-clause id="IndexedCollections.TypedArray.prototype">
      <h1><span class="secnum">5.1.1</span>Properties of the %TypedArrayPrototype% object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-%typedarrayprototype%-object">ES7 22.2.3</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype">#</a></span></span></h1>
      <emu-clause id="IndexedCollections.TypedArray.prototype.set">
        <h1><span class="secnum">5.1.1.1</span>%TypedArray%.prototype.set( <var>overloaded</var> [ , <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-overloaded-offset">ES7 22.2.3.23</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.set">#</a></span></span></h1>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1><span class="secnum">5.1.1.1.1</span>%TypedArray%.prototype.set( <var>array</var> [, <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">ES7 22.2.3.23.1</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray">#</a></span></span></h1>
          <p>This algorithm is modified as follows:</p>

          <p>In the call to <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operation is performed on a TypedArray.</p>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.setFromTypedArray">
          <h1><span class="secnum">5.1.1.1.2</span>%TypedArray%.prototype.set( <var>typedArray</var> [, <var>offset</var> ] ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-typedarray-offset">ES7 22.2.3.23.2</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.setFromTypedArray">#</a></span></span></h1>
          <p>This algorithm is modified as follows:</p>
          <p>Sets multiple values in this <var>TypedArray</var>, reading the values from the <var>typedArray</var> argument object. The optional <var>offset</var> value indicates the first element index in this <var>TypedArray</var> where values are written. If omitted, it is assumed to be 0.</p>
          <emu-alg><ol><li>Assert: <var>typedArray</var> has a [[TypedArrayName]] internal slot. If it does not, the definition in <emu-xref href="#sec-%typedarray%.prototype.set-array-offset"><a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set-array-offset">22.2.3.23.1</a></emu-xref> applies.</li><li>Let <var>target</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>target</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>target</var> does not have a [[TypedArrayName]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Assert: <var>target</var> has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>targetOffset</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>offset</var>).</li><li>If <var>targetOffset</var> &lt; 0, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>targetBuffer</var> be <var>target</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>targetBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetLength</var> be <var>target</var>.[[ArrayLength]].</li><li>Let <var>srcBuffer</var> be <var>typedArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>srcBuffer</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>targetName</var> be the String value of <var>target</var>.[[TypedArrayName]].</li><li>Let <var>targetType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetElementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>targetName</var>.</li><li>Let <var>targetByteOffset</var> be <var>target</var>.[[ByteOffset]].</li><li>Let <var>srcName</var> be the String value of <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>srcType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcElementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>srcName</var>.</li><li>Let <var>srcLength</var> be <var>typedArray</var>.[[ArrayLength]].</li><li>Let <var>srcByteOffset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>If <var>srcLength</var> + <var>targetOffset</var> &gt; <var>targetLength</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li><ins>If both <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>srcBuffer</var>) and <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>targetBuffer</var>) are <emu-val>true</emu-val>, then let <var>same</var> be <emu-val>true</emu-val> if <var>srcBuffer</var>.[[ArrayBufferData]] equals <var>targetBuffer</var>.[[ArrayBufferData]]; otherwise let <var>same</var> be <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>).</ins></li><li><del>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcBuffer</var>, <var>targetBuffer</var>)</del> <ins><var>same</var></ins> is <emu-val>true</emu-val>, then<ol><li>Let <var>srcBuffer</var> be ? <emu-xref aoid="CloneArrayBuffer"><a href="https://tc39.github.io/ecma262/#sec-clonearraybuffer">CloneArrayBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteOffset</var>, <var>srcLength</var>, <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref>).</li><li>NOTE: <emu-xref href="#sec-arraybuffer-constructor"><a href="https://tc39.github.io/ecma262/#sec-arraybuffer-constructor">%ArrayBuffer%</a></emu-xref> is used to clone <var>srcBuffer</var> because is it known to not have any observable side-effects.</li><li>Let <var>srcByteIndex</var> be 0.</li></ol></li><li>Else, let <var>srcByteIndex</var> be <var>srcByteOffset</var>.</li><li>Let <var>targetByteIndex</var> be <var>targetOffset</var> × <var>targetElementSize</var> + <var>targetByteOffset</var>.</li><li>Let <var>limit</var> be <var>targetByteIndex</var> + <var>targetElementSize</var> × <var>srcLength</var>.</li><li>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>srcType</var>, <var>targetType</var>) is <emu-val>true</emu-val>, then<ol><li>NOTE: If <var>srcType</var> and <var>targetType</var> are the same, the transfer must be performed in a manner that preserves the bit-level encoding of the source data.</li><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var><ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <code>"Uint8"</code>, <ins><emu-val>true</emu-val></ins>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <code>"Uint8"</code>, <ins><emu-val>true</emu-val></ins>, <var>value</var>).</li><li>...</li></ol></li></ol></li><li>Else,<ol><li>Repeat, while <var>targetByteIndex</var> &lt; <var>limit</var><ol><li>Let <var>value</var> be <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>(<var>srcBuffer</var>, <var>srcByteIndex</var>, <var>srcType</var>, <ins><emu-val>true</emu-val></ins>).</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>(<var>targetBuffer</var>, <var>targetByteIndex</var>, <var>targetType</var>, <ins><emu-val>true</emu-val></ins>, <var>value</var>).</li><li>...</li></ol></li></ol></li><li>Return <emu-val>undefined</emu-val>.
          </li></ol></emu-alg>
        </emu-clause>

        <emu-clause id="IndexedCollections.TypedArray.prototype.slice">
          <h1><span class="secnum">5.1.1.1.3</span>%TypedArray%.prototype.slice( <var>start</var>, <var>end</var> ) (<a href="https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice">ES7 22.2.3.24</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.prototype.slice">#</a></span></span></h1>
          <p>This algorithm is modified as follows:</p>

          <p>In the calls to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operations are
            performed on a TypedArray.</p>
        </emu-clause>
      </emu-clause>
    </emu-clause>

    <emu-clause id="IndexedCollections.TypedArray.constructors">
      <h1><span class="secnum">5.1.2</span>The %TypedArray% constructors (<a href="https://tc39.github.io/ecma262/#sec-typedarray-constructors">ES7 22.2.4</a>)<span class="utils"><span class="anchor"><a href="#IndexedCollections.TypedArray.constructors">#</a></span></span></h1>

      <!-- es6num="22.2.1.3" -->
      <emu-clause id="sec-typedarray-typedarray">
        <h1><span class="secnum">5.1.2.1</span><var>TypedArray</var> ( <var>typedArray</var> ) (<a href="https://tc39.github.io/ecma262/#sec-typedarray-typedarray">ES7 22.2.4.3</a>)<span class="utils"><span class="anchor"><a href="#sec-typedarray-typedarray">#</a></span></span></h1>

        <p>This algorithm is modified as follows:</p>

        <p>In the calls to <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> and <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>, pass <emu-val>true</emu-val> as the fourth argument to indicate that the operations are performed on a TypedArray.</p>
      </emu-clause>

    </emu-clause> <!-- intrinsic object -->

  </emu-clause>
</emu-clause>

<emu-clause id="StructuredData">
  <h1><span class="secnum">6</span>Structured Data (<a href="https://tc39.github.io/ecma262/#sec-structured-data">ES7 24</a>)<span class="utils"><span class="anchor"><a href="#StructuredData">#</a></span></span></h1>

  <emu-clause id="StructuredData.ArrayBuffer">
    <h1><span class="secnum">6.1</span>ArrayBuffer Objects (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer-objects">ES7 24.1</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.ArrayBuffer.abstract">
      <h1><span class="secnum">6.1.1</span>Abstract Operations for ArrayBuffer (<a href="https://tc39.github.io/ecma262/#sec-abstract-operations-for-arraybuffer-objects">ES7 24.1.1</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="sec-detacharraybuffer" aoid="DetachArrayBuffer">
        <h1><span class="secnum">6.1.1.1</span>DetachArrayBuffer ( <var>arrayBuffer</var> ) (<a href="https://tc39.github.io/ecma262/#sec-detacharraybuffer">ES7 24.1.1.3</a>)<span class="utils"><span class="anchor"><a href="#sec-detacharraybuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation DetachArrayBuffer with argument <var>arrayBuffer</var> performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>arrayBuffer</var>) is Object and it has [[ArrayBufferData]] and [[ArrayBufferByteLength]] internal slots.</li><li><ins>Assert: <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</ins></li><li>...
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.RawBytesToNumber" aoid="RawBytesToNumber">
        <h1><span class="secnum">6.1.1.2</span><ins>RawBytesToNumber( <var>type</var>, <var>rawBytes</var>, <var>isLittleEndian</var> )</ins><span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.RawBytesToNumber">#</a></span></span></h1>
        <p>This is a new abstract operation.</p>
        <p><ins>The abstract operation RawBytesToNumber takes three parameters, a String <var>type</var>, a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> <var>rawBytes</var>, and a Boolean <var>isLittleEndian</var>.</ins></p>
        <emu-alg><ol><li><ins>If <var>isLittleEndian</var> is <emu-val>false</emu-val>, reverse the order of the elements of <var>rawBytes</var>.</ins></li><li><ins>If <var>type</var> is <code>"Float32"</code>, then</ins><ol><li><ins>Let <var>value</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.</ins></li><li><ins>If <var>value</var> is an IEEE 754-2008 binary32 NaN value, return the <emu-val>NaN</emu-val> Number value.</ins></li><li><ins>Return the Number value that corresponds to <var>value</var>.</ins></li></ol></li><li><ins>If <var>type</var> is <code>"Float64"</code>, then</ins><ol><li><ins>Let <var>value</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.</ins></li><li><ins>If <var>value</var> is an IEEE 754-2008 binary64 NaN value, return the <emu-val>NaN</emu-val> Number value.</ins></li><li><ins>Return the Number value that corresponds to <var>value</var>.</ins></li></ol></li><li><ins>If the first code unit of <var>type</var> is <code>"U"</code>, then</ins><ol><li><ins>Let <var>intValue</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Let <var>intValue</var> be the byte elements of <var>rawBytes</var> concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length <var>elementSize</var> × 8.</ins></li></ol></li><li><ins>Return the Number value that corresponds to <var>intValue</var>.</ins>
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetValueFromBuffer" aoid="GetValueFromBuffer">
        <h1><span class="secnum">6.1.1.3</span>GetValueFromBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>,  <ins><var>isTypedArray</var>, <var>order</var></ins> [, <var>isLittleEndian</var>] ) (<a href="https://tc39.github.io/ecma262/#sec-getvaluefrombuffer">ES7 24.1.1.5</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation GetValueFromBuffer takes  <del>four</del><ins>six</ins> parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>arrayBuffer</var>, an integer <var>byteIndex</var>, a String <var>type</var>,  <ins>a Boolean <var>isTypedArray</var>, a String <var>order</var>,</ins> and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Assert: <var>byteIndex</var> is an integer value ≥ 0.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</li><li><del>Let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <var>elementSize</var> containing, in order, the <var>elementSize</var> sequence of bytes starting with <var>block</var>[<var>byteIndex</var>].</del><br><ins>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val> then</ins><ol><li><ins>Let <var>execution</var> be the [[CandidateExecution]] field of the <em>surrounding agent</em>'s <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref>.</ins></li><li><ins>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventLists]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</ins></li><li><ins>Let <var>noTear</var> be <emu-val>true</emu-val> if <var>isTypedArray</var> is <emu-val>true</emu-val> and <var>type</var> is <code>"Int8"</code>, <code>"Uint8"</code>, <code>"Int16"</code>, <code>"Uint16"</code>, <code>"Int32"</code>, or <code>"Uint32"</code>, otherwise <emu-val>false</emu-val>.</ins></li><li><ins>Let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>elementSize</var> of nondeterministically chosen byte values.</ins></li><li><ins>NOTE: In implementations, <var>rawValue</var> is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> to describe observable behavior of hardware with weak consistency.</ins></li><li><ins>Let <var>readEvent</var> be ReadSharedMemory{[[Order]]: <var>order</var>, [[NoTear]]: <var>noTear</var>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var>}.</ins></li><li><ins>Append <var>readEvent</var> to _eventList.</ins></li><li><ins>Append {[[Event]]: <var>readEvent</var>, [[ChosenValue]]: <var>rawValue</var>} to <var>execution</var>.[[ChosenValues]].</ins></li></ol></li><li><ins>Else, let <var>rawValue</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing, in order, the <var>elementSize</var> sequence of bytes starting with <var>block</var>[<var>byteIndex</var>].</ins></li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to <del>either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref> abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref></ins>.</li><li><del>If <var>isLittleEndian</var> is <emu-val>false</emu-val>, reverse the order of the elements of <var>rawValue</var>.</del><br><ins>Let <var>value</var> be <emu-xref aoid="RawBytesToNumber"><a href="#StructuredData.ArrayBuffer.abstract.RawBytesToNumber">RawBytesToNumber</a></emu-xref>(<var>type</var>, <var>rawValue</var>, <var>isLittleEndian</var>).</ins></li><li><del>If <var>type</var> is <code>"Float32"</code>, then</del><ol><li><del>Let <var>value</var> be the byte elements of <var>rawValue</var> concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary32 value.</del></li><li><del>If <var>value</var> is an IEEE 754-2008 binary32 NaN value, return the <emu-val>NaN</emu-val> Number value.</del></li><li><del>Return the Number value that corresponds to <var>value</var>.</del></li></ol></li><li><del>If <var>type</var> is <code>"Float64"</code>, then</del><ol><li><del>Let <var>value</var> be the byte elements of <var>rawValue</var> concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2008 binary64 value.</del></li><li><del>If <var>value</var> is an IEEE 754-2008 binary64 NaN value, return the <emu-val>NaN</emu-val> Number value.</del></li><li><del>Return the Number value that corresponds to <var>value</var>.</del></li></ol></li><li><del>If the first code unit of <var>type</var> is <code>"U"</code>, then</del><ol><li><del>Let <var>intValue</var> be the byte elements of <var>rawValue</var> concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.</del></li></ol></li><li><del>Else,</del><ol><li><del>Let <var>intValue</var> be the byte elements of <var>rawValue</var> concatenated and interpreted as a bit string encoding of a binary little-endian 2's complement number of bit length <var>elementSize</var> × 8.</del></li></ol></li><li><del>Return the Number value that corresponds to <var>intValue</var>.</del> <ins>Return <var>value</var>.</ins>
        </li></ol></emu-alg>

        <p>All existing uses of the form GetValueFromBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isLittleEndian</var>) in TypedArray methods and abstract operations are changed to  <ins>GetValueFromBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <emu-val>true</emu-val>, <code>"Unordered"</code>, <var>isLittleEndian</var>).</ins></p>
        <p>All existing uses of the form GetValueFromBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>isLittleEndian</var>) in non-TypedArray methods and abstract operations are changed to  <ins>GetValueFromBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <emu-val>false</emu-val>, <code>"Unordered"</code>, <var>isLittleEndian</var>).</ins></p>
        <p>All existing uses of the form GetValueFromBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>) in TypedArray methods and abstract operations are changed to  <ins>GetValueFromBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <emu-val>true</emu-val>, <code>"Unordered"</code>).</ins></p>
        <p>All existing uses of the form GetValueFromBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>) in non-TypedArray methods and abstract operations are changed to  <ins>GetValueFromBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <emu-val>false</emu-val>, <code>"Unordered"</code>).</ins></p>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.NumberToRawBytes" aoid="NumberToRawBytes">
        <h1><span class="secnum">6.1.1.4</span><ins>NumberToRawBytes( <var>type</var>, <var>value</var>, <var>isLittleEndian</var> )</ins><span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.NumberToRawBytes">#</a></span></span></h1>
        <p><ins>The abstract operation NumberToRawBytes takes three parameters, a String <var>type</var>, a Number <var>value</var>, and a Boolean <var>isLittleEndian</var>.</ins></p>
        <emu-alg><ol><li><ins>If <var>type</var> is <code>"Float32"</code>, then</ins><ol><li><ins>Set <var>rawBytes</var> to a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the 4 bytes that are the result of converting <var>value</var> to IEEE 754-2008 binary32 format using “Round to nearest, ties to even” rounding mode. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <var>value</var> is <emu-val>NaN</emu-val>, <var>rawValue</var> may be set to any implementation chosen IEEE 754-2008 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable <emu-val>NaN</emu-val> value.</ins></li></ol></li><li><ins>Else if <var>type</var> is <code>"Float64"</code>, then</ins><ol><li><ins>Set <var>rawBytes</var> to a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of <var>value</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <var>value</var> is <emu-val>NaN</emu-val>, <var>rawValue</var> may be set to any implementation chosen IEEE 754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable <emu-val>NaN</emu-val> value.</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Let <var>n</var> be the Number value of the Element Size specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</ins></li><li><ins>Let <var>convOp</var> be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</ins></li><li><ins>Let <var>intValue</var> be <var>convOp</var>(<var>value</var>).</ins></li><li><ins>If <var>intValue</var> ≥ 0, then</ins><ol><li><ins>Let <var>rawBytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the <var>n</var>-byte binary encoding of <var>intValue</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</ins></li></ol></li><li><ins>Else,</ins><ol><li><ins>Let <var>rawBytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the <var>n</var>-byte binary 2's complement encoding of <var>intValue</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</ins></li></ol></li></ol></li><li><ins>Return <var>rawBytes</var>.</ins>
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.SetValueInBuffer" aoid="SetValueInBuffer">
        <h1><span class="secnum">6.1.1.5</span>SetValueInBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>,  <ins><var>isTypedArray</var>, <var>order</var></ins> [, <var>isLittleEndian</var>] ) (<a href="https://tc39.github.io/ecma262/#sec-setvalueinbuffer">ES7 24.1.1.6</a>)<span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>The abstract operation SetValueInBuffer takes  <del>five</del><ins>seven</ins> parameters, an ArrayBuffer  <ins>or SharedArrayBuffer</ins> <var>arrayBuffer</var>, an integer <var>byteIndex</var>, a String <var>type</var>, a Number <var>value</var>,  <ins>a Boolean <var>isTypedArray</var>, a String <var>order</var>,</ins> and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps:</p>

        <emu-alg><ol><li>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</li><li>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</li><li>Assert: <var>byteIndex</var> is an integer value ≥ 0.</li><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>value</var>) is Number.</li><li>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</li><li>Assert: <var>block</var> is not <emu-val>undefined</emu-val>.</li><li>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to <del>either <emu-val>true</emu-val> or <emu-val>false</emu-val>. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> abstract operation</del> <ins>the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref></ins>.</li><li><del>If <var>type</var> is <code>"Float32"</code>, then</del><br><ins>Let <var>rawBytes</var> be <emu-xref aoid="NumberToRawBytes"><a href="#StructuredData.ArrayBuffer.abstract.NumberToRawBytes">NumberToRawBytes</a></emu-xref>(<var>type</var>, <var>value</var>, <var>isLittleEndian</var>).</ins><ol><li><del>Set <var>rawBytes</var> to a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the 4 bytes that are the result of converting <var>value</var> to IEEE 754-2008 binary32 format using “Round to nearest, ties to even” rounding mode. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <var>value</var> is <emu-val>NaN</emu-val>, <var>rawValue</var> may be set to any implementation chosen IEEE 754-2008 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable <emu-val>NaN</emu-val> value.</del></li></ol></li><li><del>Else if <var>type</var> is <code>"Float64"</code>, then</del><ol><li><del>Set <var>rawBytes</var> to a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the 8 bytes that are the IEEE 754-2008 binary64 format encoding of <var>value</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are arranged in big endian order. Otherwise, the bytes are arranged in little endian order. If <var>value</var> is <emu-val>NaN</emu-val>, <var>rawValue</var> may be set to any implementation chosen IEEE 754-2008 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable <emu-val>NaN</emu-val> value.</del></li></ol></li><li><del>Else,</del><ol><li><del>Let <var>n</var> be the Number value of the Element Size specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</del></li><li><del>Let <var>convOp</var> be the abstract operation named in the Conversion Operation column in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</del></li><li><del>Let <var>intValue</var> be <var>convOp</var>(<var>value</var>).</del></li><li><del>If <var>intValue</var> ≥ 0, then</del><ol><li><del>Let <var>rawBytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the <var>n</var>-byte binary encoding of <var>intValue</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</del></li></ol></li><li><del>Else,</del><ol><li><del>Let <var>rawBytes</var> be a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> containing the <var>n</var>-byte binary 2's complement encoding of <var>intValue</var>. If <var>isLittleEndian</var> is <emu-val>false</emu-val>, the bytes are ordered in big endian order. Otherwise, the bytes are ordered in little endian order.</del></li></ol></li></ol></li><li><del>Store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>byteIndex</var>].</del><br><ins>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>, then</ins><ol><li><ins>Let <var>execution</var> be the [[CandidateExecution]] field of the <em>surrounding agent</em>'s <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref>.</ins></li><li><ins>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[EventLists]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</ins></li><li><ins>Let <var>noTear</var> be <emu-val>true</emu-val> if <var>isTypedArray</var> is <emu-val>true</emu-val> and <var>type</var> is <code>"Int8"</code>, <code>"Uint8"</code>, <code>"Int16"</code>, <code>"Uint16"</code>, <code>"Int32"</code>, or <code>"Uint32"</code>, otherwise <emu-val>false</emu-val>.</ins></li><li><ins>Append WriteSharedMemory{[[Order]]: <var>order</var>, [[NoTear]]: <var>noTear</var>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var>, [[Payload]]: <var>rawBytes</var>} to _eventList.</ins></li></ol></li><li><ins>Else, store the individual bytes of <var>rawBytes</var> into <var>block</var>, in order, starting at <var>block</var>[<var>byteIndex</var>].</ins></li><li>Return <emu-xref aoid="NormalCompletion"><a href="https://tc39.github.io/ecma262/#sec-normalcompletion">NormalCompletion</a></emu-xref>(<emu-val>undefined</emu-val>).
        </li></ol></emu-alg>

        <p>All existing uses of the form SetValueInBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>isLittleEndian</var>) in TypedArray methods and abstract operations are changed to  <ins>SetValueInBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <emu-val>true</emu-val>, <code>"Unordered"</code>, <var>isLittleEndian</var>).</ins></p>
        <p>All existing uses of the form SetValueInBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>isLittleEndian</var>) in non-TypedArray methods and abstract operations are changed to  <ins>SetValueInBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <emu-val>false</emu-val>, <code>"Unordered"</code>, <var>isLittleEndian</var>).</ins></p>
        <p>All existing uses of the form SetValueInBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>) in TypedArray methods and abstract operations are changed to  <ins>SetValueInBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <emu-val>true</emu-val>, <code>"Unordered"</code>).</ins></p>
        <p>All existing uses of the form SetValueInBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>) in non-TypedArray methods and abstract operations are changed to  <ins>SetValueInBuffer(<var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <emu-val>false</emu-val>, <code>"Unordered"</code>).</ins></p>
      </emu-clause>

      <emu-clause id="StructuredData.ArrayBuffer.abstract.GetModifySetValueInBuffer" aoid="GetModifySetValueInBuffer">
        <h1><span class="secnum">6.1.1.6</span><ins>GetModifySetValueInBuffer( <var>arrayBuffer</var>, <var>byteIndex</var>, <var>type</var>, <var>value</var>, <var>op</var> [, <var>isLittleEndian</var>] )</ins><span class="utils"><span class="anchor"><a href="#StructuredData.ArrayBuffer.abstract.GetModifySetValueInBuffer">#</a></span></span></h1>
        <p>This is a new abstract operation.</p>
        <p><ins>The abstract operation GetModifySetValueInBuffer takes six parameters, An ArrayBuffer or SharedArrayBuffer <var>arrayBuffer</var>, a nonnegative integer <var>byteIndex</var>, a String <var>type</var>, a semantic function <var>op</var>, a Number <var>value</var>, and optionally a Boolean <var>isLittleEndian</var>. This operation performs the following steps given a valid execution <var>execution</var> (see the Atomics <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>):</ins></p>

        <emu-alg><ol><li><ins>Assert: <emu-xref aoid="IsDetachedBuffer"><a href="https://tc39.github.io/ecma262/#sec-isdetachedbuffer">IsDetachedBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>false</emu-val>.</ins></li><li><ins>Assert: There are sufficient bytes in <var>arrayBuffer</var> starting at <var>byteIndex</var> to represent a value of <var>type</var>.</ins></li><li><ins>Assert: <var>byteIndex</var> is an integer value ≥ 0.</ins></li><li><ins>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>value</var>) is Number.</ins></li><li><ins>Let <var>block</var> be <var>arrayBuffer</var>.[[ArrayBufferData]].</ins></li><li><ins>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for Element Type <var>type</var>.</ins></li><li><ins>If <var>isLittleEndian</var> is not present, set <var>isLittleEndian</var> to the value of the [[LittleEndian]] internal slot of the surrounding agent's <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref>.</ins></li><li><ins>Let <var>rawBytes</var> be <emu-xref aoid="NumberToRawBytes"><a href="#StructuredData.ArrayBuffer.abstract.NumberToRawBytes">NumberToRawBytes</a></emu-xref>(<var>type</var>, <var>value</var>, <var>isLittleEndian</var>).</ins></li><li><ins>Assert: <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>arrayBuffer</var>) is <emu-val>true</emu-val>.</ins></li><li><ins>Let <var>execution</var> be the [[CandidateExecution]] field of the <em>surrounding agent</em>'s <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref>.</ins></li><li><ins>Let <var>eventList</var> be the [[EventList]] field of the element in <var>execution</var>.[[AgentOrders]] whose [[AgentSignifier]] is <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</ins></li><li><ins>Let <var>rawBytesRead</var> be the a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length <var>elementSize</var> of nondeterministically chosen byte values.</ins></li><li><ins>NOTE: In implementations, <var>rawBytesRead</var> is the result of a load-link or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> to describe observable behavior of hardware with weak consistency.</ins></li><li><ins>Let <var>rmwEvent</var> be ReadModifyWriteSharedMemory{[[Order]]: <code>"SeqCst"</code>, [[NoTear]]: <emu-val>true</emu-val>, [[Block]]: <var>block</var>, [[ByteIndex]]: <var>byteIndex</var>, [[ElementSize]]: <var>elementSize</var>, [[Payload]]: <var>rawBytes</var>, [[ModifyOp]]: <var>op</var>}.</ins></li><li><ins>Append <var>rmwEvent</var> to _eventList.</ins></li><li><ins>Append {[[Event]]: <var>rmwEvent</var>, [[ChosenValue]]: <var>rawBytesRead</var>} to <var>execution</var>.[[ChosenValues]].</ins></li><li><ins>Let <var>value</var> be <emu-xref aoid="RawBytesToNumber"><a href="#StructuredData.ArrayBuffer.abstract.RawBytesToNumber">RawBytesToNumber</a></emu-xref>(<var>type</var>, <var>rawBytesRead</var>, <var>isLittleEndian</var>).</ins></li><li><ins>Return <var>value</var>.</ins>
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause> <!-- abstract -->

    <emu-clause id="sec-properties-of-the-arraybuffer-prototype-object">
      <h1><span class="secnum">6.1.2</span>Properties of the ArrayBuffer Prototype Object (<a href="https://tc39.github.io/ecma262/#sec-properties-of-the-arraybuffer-prototype-object">ES7 24.1.4</a>)<span class="utils"><span class="anchor"><a href="#sec-properties-of-the-arraybuffer-prototype-object">#</a></span></span></h1>

      <emu-clause id="sec-get-arraybuffer.prototype.bytelength">
        <h1><span class="secnum">6.1.2.1</span>get ArrayBuffer.prototype.byteLength (<a href="https://tc39.github.io/ecma262/#sec-get-arraybuffer.prototype.bytelength">ES7 24.1.4.1</a>)<span class="utils"><span class="anchor"><a href="#sec-get-arraybuffer.prototype.bytelength">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p><code>ArrayBuffer.prototype.byteLength</code> is an accessor property whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>...
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="sec-arraybuffer.prototype.slice">
        <h1><span class="secnum">6.1.2.2</span>ArrayBuffer.prototype.slice ( <var>start</var>, <var>end</var> ) (<a href="https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice">ES7 24.1.4.3</a>)<span class="utils"><span class="anchor"><a href="#sec-arraybuffer.prototype.slice">#</a></span></span></h1>
        <p>This algorithm is modified as follows:</p>
        <p>The following steps are taken:</p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li><ins>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</ins></li><li>...
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause> <!-- ArrayBuffer -->

  <emu-clause id="StructuredData.SharedArrayBuffer">
    <h1><span class="secnum">6.2</span>SharedArrayBuffer Objects<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer">#</a></span></span></h1>

    <emu-clause id="StructuredData.SharedArrayBuffer.abstract">
      <h1><span class="secnum">6.2.1</span>Abstract Operations for SharedArrayBuffer<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract">#</a></span></span></h1>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">
        <h1><span class="secnum">6.2.1.1</span>AllocateSharedArrayBuffer( <var>constructor</var>, <var>byteLength</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.AllocateSharedArrayBuffer">#</a></span></span></h1>
        <p>The abstract operation AllocateSharedArrayBuffer with arguments <var>constructor</var> and <var>byteLength</var> is used to create a SharedArrayBuffer object. It performs the following steps:</p>

        <emu-alg><ol><li>Let <var>obj</var> be ? <emu-xref aoid="OrdinaryCreateFromConstructor"><a href="https://tc39.github.io/ecma262/#sec-ordinarycreatefromconstructor">OrdinaryCreateFromConstructor</a></emu-xref>(constructor, "%SharedArrayBufferPrototype%", «‍[[ArrayBufferData]], [[ArrayBufferByteLength]]» ).</li><li>Assert: <var>byteLength</var> is a nonnegative integer.</li><li>Let <var>block</var> be ? <emu-xref aoid="CreateSharedByteDataBlock"><a href="#DataTypesValues.SpecTypes.DataBlocks.CreateSharedByteDataBlock">CreateSharedByteDataBlock</a></emu-xref>(<var>byteLength</var>).</li><li>Set <var>obj</var>.[[ArrayBufferData]] to <var>block</var>.</li><li>Set <var>obj</var>.[[ArrayBufferByteLength]] to <var>byteLength</var>.</li><li>Return <var>obj</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer" aoid="IsSharedArrayBuffer">
        <h1><span class="secnum">6.2.1.2</span>IsSharedArrayBuffer( <var>obj</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">#</a></span></span></h1>
        <p>IsSharedArrayBuffer tests whether an object that is an ArrayBuffer, a SharedArrayBuffer, or a subtype of either is a SharedArrayBuffer or a subtype of it.  It performs the following steps:</p>
        <emu-alg><ol><li>Assert: <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>obj</var>) is Object and it has an [[ArrayBufferData]] internal slot.</li><li>Let <var>bufferData</var> be <var>obj</var>.[[ArrayBufferData]].</li><li>If <var>bufferData</var> is <emu-val>null</emu-val> or <emu-val>undefined</emu-val> then return <emu-val>false</emu-val>.</li><li>If <var>bufferData</var> is a <emu-xref href="#sec-data-blocks"><a href="https://tc39.github.io/ecma262/#sec-data-blocks">Data Block</a></emu-xref> then return <emu-val>false</emu-val>.</li><li>Assert: <var>bufferData</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>.</li><li>Return <emu-val>true</emu-val>.
        </li></ol></emu-alg>
      </emu-clause>

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor">
      <h1><span class="secnum">6.2.1.3</span>The SharedArrayBuffer Constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor">#</a></span></span></h1>
      <p>The SharedArrayBuffer constructor is the %SharedArrayBuffer% intrinsic object and the initial value of the <code>SharedArrayBuffer</code> property of the <emu-xref href="#global-object"><a href="https://tc39.github.io/ecma262/#global-object">global object</a></emu-xref>. When called as a constructor it creates and initializes a new SharedArrayBuffer object.  The SharedArrayBuffer constructor is not intended to be called as a function and will throw an exception when called in that manner.</p>

      <p>The SharedArrayBuffer constructor is designed to be subclassable. It may be used as the value of an <code>extends</code> clause of a class definition. Subclass constructors that intend to inherit the specified SharedArrayBuffer behaviour must include a <code>super</code> call to the SharedArrayBuffer constructor to create and initialize subclass instances with the internal state necessary to support the <code>SharedArrayBuffer.prototype</code> built-in methods.</p>

      <emu-note><span class="note">Note</span>
        <p>Unlike an ArrayBuffer, a SharedArrayBuffer cannot become detached, and its internal [[ArrayBufferData]] slot is never <emu-val>null</emu-val> or <emu-val>undefined</emu-val>.</p>
      </emu-note>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.withLength">
        <h1><span class="secnum">6.2.1.3.1</span>SharedArrayBuffer( <var>length</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.withLength">#</a></span></span></h1>
        <p>SharedArrayBuffer called with argument <var>length</var> performs the following steps:</p>
        <emu-alg><ol><li>If NewTarget is <emu-val>undefined</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>numberLength</var> be ? <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>length</var>).</li><li>Let <var>byteLength</var> be <emu-xref aoid="ToLength"><a href="https://tc39.github.io/ecma262/#sec-tolength">ToLength</a></emu-xref>(<var>numberLength</var>).</li><li>If <emu-xref aoid="SameValueZero"><a href="https://tc39.github.io/ecma262/#sec-samevaluezero">SameValueZero</a></emu-xref>(<var>numberLength</var>, <var>byteLength</var>) is <emu-val>false</emu-val>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return AllocateSharedArrayBuffer(NewTarget, <var>byteLength</var>).
        </li></ol></emu-alg>
      </emu-clause>
    </emu-clause> <!-- constructor -->

    <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties">
      <h1><span class="secnum">6.2.1.4</span>Properties of the SharedArrayBuffer constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties">#</a></span></span></h1>

      <p>The value of the [[Prototype]] internal slot of the SharedArrayBuffer constructor is the intrinsic object <emu-xref href="#sec-properties-of-the-function-constructor"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-function-constructor">%FunctionPrototype%</a></emu-xref> (q.v.).</p>

      <p>Besides its <code>length</code> property (whose value is 1), the SharedArrayBuffer constructor has the following properties:</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.prototype">
        <h1><span class="secnum">6.2.1.4.1</span>SharedArrayBuffer.prototype<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.prototype">#</a></span></span></h1>
        <p>The initial value of SharedArrayBuffer.prototype is the intrinsic object %SharedArrayBufferPrototype% (q.v.).</p>
        <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>false</emu-val> }.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.constructor.properties.get_species">
        <h1><span class="secnum">6.2.1.4.2</span>get SharedArrayBuffer [ @@species ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.constructor.properties.get_species">#</a></span></span></h1>
        <p><code>SharedArrayBuffer[@@species]</code> is an accessor property whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>
        <emu-alg><ol><li>Return the <emu-val>this</emu-val> value.
        </li></ol></emu-alg>
        <p>The value of the name property of this function is "<code>get [Symbol.species]</code>".</p>
      </emu-clause>
    </emu-clause> <!-- properties -->

    <emu-clause id="StructuredData.SharedArrayBuffer.prototype">
      <h1><span class="secnum">6.2.1.5</span>Properties of the SharedArrayBuffer prototype object<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype">#</a></span></span></h1>

      <p>The SharedArrayBuffer prototype object is the intrinsic object %SharedArrayBufferPrototype%. The value of the [[Prototype]] internal slot of the SharedArrayBuffer prototype object is the intrinsic object <emu-xref href="#sec-properties-of-the-object-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-object-prototype-object">%ObjectPrototype%</a></emu-xref> (19.1.3). The SharedArrayBuffer prototype object is an ordinary object. It does not have an [[ArrayBufferData]] or [[ArrayBufferByteLength]] internal slot.</p>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.get_byteLength">
        <h1><span class="secnum">6.2.1.5.1</span>get SharedArrayBuffer.prototype.byteLength<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.get_byteLength">#</a></span></span></h1>

        <p>SharedArrayBuffer.prototype.byteLength is an accessor property whose set accessor function is <emu-val>undefined</emu-val>. Its get accessor function performs the following steps:</p>

        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have a [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>length</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Return <var>length</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.constructor">
        <h1><span class="secnum">6.2.1.5.2</span>SharedArrayBuffer.prototype.constructor<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.constructor">#</a></span></span></h1>
        <p>The initial value of <code>SharedArrayBuffer.prototype.constructor</code> is the intrinsic object %SharedArrayBuffer%.</p>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.slice">
        <h1><span class="secnum">6.2.1.5.3</span>SharedArrayBuffer.prototype.slice( <var>start</var>, <var>end</var> )<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.slice">#</a></span></span></h1>
        <p>The following steps are taken:</p>
        <emu-alg><ol><li>Let <var>O</var> be the <emu-val>this</emu-val> value.</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>O</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>O</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>O</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>len</var> be <var>O</var>.[[ArrayBufferByteLength]].</li><li>Let <var>relativeStart</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>start</var>).</li><li>If <var>relativeStart</var> &lt; 0, let first be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>((<var>len</var> + <var>relativeStart</var>), 0); else let first be <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>relativeStart</var>, <var>len</var>).</li><li>If <var>end</var> is <emu-val>undefined</emu-val>, let <var>relativeEnd</var> be <var>len</var>; else let <var>relativeEnd</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>end</var>).</li><li>If <var>relativeEnd</var> &lt; 0, let <var>final</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>((<var>len</var> + <var>relativeEnd</var>), 0); else let <var>final</var> be <emu-xref aoid="min"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">min</a></emu-xref>(<var>relativeEnd</var>, <var>len</var>).</li><li>Let <var>newLen</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<var>final</var> - <var>first</var>, 0).</li><li>Let <var>ctor</var> be ? <emu-xref aoid="SpeciesConstructor"><a href="https://tc39.github.io/ecma262/#sec-speciesconstructor">SpeciesConstructor</a></emu-xref>(<var>O</var>, %SharedArrayBuffer%).</li><li>Let <var>new</var> be ? <emu-xref aoid="Construct"><a href="https://tc39.github.io/ecma262/#sec-construct">Construct</a></emu-xref>(<var>ctor</var>, «newLen»).</li><li>If <var>new</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="SameValue"><a href="https://tc39.github.io/ecma262/#sec-samevalue">SameValue</a></emu-xref>(<var>new</var>, <var>O</var>) is <emu-val>true</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>new</var>.[[ArrayBufferByteLength]] &lt; <var>newLen</var>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>fromBuf</var> be <var>O</var>.[[ArrayBufferData]].</li><li>Let <var>toBuf</var> be <var>new</var>.[[ArrayBufferData]].</li><li>Perform <emu-xref aoid="CopyDataBlockBytes"><a href="#DataTypesValues.SpecTypes.DataBlocks.CopyDataBlockBytes">CopyDataBlockBytes</a></emu-xref>(<var>toBuf</var>, 0, <var>fromBuf</var>, <var>first</var>, <var>newLen</var>).</li><li>Return <var>new</var>.
        </li></ol></emu-alg>
      </emu-clause>

      <emu-clause id="StructuredData.SharedArrayBuffer.prototype.toString">
        <h1><span class="secnum">6.2.1.5.4</span>SharedArrayBuffer.prototype[ @@toStringTag ]<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.prototype.toString">#</a></span></span></h1>
        <p>The initial value of the @@toStringTag property is the String value <code>"SharedArrayBuffer"</code>.</p>

        <p>This property has the attributes { [[Writable]]: <emu-val>false</emu-val>, [[Enumerable]]: <emu-val>false</emu-val>, [[Configurable]]: <emu-val>true</emu-val> }.</p>
      </emu-clause>
    </emu-clause> <!-- prototype -->

    <emu-clause id="StructuredData.SharedArrayBuffer.instances">
      <h1><span class="secnum">6.2.1.6</span>Properties of the SharedArrayBuffer instances<span class="utils"><span class="anchor"><a href="#StructuredData.SharedArrayBuffer.instances">#</a></span></span></h1>

      <p>SharedArrayBuffer instances inherit properties from the SharedArrayBuffer prototype object. SharedArrayBuffer instances each have an [[ArrayBufferData]] internal slot and a [[ArrayBufferByteLength]] internal slot.</p>

      <emu-note><span class="note">Note</span>
        <p>SharedArrayBuffer instances, unlike ArrayBuffer instances, are never detached.</p>
      </emu-note>
    </emu-clause> <!-- instances -->

  </emu-clause> <!-- SharedArrayBuffer -->
</emu-clause> <!-- Structured data -->

<emu-clause id="AtomicsObject">
  <h1><span class="secnum">6.3</span>The Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObject">#</a></span></span></h1>

  <p>The Atomics object is the  <dfn>%Atomics%</dfn> intrinsic object and the initial value of the <code>Atomics</code> property of the <emu-xref href="#global-object"><a href="https://tc39.github.io/ecma262/#global-object">global object</a></emu-xref>. The Atomics object is a single ordinary object.</p>
  <p>The Atomics object provides functions that operate indivisibly (atomically) on shared memory array cells as well as functions that let agents wait for and dispatch primitive events.  When used with discipline, the Atomics functions allow multi-agent programs that communicate through shared memory to execute in a well-understood order even on parallel CPUs.  The rules that govern shared-memory communication are provided by the  <dfn>memory model</dfn>, defined below.</p>
  <p>The value of the [[Prototype]] internal slot of the Atomics object is the intrinsic object <emu-xref href="#sec-properties-of-the-object-prototype-object"><a href="https://tc39.github.io/ecma262/#sec-properties-of-the-object-prototype-object">%ObjectPrototype%</a></emu-xref>.</p>
  <p>The Atomics object is not a function object. It does not have a [[Construct]] internal method; it is not possible to use the Atomics object as a constructor with the <code>new</code> operator. The Atomics object also does not have a [[Call]] internal method; it is not possible to invoke the Atomics object as a function.</p>

  <emu-clause id="MemoryModel">
    <h1><span class="secnum">6.3.1</span>Memory Model<span class="utils"><span class="anchor"><a href="#MemoryModel">#</a></span></span></h1>

    <emu-note><span class="note">Note 1</span>
      <p>(Spec draft notes)</p>
      <h2>What We Talk About When We Talk About Atomicity</h2>
      <p>Atomicity means two things. One, it means that an action is indivisible. For example, writing a value to memory should write the whole value all at once. This is called access atomicity. Two, it means the timing with which different threads can observe a memory access, i.e., the ordering of memory events. For example, on x86, a memory write becomes visible to all cores other than the writing core at exactly the same time. On ARM, a memory write may become visible to other cores at different times. This is called copy atomicity.</p>

      <p>Access atomicity is the easier problem. Hardware provides access atomic instructions that provide the guarantee. Copy atomicity much more difficult. Memory models concern themselves with prescribing some flavor of copy atomicity by ordering memory operations. Access atomicity may be thought of as an orthogonal property that is applied on top of the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>.</p>

      <h2>Intuitions for the Memory Model</h2>
      <p>The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> proper is a set of relational constraints on a set of memory events. The memory events correspond to read, write, and read-modify-write operations. Most readers' mental models of computation tend to be operational in that they show meaning by describing what each step of a computation does, in algorithmic fashion. ECMA262, excluding this section, is specified in this operational fashion. The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>, in contrast, corresponds closer to classical logic rather than constructive logic, in that they show meaning by describing a set of axiomatic constraints that must be satisfied. Instead of constructing an algorithm that builds up the possible memory values, the model describes the set of all possible allowed memory values of a program directly via relational constraints.</p>

      <p>Thought of another way, the operational model of ECMA262 constructs an execution that is correct by construction. The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> instead is a filter on  <em>all</em> executions. Some of those executions may not be correct, and the correct ones are exactly the ones that are allowed by the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>.</p>

      <p>The model is best understood in two parts: the axiomatic part and the interfacing with the rest of ECMA262.</p>

      <p>The axiomatic part is a weak consistency model. It needs to be flexible enough to allow a set of astonishing observable behavior that are exhibited on weak hardware like ARM and Power. For example, in certain cases, causality is allowed to be violated. At the same time, the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> needs to enable programmers reasoning about programs. These two needs run counter to each other. The compromise in the community is a guarantee called Sequential Consistency for Data Race Free Programs, or SC-DRF. In informal terms, SC-DRF says that if a program does not have concurrent, non-atomic memory accesses on the same memory locations (no data races), the program semantics is as if it were an interleaving of steps from each individual thread (sequentially consistent). The dual goal of the model is to fully define the semantics of races as well as enable SC-DRF reasoning.</p>

      <p>To understand the axiomatic model, assume that there is a set of events that correspond to some evaluation of a program. The evaluation gives an initial partial ordering of these events called <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref>: if an event <var>E</var> was evaluated before <var>D</var> in some thread, then <var>E</var> must come before <var>D</var> in <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref>. Along with the set of events and <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> is a function that maps read events to write events, <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref>. This function says which reads read from which writes during the evaluation. These three things make up a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref>, which is the input to the model. The model's job is to further order those events in such a way that candidate executions we should be able to observe on hardware are deemed valid, i.e., allowed, and executions that cannot be observed are deemed invalid, i.e. disallowed.</p>

      <p>The <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">partial order</a></emu-xref> <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> only orders events from the same thread. From this order we will build a new <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">partial order</a></emu-xref> called <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref>, which additionally relates pairs of correctly synchronized events. Data races, then, are precisely the events that are not relatable by <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref>. To build <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref>, we start by relating atomic reads that <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> atomic writes on the same memory location. These pairs are considered correctly synchronized. The <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">partial order</a></emu-xref> then includes all pairs from <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> and <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref>, as well as pairs of events that are transitively related.</p>

      <p>The SharedArrayBuffer API raises the difficulty that it allows aliased access on the same memory location via different sizes. That is, a read event can <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> multiple write events, resulting in reading a composite value of bytes written by multiple events. Problematically, hardware often cannot guarantee the atomicity of concurrent accesses that happen on overlapping locations. To this end the model only guarantees atomic reads and writes on exactly the same memory <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">range</a></emu-xref> to be synchronized. Atomic reads and writes on overlapping locations may behave as if they were non-atomic.</p>

      <p>After <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref>, we have one last constraint on synchronized atomics to enable SC-DRF reasoning. Recall that sequential consistency is an interleaving. Mathematically, this is equivalent to putting events in a <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">total order</a></emu-xref> (i.e., a sequence). Thus the model requires that valid executions have a total ordering of correctly synchronized atomic events called <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref>.</p>

      <p>These relations and orders mutually constrain each other so that they are coherent. The coherence constraints roughly correspond to the intuition that a read event cannot read from a write event that's "too old", in the sense that there's another write event on the memory location that happens-after the write event that was read from.</p>

      <p>Putting all of these together nets us a decision procedure that can decide if a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> is valid or not.</p>

      <p>Having this is not yet enough. How does this set of memory events arise in the first place? How do we connect this decision procedure, which acts on all possible executions, with the evaluation semantics of ECMA262?</p>

      <p>To connect the axiomatic semantics to the operational semantics, the operational semantics are made nondeterministic. Instead of constructing a single, valid execution, the nondeterministic operational semantics constructs  <em>all</em> candidate executions. This is captured by <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref> returning any possible byte value when operating on SharedArrayBuffers. It bears stressing that this is the stuff of semantics and not actual implementations. Implementations will simply return the value that the corresponding hardware load instruction returns. But the hardware may act astonishingly due to the sophistication of their implementation and seemingly read values from e.g., the future, or a branch not taken. One may think of this nondeterminism as treating the reads on shared memory as black boxes. Up front, it reads  <em>something</em>, the exact value of which is unknown until later, when we apply the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> decision procedure.</p>

      <p>With this nondeterminism the evaluation semantics can also accumulate events simply as a side effect of performing operations on SharedArrayBuffers. It does so by accumulating events and chosen values in the [[EventLists]] and [[ChosenValues]] fields in a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> during <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>., to be passed to the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>. The model then validates that the chosen values were not completely bogus in addition to all the constraints described above. It bears restressing that this reified <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> record and validation are purely formal mechanisms. Implementations will simply return what is read by hardware.</p>

      <p>So what we talk about when we talking about the meaning of a program that uses SharedArrayBuffer is the  <em>set</em> of valid executions. To wit, the evaluation semantics first generates the set of all possible candidate executions, then the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> filters out the invalid ones. The remaining executions is the meaning of the program. A program always has at least one valid execution.</p>

      <h2>Advice for Programmers</h2>
      <p>Keep programs <emu-xref aoid="data race free"><a href="#MemoryModel.DRF">data race free</a></emu-xref>, i.e., make it so that it is impossible for there to be concurrent non-atomic operations on the same memory location. Data <emu-xref aoid="race"><a href="#MemoryModel.Races">race</a></emu-xref> free programs have interleaving semantics where each step in the evaluation semantics of each agent are interleaved with each other. For <emu-xref aoid="data race free"><a href="#MemoryModel.DRF">data race free</a></emu-xref> programs, it is not necessary to understand the details of the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>. The details are unlikely to build intuition that will help one to better write JavaScript. It is the author's opinion that trying to exploit the semantics of races for performance is ill-advised and likely to be incorrect.</p>

      <h2>Advice for Implementers</h2>
      <p>While the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> is prescriptive by nature, it is intended to allow non-atomic accesses to be compiled to bare stores and loads and atomic accesses to be compiled in the "obvious way" on the underlying hardware. The intention is thus descriptive; the model must allow enough executions such that the astonishing effects that bare stores and loads on hardware with weak memory models exhibit are not prohibited. If an obvious implementation is found to be non-compliant, the bug is likely in the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> and not the implementation.</p>

      <h2>Acknowledgements</h2>
      <p>Many of the fundamentals and relations described here are inspired by the LLVM <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>. Hardware intuition comes in no small part from the wonderful work from Peter Sewell's Cambridge group. Many thanks to Alan Jeffrey and Michael Sullivan for reviewing drafts.</p>
    </emu-note>

    <p>The memory consistency model, or <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>, specifies the possible orderings of <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> events, arising via accessing TypedArray instances backed by a SharedArrayBuffer and via methods on the Atomics object. When the program has no data races (defined more precisely below), the ordering of events appears as sequentially consistent, i.e., as an interleaving of actions from each agent. When the program has data races, shared memory operations may appear sequentially inconsistent. For example, programs may exhibit causality-violating behavior and other astonishments. These astonishments arise from compiler transforms and the design of CPUs (e.g., out-of-order execution and speculation). The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> defines both the precise conditions under which a program exhibits sequentially consistent behavior as well as the possible values read from data races. To wit, there is no undefined behavior.</p>

    <p>The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> is defined as relational constraints on events introduced by abstract operations on SharedArrayBuffer or by methods on the Atomics object during an evaluation.</p>

    <emu-note><span class="note">Note 2</span>
      <p>This section provides an axiomatic model on events introduced by the abstract operations on SharedArrayBuffers. It bears stressing that the model is not expressible algorithmically, unlike the rest of this specification. The nondeterministic introduction of events by abstract operations is the interface between the operational semantics of ECMAScript evaluation and the axiomatic semantics of the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>. The semantics of these events is defined by considering graphs of all events in an evaluation. These are neither Static Semantics nor Runtime Semantics. There is no demonstrated algorithmic implementation, but instead a set of constraints that determine if a particular event graph is allowed or disallowed.</p>
    </emu-note>

    <emu-clause id="MemoryModel.Relations">
      <h1><span class="secnum">6.3.1.1</span>The Set and Relation Specification Types<span class="utils"><span class="anchor"><a href="#MemoryModel.Relations">#</a></span></span></h1>
      <p>The  <dfn>Set</dfn> type is used to explain a collection of unordered elements. Values of the Set type are simple collections of elements, where no element appears more than once. Elements may be added to and removed from Sets. Sets may be unioned, intersected, or subtracted from each other.</p>
      <p>The  <dfn>Relation</dfn> type is used to explain constraints on Sets. Values of the Relation type are Sets of ordered pairs of values from its value domain. For example, a Relation on events is a set of ordered pairs of events. For a Relation <var>R</var> and two values <var>a</var> and <var>b</var> in the value domain of <var>R</var>, <var>a</var> <var>R</var> <var>b</var> is shorthand for saying the ordered pair (<var>a</var>, <var>b</var>) is a member of <var>R</var>. A Relation is least with respect to some conditions when it is the smallest Relation that satisfies those conditions.</p>

      <p>A  <dfn>partial order</dfn> is a Relation value <var>R</var> that satisfies the following conditions.</p>

      <emu-alg><ol><li>Let <var>a</var>, <var>b</var>, and <var>c</var> be values of <var>R</var>'s domain.</li><li><var>a</var> <var>R</var> <var>a</var>, and</li><li>If <var>a</var> <var>R</var> <var>b</var> and <var>b</var> <var>R</var> <var>a</var> then <var>a</var> is <var>b</var>, and</li><li>If <var>a</var> <var>R</var> <var>b</var> and <var>b</var> <var>R</var> <var>c</var> then <var>a</var> <var>R</var> <var>c</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note 1</span>
        <p>The three properties above are called, in order, reflexivity, antisymmetry, and transitivity.</p>
      </emu-note>

      <p>A  <dfn>total order</dfn> is a Relation value <var>R</var> that satisfies the following conditions.</p>

      <emu-alg><ol><li>Let <var>a</var>, <var>b</var>, and <var>c</var> be values of <var>R</var>'s domain.</li><li><var>a</var> <var>R</var> <var>b</var> or <var>b</var> <var>R</var> <var>a</var>, and</li><li>If <var>a</var> <var>R</var> <var>b</var> and <var>b</var> <var>R</var> <var>a</var> then <var>a</var> is <var>b</var>, and</li><li>If <var>a</var> <var>R</var> <var>b</var> and <var>b</var> <var>R</var> <var>c</var> then <var>a</var> <var>R</var> <var>c</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note 2</span>
        <p>The three properties above are called, in order, totality, antisymmetry, and transitivity.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.Fundamentals">
      <h1><span class="secnum">6.3.1.2</span>Fundamentals<span class="utils"><span class="anchor"><a href="#MemoryModel.Fundamentals">#</a></span></span></h1>

      <p>Shared memory accesses (reads and writes) are divided into two groups, atomic accesses and data accesses, defined below. Atomic accesses are sequentially consistent, i.e., there is a total ordering of events agreed upon by all agents in an agent cluster. Non-atomic accesses do not have a total ordering agreed upon by all agents, i.e., unordered.</p>

      <emu-note><span class="note">Note 1</span>
        <p>No orderings weaker than sequentially consistent and stronger than unordered, such as release-acquire, are supported.</p>
      </emu-note>

      <p>A  <dfn>Shared Data Block event</dfn> is either a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref>.</p>

      <emu-table id="table-readsharedmemory-fields" caption="ReadSharedMemory Event Fields"><figure><figcaption>Table 2: ReadSharedMemory Event Fields</figcaption>
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Order]]</td>
              <td><code>"SeqCst"</code>, <code>"Unordered"</code>, or <code>"Init"</code>.</td>
              <td>The weakest ordering guaranteed by the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> for the event.</td>
            </tr>
            <tr>
              <td>[[NoTear]]</td>
              <td>A Boolean</td>
              <td>Whether this event is allowed to read from multiple write events on the equal range.</td>
            </tr>
            <tr>
              <td>[[Block]]</td>
              <td>A <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref></td>
              <td>The block the event operates on.</td>
            </tr>
            <tr>
              <td>[[ByteIndex]]</td>
              <td>A nonnegative integer</td>
              <td>The byte address of the read in [[Block]].</td>
            </tr>
            <tr>
              <td>[[ElementSize]]</td>
              <td>A nonnegative integer</td>
              <td>The size of the read.</td>
            </tr>
          </tbody>
        </table>
      </figure></emu-table>

      <emu-table id="table-writesharedmemory-fields" caption="WriteSharedMemory Event Fields"><figure><figcaption>Table 3: WriteSharedMemory Event Fields</figcaption>
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Order]]</td>
              <td><code>"SeqCst"</code>, <code>"Unordered"</code>, or <code>"Init"</code>.</td>
              <td>The weakest ordering guaranteed by the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> for the event.</td>
            </tr>
            <tr>
              <td>[[NoTear]]</td>
              <td>A Boolean</td>
              <td>Whether this event is allowed to be read from multiple read events on the equal range.</td>
            </tr>
            <tr>
              <td>[[Block]]</td>
              <td>A <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref></td>
              <td>The block the event operates on.</td>
            </tr>
            <tr>
              <td>[[ByteIndex]]</td>
              <td>A nonnegative integer</td>
              <td>The byte address of the write in [[Block]].</td>
            </tr>
            <tr>
              <td>[[ElementSize]]</td>
              <td>A nonnegative integer</td>
              <td>The size of the write.</td>
            </tr>
            <tr>
              <td>[[Payload]]</td>
              <td>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref></td>
              <td>The <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values to be read by other events.</td>
            </tr>
          </tbody>
        </table>
      </figure></emu-table>

      <emu-table id="table-rmwsharedmemory-fields" caption="ReadModifyWriteSharedMemory Event Fields"><figure><figcaption>Table 4: ReadModifyWriteSharedMemory Event Fields</figcaption>
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Order]]</td>
              <td><code>"SeqCst"</code></td>
              <td>Read-modify-write events are always sequentially consistent.</td>
            </tr>
            <tr>
              <td>[[NoTear]]</td>
              <td><emu-val>true</emu-val></td>
              <td>Read-modify-write events cannot tear.</td>
            </tr>
            <tr>
              <td>[[Block]]</td>
              <td>A <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref></td>
              <td>The block the event operates on.</td>
            </tr>
            <tr>
              <td>[[ByteIndex]]</td>
              <td>A nonnegative integer</td>
              <td>The byte address of the read-modify-write in [[Block]].</td>
            </tr>
            <tr>
              <td>[[ElementSize]]</td>
              <td>A nonnegative integer</td>
              <td>The size of the write.</td>
            </tr>
            <tr>
              <td>[[Payload]]</td>
              <td>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref></td>
              <td>The <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values to be passed to [[ModifyOp]].</td>
            </tr>
            <tr>
              <td>[[ModifyOp]]</td>
              <td>A semantic function</td>
              <td>A pure semantic function that returns a modified <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values from a read <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values and [[Payload]].</td>
            </tr>
          </tbody>
        </table>
      </figure></emu-table>

      <p>These events are introduced by an abstract operation or by a Function property on the Atomics object. Additionally, <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> events include host-specific events.</p>

      <p>Let the  <dfn>range</dfn> of a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event be the Set of contiguous integers from its <var>byteIndex</var> to <var>byteIndex</var>+<var>elementSize</var>-1. Two events' ranges are equal when the events have the same <var>block</var>, and the ranges are element-wise equal. Two events' ranges are overlapping when the events have the same <var>block</var>, the ranges are not equal and their intersection is non-empty. Two events' ranges are disjoint when the events do not have the same <var>block</var> or their ranges their neither equal nor overlapping.</p>

      <emu-note><span class="note">Note 2</span>
        <p>Examples of host-specific synchronizing events that should be accounted for are: sending a SharedArrayBuffer from one agent to another (e.g., by <code>postMessage</code> in a browser), starting and stopping agents, and communicating within the agent cluster via channels other than shared memory. It is assumed those events are appended to <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> during evaluation like the other SharedArrayBuffer events.</p>
      </emu-note>

      <p><emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> events are ordered within candidate executions by the relations defined mutually recursively below.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.AgentEventsRecords">
      <h1><span class="secnum">6.3.1.3</span>Agent Events Records<span class="utils"><span class="anchor"><a href="#MemoryModel.AgentEventsRecords">#</a></span></span></h1>
      <p>An  <dfn>Agent Events Record</dfn> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> with the following fields.</p>
      <emu-table id="table-agent-events-records" caption="Agent Events Record Fields"><figure><figcaption>Table 5: Agent Events Record Fields</figcaption>
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[AgentSignifier]]</td>
              <td>A value that admits equality testing</td>
              <td>The agent whose evaluation resulted in this ordering.</td>
            </tr>
            <tr>
              <td>[[EventList]]</td>
              <td>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> events</td>
              <td>Events are appended to the list during evaluation.</td>
            </tr>
          </tbody>
        </table>
      </figure></emu-table>
    </emu-clause>

    <emu-clause id="MemoryModel.ChosenValueRecords">
      <h1><span class="secnum">6.3.1.4</span>Chosen Value Records<span class="utils"><span class="anchor"><a href="#MemoryModel.ChosenValueRecords">#</a></span></span></h1>
      <p>A  <dfn>Chosen Value Record</dfn> is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> with the following fields.</p>
      <emu-table id="table-chosen-value-records" caption="Chosen Value Record Fields"><figure><figcaption>Table 6: Chosen Value Record Fields</figcaption>
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[Event]]</td>
              <td>A <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">Shared Data Block event</a></emu-xref></td>
              <td>The ReadSharedMemory or ReadModifyWriteSharedMemory event that was introduced for this chosen value.</td>
            </tr>
            <tr>
              <td>[[ChosenValue]]</td>
              <td>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values</td>
              <td>The bytes that were nondeterministically chosen during evaluation.</td>
            </tr>
          </tbody>
        </table>
      </figure></emu-table>
    </emu-clause>

    <emu-clause id="MemoryModel.CandidateExecutions">
      <h1><span class="secnum">6.3.1.5</span>Candidate Executions<span class="utils"><span class="anchor"><a href="#MemoryModel.CandidateExecutions">#</a></span></span></h1>
      <p>A  <dfn>candidate execution</dfn> of the evaluation of an agent cluster is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> with the following fields.</p>
      <emu-table id="table-candidate-execution-records" caption="Candidate Execution Record Fields"><figure><figcaption>Table 7: Candidate Execution <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> Fields</figcaption>
        <table>
          <tbody>
            <tr>
              <th>Field</th>
              <th>Value</th>
              <th>Meaning</th>
            </tr>
            <tr>
              <td>[[EventLists]]</td>
              <td>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of Agent Events Records.</td>
              <td>Maps an agent to Lists of events appended during the evaluation.</td>
            </tr>
            <tr>
              <td>[[ChosenValues]]</td>
              <td>A <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of Chosen Value Records.</td>
              <td>Maps ReadSharedMemory or ReadModifyWriteSharedMemory events to the <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values chosen during the evaluation.</td>
            </tr>
            <tr>
              <td>[[AgentOrder]]</td>
              <td>An <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref>.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[HostSynchronizesWith]]</td>
              <td>A <emu-xref aoid="host-synchronizes-with"><a href="#MemoryModel.HostSynchronizesWith">host-synchronizes-with</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref>.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[SynchronizesWith]]</td>
              <td>A <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref>.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[HappensBefore]]</td>
              <td>A <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref>.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[ReadsBytesFrom]]</td>
              <td>A <emu-xref aoid="reads-bytes-from"><a href="#MemoryModel.ReadBytesFrom">reads-bytes-from</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref>.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[ReadsFrom]]</td>
              <td>A <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref>.</td>
              <td>Defined below.</td>
            </tr>
            <tr>
              <td>[[DependsOn]]</td>
              <td>A <emu-xref aoid="depends-on"><a href="#MemoryModel.DependsOn">depends-on</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref>.</td>
              <td>Defined below.</td>
            </tr>
          </tbody>
        </table>
      </figure></emu-table>

     <p>An empty candidate execution is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">Record</a></emu-xref> where all its fields are empty Lists and empty Relations.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.EventSet" aoid="EventSet">
      <h1><span class="secnum">6.3.1.6</span>EventSet( <var>execution</var> )<span class="utils"><span class="anchor"><a href="#MemoryModel.EventSet">#</a></span></span></h1>
      <p>EventSet takes one argument, a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, and performs the following steps.</p>
      <emu-alg><ol><li>Let <var>events</var> be an empty Set.</li><li>For each element <var>eventList</var> in <var>execution</var>.[[EventLists]]:<ol><li>For each event <var>E</var> in <var>eventList</var>:<ol><li>Add <var>E</var> to <var>events</var>.</li></ol></li></ol></li><li>Return <var>events</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.AgentOrder" aoid="agent-order">
      <h1><span class="secnum">6.3.1.7</span>agent-order<span class="utils"><span class="anchor"><a href="#MemoryModel.AgentOrder">#</a></span></span></h1>
      <p>For a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, the least <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> on events that satisfies the following conditions.</p>
      <emu-alg><ol><li>Let <var>events</var> be <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>).</li><li>For each pair of events <var>E</var> and <var>D</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>):<ol><li>For each element <var>eventList</var> in <var>execution</var>.[[EventLists]]:<ol><li>If <var>E</var> and <var>D</var> are in <var>eventList</var> and <var>E</var> is before <var>D</var> in <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> order of <var>eventList</var> then <var>E</var> is <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> before <var>D</var>.
      </li></ol></li></ol></li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>Each agent introduces events in a <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">total order</a></emu-xref> during the evaluation. This is the union of those total orders.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.HostSynchronizesWith" aoid="host-synchronizes-with">
      <h1><span class="secnum">6.3.1.8</span>host-synchronizes-with<span class="utils"><span class="anchor"><a href="#MemoryModel.HostSynchronizesWith">#</a></span></span></h1>
      <p>For a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, a <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> on host-specific events in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>).</p>
      <emu-note><span class="note">Note</span>
        <p>The host-synchronizes-with relation allows the host to provide additional synchronization mechanisms, such as <code>postMessage</code> between HTML workers.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.SynchronizesWith" aoid="synchronizes-with">
      <h1><span class="secnum">6.3.1.9</span>synchronizes-with<span class="utils"><span class="anchor"><a href="#MemoryModel.SynchronizesWith">#</a></span></span></h1>
      <p>For a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, <var>execution</var>.[[SynchronizesWith]] is the least <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> that satisfies the following conditions.</p>

      <emu-alg><ol><li>Let <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> be <var>execution</var>.[[SynchronizesWith]].</li><li>Let <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> be <var>execution</var>.[[ReadsFrom]].</li><li>Let <emu-xref aoid="host-synchronizes-with"><a href="#MemoryModel.HostSynchronizesWith">host-synchronizes-with</a></emu-xref> be <var>execution</var>.[[HostSynchronizesWith]].</li><li>For each pair of events <var>R</var> and <var>W</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>) such that <var>R</var>.[[Order]] is <code>"SeqCst"</code> and <var>R</var> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <var>W</var>:<ol><li>Assert: <var>R</var> is a ReadSharedMemory or ReadModifyWriteSharedMemory event.</li><li>Assert: <var>W</var> is a WriteSharedMemory or ReadModifyWriteSharedMemory event.</li><li>If <var>W</var>.[[Order]] is <code>"SeqCst"</code> and <var>R</var> and <var>W</var> have equal ranges then <var>W</var> <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <var>R</var>.</li><li>Otherwise, if <var>W</var> has <var>order</var> <code>"Init"</code> then<ol><li>Let <var>allInitReads</var> be <emu-val>true</emu-val>.</li><li>For each event <var>V</var> such that <var>R</var> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <var>V</var>:<ol><li>If <var>V</var>.[[Order]] is not <code>"Init"</code> then set <var>allInitReads</var> to <emu-val>false</emu-val>.</li></ol></li><li>If <var>allInitReads</var> is <emu-val>true</emu-val> then <var>W</var> <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <var>R</var>.</li></ol></li></ol></li><li>For each pair of events <var>E</var> and <var>D</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>):<ol><li>If <var>E</var> <emu-xref aoid="host-synchronizes-with"><a href="#MemoryModel.HostSynchronizesWith">host-synchronizes-with</a></emu-xref> <var>D</var> then <var>E</var> <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <var>D</var>.
      </li></ol></li></ol></emu-alg>

      <emu-note><span class="note">Note 1</span>
        <p>Owing to convention, write events synchronizes-with read events, instead of read events synchronizes-with write events.</p>
      </emu-note>

      <emu-note><span class="note">Note 2</span>
        <p>Not all <code>"SeqCst"</code> events related by <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> are related by synchronizes-with. Only events that also have equal ranges are related by synchronizes-with.</p>
      </emu-note>

      <emu-note><span class="note">Note 3</span>
        <p>For an event <var>R</var> and a event <var>W</var> such <var>W</var> synchronizes-with <var>R</var>, <var>R</var> may <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> other writes than <var>W</var>.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.HappensBefore" aoid="happens-before">
      <h1><span class="secnum">6.3.1.10</span>happens-before<span class="utils"><span class="anchor"><a href="#MemoryModel.HappensBefore">#</a></span></span></h1>
      <p>For a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, <var>execution</var>.[[HappensBefore]] is the least <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">partial order</a></emu-xref> that satisfies the following conditions.</p>

      <emu-alg><ol><li>Let <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> be <var>execution</var>.[[HappensBefore]].</li><li>Let <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> be <var>execution</var>.[[AgentOrder]].</li><li>Let <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> be <var>execution</var>.[[SynchronizesWith]].</li><li>For each pair of events <var>E</var> and <var>D</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>):<ol><li>If <var>E</var> is <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> before <var>D</var> in <var>a</var> then <var>E</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>D</var>.</li><li>If <var>E</var> <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <var>D</var> then <var>E</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>D</var>.</li><li>If <var>E</var>.[[Order]] is <code>"Init"</code> and <var>E</var> and <var>D</var> have overlapping ranges then:<ol><li>Assert: <var>D</var>.[[Order]] is not <code>"Init"</code>.</li><li><var>E</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>D</var>.</li></ol></li><li>If there is an event <var>F</var> such that <var>E</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>F</var> and <var>F</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>D</var> then <var>E</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>D</var>.
      </li></ol></li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>Because happens-before is a superset of <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref>, candidate executions are consistent with the single-thread evaluation semantics of ECMA262.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.ReadBytesFrom" aoid="reads-bytes-from">
      <h1><span class="secnum">6.3.1.11</span>reads-bytes-from<span class="utils"><span class="anchor"><a href="#MemoryModel.ReadBytesFrom">#</a></span></span></h1>
      <p>For a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, <var>execution</var>.[[ReadsBytesFrom]] is a <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> that satisfies the following conditions.</p>

      <emu-alg><ol><li>Let <emu-xref aoid="reads-bytes-from"><a href="#MemoryModel.ReadBytesFrom">reads-bytes-from</a></emu-xref> be <var>execution</var>.[[ReadsBytesFrom]].</li><li>Let <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> be <var>execution</var>.[[HappensBefore]].</li><li>For each ReadSharedMemory or ReadModifyWriteSharedMemory event <var>R</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>):<ol><li>There is a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of length equal to <var>R</var>.[[ElementSize]] of WriteSharedMemory or ReadModifyWriteSharedMemory events <var>Ws</var> such that <var>R</var> <emu-xref aoid="reads-bytes-from"><a href="#MemoryModel.ReadBytesFrom">reads-bytes-from</a></emu-xref> <var>Ws</var>.</li><li>Let <var>byteLocation</var> be <var>R</var>.[[ByteIndex]].</li><li>For each element <var>W</var> of <var>Ws</var> in <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> order:<ol><li><var>W</var> has <var>byteLocation</var> in its <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">range</a></emu-xref>, and</li><li>It is not the case that <var>R</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>W</var>, and</li><li>There is no WriteSharedMemory or ReadModifyWriteSharedMemory event <var>V</var> that has <var>byteLocation</var> in its <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">range</a></emu-xref> such that <var>W</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>V</var> and <var>V</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>R</var>.</li><li>Increment <var>byteLocation</var> by 1.
      </li></ol></li></ol></li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.ReadsFrom" aoid="reads-from">
      <h1><span class="secnum">6.3.1.12</span>reads-from<span class="utils"><span class="anchor"><a href="#MemoryModel.ReadsFrom">#</a></span></span></h1>
      <p>For a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, <var>execution</var>.[[ReadsFrom]] is the least <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> that satisfies the following conditions.</p>

      <emu-alg><ol><li>Let <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> be <var>execution</var>.[[ReadsFrom]].</li><li>Let <emu-xref aoid="reads-bytes-from"><a href="#MemoryModel.ReadBytesFrom">reads-bytes-from</a></emu-xref> be <var>execution</var>.[[ReadsBytesFrom]].</li><li>For each pair of events <var>R</var> and <var>W</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>):<ol><li>If <var>R</var> <emu-xref aoid="reads-bytes-from"><a href="#MemoryModel.ReadBytesFrom">reads-bytes-from</a></emu-xref> a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of WriteSharedMemory events <var>Ws</var> that contains <var>W</var> then <var>R</var> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <var>W</var>.
      </li></ol></li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>This is a function from events to Lists of events.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.DependsOn" aoid="depends-on">
      <h1><span class="secnum">6.3.1.13</span>depends-on<span class="utils"><span class="anchor"><a href="#MemoryModel.DependsOn">#</a></span></span></h1>
      <p>For a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, a host-provided <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> on events in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>) that captures semantic data and control dependencies between events.</p>

      <emu-note><span class="note">Note</span>
        <p>The dependence relation may differ between implementations of ECMAScript. For instance, one implementation may provide a syntactic dependence relation that overapproximates semantic dependences.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.ComposeWriteEventBytes" aoid="ComposeWriteEventBytes">
      <h1><span class="secnum">6.3.1.14</span>ComposeWriteEventBytes( <var>execution</var>, <var>block</var>, <var>byteIndex</var>, <var>Ws</var> )<span class="utils"><span class="anchor"><a href="#MemoryModel.ComposeWriteEventBytes">#</a></span></span></h1>
      <p>The abstraction operation ComposeWriteEventBytes takes four arguments, a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var>, a nonnegative integer <var>byteIndex</var>, and a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> <var>Ws</var>, and performs the following steps.</p>

      <emu-alg><ol><li>Let <var>byteLocation</var> be <var>byteIndex</var>.</li><li>Let <var>bytesRead</var> be an empty <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref>.</li><li>For each element <var>W</var> of <var>Ws</var> in <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> order:<ol><li>Assert: <var>W</var> has <var>byteLocation</var> in its <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">range</a></emu-xref>.</li><li>If <var>W</var> is a WriteSharedMemory event then<ol><li>Let <var>byte</var> be <var>W</var>.[[Payload]][<var>byteLocation</var>].</li></ol></li><li>Else,<ol><li>Assert: <var>W</var> is a ReadModifyWriteSharedMemory event.</li><li>Let <var>bytesRead</var> be <emu-xref aoid="ValueOfReadEvent"><a href="#MemoryModel.ValueOfReadEvent">ValueOfReadEvent</a></emu-xref>(<var>execution</var>, <var>W</var>).</li><li>Let <var>bytesModified</var> be <var>W</var>.[[ModifyOp]](<var>bytesRead</var>, <var>W</var>.[[Payload]]).</li><li>Let <var>byte</var> be <var>bytesModified</var>[<var>byteLocation</var>].</li></ol></li><li>Append <var>byte</var> to <var>bytesRead</var>.</li><li>Increment <var>byteLocation</var> by 1.</li></ol></li><li>Return <var>bytesRead</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note 1</span>
        <p>The semantic function [[ModifyOp]] is given by the function properties on the Atomics object that introduce ReadModifyWriteSharedMemory events.</p>
      </emu-note>

      <emu-note><span class="note">Note 2</span>
        <p>This subroutine composes a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of write events into a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values. It is used in the event semantics of ReadSharedMemory and ReadModifyWriteSharedMemory events.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.ValueOfReadEvent" aoid="ValueOfReadEvent">
      <h1><span class="secnum">6.3.1.15</span>ValueOfReadEvent( <var>execution</var>, <var>R</var> )<span class="utils"><span class="anchor"><a href="#MemoryModel.ValueOfReadEvent">#</a></span></span></h1>
      <p>The abstract operation ValueOfReadEvent takes two arguments, a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var> and a <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">Shared Data Block event</a></emu-xref> <var>R</var>, and performs the following steps</p>

      <emu-alg><ol><li>Assert: <var>R</var> is a ReadSharedMemory or ReadModifyWriteSharedMemory event.</li><li>Let <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> be <var>execution</var>.[[ReadsFrom]].</li><li>Let <var>Ws</var> be the <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of events such that <var>R</var> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <var>Ws</var>.</li><li>Assert: <var>Ws</var> has length equal to <var>R</var>.[[ElementSize]].</li><li>Return <emu-xref aoid="ComposeWriteEventBytes"><a href="#MemoryModel.ComposeWriteEventBytes">ComposeWriteEventBytes</a></emu-xref>(<var>execution</var>, <var>R</var>.[[Block]], <var>R</var>.[[ByteIndex]], <var>Ws</var>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.ValidChosenReads">
      <h1><span class="secnum">6.3.1.16</span>Valid Chosen Reads<span class="utils"><span class="anchor"><a href="#MemoryModel.ValidChosenReads">#</a></span></span></h1>
      <p>A <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var> has valid chosen reads if the following conditions hold.</p>

      <emu-alg><ol><li>For each ReadSharedMemory and ReadModifyWriteSharedMemory event <var>R</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>):<ol><li>Let <var>chosenValue</var> be the element of <var>execution</var>.[[ChosenValues]] whose [[Event]] field is <var>R</var>.</li><li><var>chosenValue</var> is equal to <emu-xref aoid="ValueOfReadEvent"><a href="#MemoryModel.ValueOfReadEvent">ValueOfReadEvent</a></emu-xref>(<var>execution</var>, <var>R</var>).
      </li></ol></li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.NoOutOfThinAirReads">
      <h1><span class="secnum">6.3.1.17</span>No Out of Thin Air Reads<span class="utils"><span class="anchor"><a href="#MemoryModel.NoOutOfThinAirReads">#</a></span></span></h1>
      <p>A <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> has no out of thin air reads if there is no cycle in the union of the relations <var>execution</var>.[[ReadsFrom]] and <var>execution</var>.[[DependsOn]].</p>

      <emu-note><span class="note">Note 1</span>
        <p>Out of thin air reads is an artifact of memory models rather than implementation reality. For other languages with similar memory models, thin air reads have not been observed on any known hardware nor due to any known compiler transform.</p>
      </emu-note>

      <emu-note><span class="note">Note 2</span>
        <p>(Spec draft notes)</p>
        <p>This is intentionally underspecified. Precisely capturing and forbidding OOTA is currently an open problem.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.TearFreeAlignedReads">
      <h1><span class="secnum">6.3.1.18</span>Tear Free Reads<span class="utils"><span class="anchor"><a href="#MemoryModel.TearFreeAlignedReads">#</a></span></span></h1>
      <p>A <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var> has tear free reads if the following conditions hold.</p>
      <emu-alg><ol><li>Let <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> be <var>execution</var>.[[ReadsFrom]].</li><li>For each ReadSharedMemory or ReadModifyWriteSharedMemory event <var>R</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>):<ol><li>If <var>R</var>.[[NoTear]] is <emu-val>true</emu-val> then<ol><li>Assert that the remainder of <var>R</var>.[[ByteIndex]] ÷ <var>R</var>.[[ElementSize]] is <emu-val>0</emu-val>.</li><li>For each event <var>W</var> such that <var>R</var> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <var>W</var> and <var>W</var>.[[NoTear]] is <emu-val>true</emu-val>:<ol><li>If <var>R</var> and <var>W</var> have equal ranges then there is no <var>V</var> such that <var>V</var> and <var>W</var> have equal <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">range</a></emu-xref>, <var>V</var>.[[NoTear]] is <emu-val>true</emu-val>, <var>W</var> is not <var>V</var>, and <var>R</var> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <var>V</var>.
      </li></ol></li></ol></li></ol></li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>An event's [[NoTear]] field is <emu-val>true</emu-val> when that event was introduced via accessing a TypedArray, and <emu-val>false</emu-val> when introduced via accessing a DataView.</p>
        <p>Intuitively, this requirement says when a memory <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">range</a></emu-xref> is accessed in an aligned fashion via a TypedArray, a single write event on that <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">range</a></emu-xref> must "win" when in a <emu-xref aoid="data race"><a href="#MemoryModel.DataRaces">data race</a></emu-xref> with other write events with equal ranges. More precisely, this requirement says an aligned read event cannot read a value composed of bytes from multiple, different write events all with equal ranges. It is possible, however, for an aligned read event to read from multiple write events with overlapping ranges. See Access Atomicity below.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.MemoryOrder" aoid="memory-order">
      <h1><span class="secnum">6.3.1.19</span>memory-order<span class="utils"><span class="anchor"><a href="#MemoryModel.MemoryOrder">#</a></span></span></h1>
      <p>For a <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var>, memory-order is a <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">total order</a></emu-xref> that satisfies the following conditions.</p>

      <emu-alg><ol><li>Let <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> be <var>execution</var>.[[HappensBefore]].</li><li>Let <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> be <var>execution</var>.[[SynchronizesWith]].</li><li>For each pair of events <var>E</var> and <var>D</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>):<ol><li>If <var>E</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>D</var> then <var>E</var> is <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> before <var>D</var>.</li><li>If <var>E</var> <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <var>D</var> then<ol><li>Assert: <var>D</var> has <var>order</var> <code>"SeqCst"</code>.</li><li>There is no WriteSharedMemory or ReadModifyWriteSharedMemory event <var>W</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>) with equal <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">range</a></emu-xref> as <var>D</var> such that <var>E</var> is <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> before <var>W</var> and <var>W</var> is <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> before <var>D</var>.</li><li>NOTE: This clause constrains <code>"SeqCst"</code> events on equal ranges, not all <code>"SeqCst"</code> events.
      </li></ol></li></ol></li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.SequentiallyConsistentAtomics">
      <h1><span class="secnum">6.3.1.20</span>Sequentially Consistent Atomics<span class="utils"><span class="anchor"><a href="#MemoryModel.SequentiallyConsistentAtomics">#</a></span></span></h1>
      <p>A <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> has sequentially consistent atomics if it admits a <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref>.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.ValidExecutions">
      <h1><span class="secnum">6.3.1.21</span>Valid Executions<span class="utils"><span class="anchor"><a href="#MemoryModel.ValidExecutions">#</a></span></span></h1>
      <p>A <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> <var>execution</var> is a valid execution (or simply an execution) if the following conditions hold.</p>

      <emu-alg><ol><li>The host provides a <emu-xref aoid="host-synchronizes-with"><a href="#MemoryModel.HostSynchronizesWith">host-synchronizes-with</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> for <var>execution</var>.[[HostSynchronizesWith]], and</li><li>The host provides a <emu-xref aoid="depends-on"><a href="#MemoryModel.DependsOn">depends-on</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> for <var>execution</var>.[[DependsOn]], and</li><li><var>execution</var> admits an <emu-xref aoid="agent-order"><a href="#MemoryModel.AgentOrder">agent-order</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> <var>execution</var>.[[AgentOrder]], and</li><li><var>execution</var> admits a <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> <var>execution</var>.[[SynchronizesWith]], and</li><li><var>execution</var> admits a <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> <var>execution</var>.[[HappensBefore]], and</li><li><var>execution</var> admits a <emu-xref aoid="reads-bytes-from"><a href="#MemoryModel.ReadBytesFrom">reads-bytes-from</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> <var>execution</var>.[[ReadsBytesFrom]], and</li><li><var>execution</var> admits a <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <emu-xref href="#MemoryModel.Relations"><a href="#MemoryModel.Relations">Relation</a></emu-xref> <var>execution</var>.[[ReadsFrom]], and</li><li><var>execution</var> has valid chosen reads, and</li><li><var>execution</var> has no out of thin air reads, and</li><li><var>execution</var> has tear free reads, and</li><li><var>execution</var> has sequentially consistent atomics.
      </li></ol></emu-alg>

      <p>All programs have at least one valid execution.</p>

      <emu-note><span class="note">Note</span>
        <p>The <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> where all events are interleaved and a read event always reads from the set of most recent write events is always admitted as a valid execution. That is, the execution where all events are treated as if they were <code>"SeqCst"</code> is always admitted.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="MemoryModel.Races" aoid="race">
      <h1><span class="secnum">6.3.1.22</span>Races<span class="utils"><span class="anchor"><a href="#MemoryModel.Races">#</a></span></span></h1>
      <p>For an execution <var>execution</var>, two events <var>E</var> and <var>D</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>) are in a race if the following conditions hold.</p>

      <emu-alg><ol><li>Let <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> be <var>execution</var>.[[HappensBefore]].</li><li>Let <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> be <var>execution</var>.[[ReadsFrom]].</li><li>It is not the case that <var>E</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>D</var> or <var>D</var> <emu-xref aoid="happens-before"><a href="#MemoryModel.HappensBefore">happens-before</a></emu-xref> <var>E</var>, and</li><li>If <var>E</var> and <var>D</var> are both WriteSharedMemory or ReadModifyWriteSharedMemory events then<ol><li><var>E</var> and <var>D</var> do not have disjoint ranges.</li></ol></li><li>Otherwise:<ol><li><var>E</var> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <var>D</var> or <var>D</var> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <var>E</var>.
      </li></ol></li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.DataRaces" aoid="data race">
      <h1><span class="secnum">6.3.1.23</span>Data Races<span class="utils"><span class="anchor"><a href="#MemoryModel.DataRaces">#</a></span></span></h1>
      <p>For an execution <var>execution</var>, two events <var>E</var> and <var>D</var> in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>) are in a data race if the following conditions hold.</p>

      <emu-alg><ol><li><var>E</var> and <var>D</var> are in a <emu-xref aoid="race"><a href="#MemoryModel.Races">race</a></emu-xref> in <var>execution</var>, and</li><li>At least one of <var>E</var> or <var>D</var> does not have [[Order]] <code>"SeqCst"</code> or <var>E</var> and <var>D</var> have overlapping ranges.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="MemoryModel.DRF" aoid="data race free">
      <h1><span class="secnum">6.3.1.24</span>Data Race Freedom<span class="utils"><span class="anchor"><a href="#MemoryModel.DRF">#</a></span></span></h1>
      <p>An execution <var>execution</var> is data race free if there are no two events in <emu-xref aoid="EventSet"><a href="#MemoryModel.EventSet">EventSet</a></emu-xref>(<var>execution</var>) that are in a <emu-xref aoid="data race"><a href="#MemoryModel.DataRaces">data race</a></emu-xref>.</p>
      <p>A program is data race free if all its executions are data race free.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.AccessAtomicity">
      <h1><span class="secnum">6.3.1.25</span>Access Atomicity (informative)<span class="utils"><span class="anchor"><a href="#MemoryModel.AccessAtomicity">#</a></span></span></h1>

      <p>In an execution, a ReadSharedMemory or ReadModifyWriteSharedMemory event is access atomic when it <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> a single WriteSharedMemory event or ReadModifyWriteSharedMemory event. In the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref>, write events have no force beyond being read from by read events and thus have no notion of being access atomic. This differs from the colloquial notion of access atomicity, which usually means if a write or read was performed by hardware atomically.</p>

      <p>The Tear Free Reads requirement does not guarantee access atomicity for non-atomic events. Consider the following program where <code>U8</code> and <code>U16</code> are aliased 1-byte and 2-byte views on the same <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> and <code>a</code> and <code>b</code> represent the same memory address (scaled appropriately for the data type).</p>

      <pre>   W1: U16[a] = 1; W2: U8[b] = 2;
|| W3: U16[a] = 3;
||  R: observe(U16[a]);</pre>

      <p>A <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> where all the following hold is a valid execution.</p>

      <ul>
        <li><code>R</code> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <code>W1</code></li>
        <li><code>R</code> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <code>W2</code></li>
      </ul>

      <p><code>R</code> reads a value composed of bytes from <code>W1</code> and <code>W2</code>, and is thus not access atomic. At the same time, it does not read-from both <code>W2</code> and <code>W3</code>, and thus is tear free.</p>

      <p>Similarly, neither the <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> relation, the Sequentially Consistent Atomics requirement guarantees access atomicity for atomic events. Both are concerned with ordering of atomic operations on equal ranges, but it is possible to have sequentially consistent equal-ranged atomics without access atomicity. For example, consider the following program where <code>U8</code> and <code>U16</code> are aliased 1-byte and 2-byte views on the same <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>.</p>

      <pre>   W1: Atomics.store(U16, a, 1); W2: Atomics.store(U8, b, 2);
|| W3: Atomics.store(U16, a, 3);
||  R: observe(Atomics.load(U16, a));</pre>

      <p>A <emu-xref href="#MemoryModel.CandidateExecutions"><a href="#MemoryModel.CandidateExecutions">candidate execution</a></emu-xref> where all of the following hold is a valid execution.</p>

      <ul>
        <li><code>R</code> <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <code>W1</code></li>
        <li><code>R</code> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <code>W1</code></li>
        <li><code>R</code> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <code>W2</code></li>
        <li><code>W1</code> is <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> before <code>W2</code> and <code>W2</code> is <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> before <code>R</code> and <code>R</code> is <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> before <code>W3</code></li>
      </ul>

      <p><code>W2</code> is allowed to come between <code>W1</code> and <code>R</code> in <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> because it and <code>R</code> do not have equal ranges. Thus, <code>R</code> may read a value composed of bytes written by both <code>W1</code> and <code>W2</code>.</p>

      <p>Finally, <emu-xref aoid="data race"><a href="#MemoryModel.DataRaces">data race</a></emu-xref> freedom and sequential consistency do not imply access atomicity. Consider the following program with a single agent.</p>

      <pre>W1: Atomics.store(U16, a, 1); W2: Atomics.store(U8, b, 2); R: observe(Atomics.load(U16, a));</pre>

      <p>The only valid execution is as follows.</p>

      <ul>
        <li><code>R</code> <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> <code>W1</code></li>
        <li><code>R</code> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <code>W1</code></li>
        <li><code>R</code> <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> <code>W2</code></li>
        <li><code>W1</code> is <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> before <code>W2</code> and <code>W2</code> is <emu-xref aoid="memory-order"><a href="#MemoryModel.MemoryOrder">memory-order</a></emu-xref> before <code>R</code></li>
      </ul>

      <p>All valid executions of the program are <emu-xref aoid="data race free"><a href="#MemoryModel.DRF">data race free</a></emu-xref>, since there is a single thread. But <code>R</code> is not access atomic since it <emu-xref aoid="reads-from"><a href="#MemoryModel.ReadsFrom">reads-from</a></emu-xref> multiple events.</p>

      <p>The central problem the <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> solves is the ordering of memory events. The SharedArrayBuffer API's lack of type discipline and allowance of overlapping accesses makes access atomicity an orthogonal property from event ordering.</p>
      <p>A program wishing to avoid reasoning about access atomicity or wishing to guarantee all its aligned and atomic accesses are access atomic should avoid accesses on overlapping ranges. When a program does not use address ranges in an overlapping fashion, aligned and atomic accesses are access atomic.</p>
    </emu-clause>

    <emu-clause id="MemoryModel.SeqCst">
      <h1><span class="secnum">6.3.1.26</span>Sequential Consistency (informative)<span class="utils"><span class="anchor"><a href="#MemoryModel.SeqCst">#</a></span></span></h1>
      <p>The <emu-xref href="#AtomicsObject"><a href="#AtomicsObject">memory model</a></emu-xref> guarantees sequential consistency of all events for <emu-xref aoid="data race free"><a href="#MemoryModel.DRF">data race free</a></emu-xref> programs.</p>
      <emu-note><span class="note">Note</span>
        <p>A formal proof of the property requires the host to provide a <emu-xref aoid="depends-on"><a href="#MemoryModel.DependsOn">depends-on</a></emu-xref> relation that prohibits out of thin air reads.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>

  <emu-clause id="AtomicsMethods">
    <h1><span class="secnum">6.3.2</span>Methods<span class="utils"><span class="anchor"><a href="#AtomicsMethods">#</a></span></span></h1>

    <emu-clause id="Atomics.ValidateSharedIntegerTypedArray" aoid="ValidateSharedIntegerTypedArray">
      <h1><span class="secnum">6.3.2.1</span>ValidateSharedIntegerTypedArray(<var>typedArray</var> [, <var>onlyInt32</var>] )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateSharedIntegerTypedArray">#</a></span></span></h1>
      <emu-alg><ol><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>typedArray</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>typedArray</var> does not have a [[TypedArrayName]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>typeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>If <var>onlyInt32</var> is <emu-val>true</emu-val> then<ol><li>If <var>typeName</var> is not <code>"Int32Array"</code> then throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>Else,<ol><li>If <var>typeName</var> is not <code>"Int8Array"</code>, <code>"Uint8Array"</code>, <code>"Int16Array"</code>, <code>"Uint16Array"</code>, <code>"Int32Array"</code>, or <code>"Uint32Array"</code> then throw a <emu-val>TypeError</emu-val> exception.</li></ol></li><li>If <var>typedArray</var> does not have a [[ViewedArrayBuffer]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>buffer</var> be <var>typedArray</var>.[[ViewedArrayBuffer]].</li><li>If <emu-xref aoid="Type"><a href="https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values">Type</a></emu-xref>(<var>buffer</var>) is not Object, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <var>buffer</var> does not have an [[ArrayBufferData]] internal slot, throw a <emu-val>TypeError</emu-val> exception.</li><li>If <emu-xref aoid="IsSharedArrayBuffer"><a href="#StructuredData.SharedArrayBuffer.abstract.IsSharedArrayBuffer">IsSharedArrayBuffer</a></emu-xref>(<var>buffer</var>) is <emu-val>false</emu-val>, throw a <emu-val>TypeError</emu-val> exception.</li><li>Return <var>buffer</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.ValidateAtomicAccess" aoid="ValidateAtomicAccess">
      <h1><span class="secnum">6.3.2.2</span>ValidateAtomicAccess( <var>typedArray</var>, <var>requestIndex</var> )<span class="utils"><span class="anchor"><a href="#Atomics.ValidateAtomicAccess">#</a></span></span></h1>
      <p>Perform the following steps:</p>
      <emu-alg><ol><li>Assert: <var>typedArray</var> is an Object that has a [[ViewedArrayBuffer]] internal slot.</li><li>Let <var>numberIndex</var> be ? <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>requestIndex</var>).</li><li>Let <var>accessIndex</var> be <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>numberIndex</var>).</li><li>If <var>numberIndex</var> ≠ <var>accessIndex</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Let <var>length</var> be <var>typedArray</var>.[[ArrayLength]].</li><li>If <var>accessIndex</var> &lt; 0 or <var>accessIndex</var> ≥ <var>length</var>, throw a <emu-val>RangeError</emu-val> exception.</li><li>Return <var>accessIndex</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AgentSignifier" aoid="AgentSignifier">
      <h1><span class="secnum">6.3.2.3</span>AgentSignifier( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentSignifier">#</a></span></span></h1>
      <p>When AgentSignifier is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>AR</var> be the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>Let <var>W</var> be <var>AR</var>.[[Signifier]].</li><li>Return <var>W</var>.
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.AgentCanSuspend" aoid="AgentCanSuspend">
      <h1><span class="secnum">6.3.2.4</span>AgentCanSuspend( )<span class="utils"><span class="anchor"><a href="#Atomics.AgentCanSuspend">#</a></span></span></h1>
      <p>When AgentCanSuspend is called without arguments then the following steps are taken.</p>
      <emu-alg><ol><li>Let <var>AR</var> be the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>Let <var>B</var> be <var>AR</var>.[[CanBlock]].</li><li>Return <var>B</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>In some environments it may not be reasonable for a given agent to suspend.  For example,
          in a web browser environment, it may be reasonable to disallow suspending a document's main event
          handling thread, while still allowing workers' event handling threads to suspend.</p>
      </emu-note>

    </emu-clause>

    <emu-clause id="GetWaiterList" aoid="GetWaiterList">
      <h1><span class="secnum">6.3.2.5</span>GetWaiterList( <var>block</var>, <var>i</var> )<span class="utils"><span class="anchor"><a href="#GetWaiterList">#</a></span></span></h1>
      <p>A  <dfn>WaiterList</dfn> is a semantic object that contains an ordered list of those agents that are waiting on a location (<var>block</var>, <var>i</var>) in shared memory; <var>block</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> and <var>i</var> a byte offset into the memory of <var>block</var>.</p>
      <p>The agent cluster has a store of WaiterList objects; the store is indexed by (<var>block</var>, <var>i</var>).  WaiterLists are agent-independent: a lookup in the store of WaiterLists by (<var>block</var>, <var>i</var>) will result in the same WaiterList object in any agent in the agent cluster.</p>
      <p>Operations on a WaiterList -- adding and removing waiting agents, traversing the list of agents, suspending and waking agents on the list -- may only be performed by agents that have entered the WaiterList's critical section.</p>
      <p>When GetWaiterList is called with <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> <var>block</var> and nonnegative integer <var>i</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: <var>block</var> is a <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref>.</li><li>Assert: <var>i</var> and <var>i</var>+3 are valid byte offsets within the memory of <var>block</var>.</li><li>Assert: <var>i</var> is divisible by 4.</li><li>Return the <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> that is referenced by the pair (<var>block</var>, <var>i</var>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="EnterCriticalSection" aoid="EnterCriticalSection">
      <h1><span class="secnum">6.3.2.6</span>EnterCriticalSection( <var>WL</var> )<span class="utils"><span class="anchor"><a href="#EnterCriticalSection">#</a></span></span></h1>
      <p>When EnterCriticalSection is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is not in the critical section for any <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref>.</li><li>Wait until no agent is in the critical section for <var>WL</var>, then enter the critical section for <var>WL</var> (without allowing any other agent to enter).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="LeaveCriticalSection" aoid="LeaveCriticalSection">
      <h1><span class="secnum">6.3.2.7</span>LeaveCriticalSection( <var>WL</var> )<span class="utils"><span class="anchor"><a href="#LeaveCriticalSection">#</a></span></span></h1>
      <p>When LeaveCriticalSection is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Leave the critical section for <var>WL</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.AddWaiter" aoid="AddWaiter">
      <h1><span class="secnum">6.3.2.8</span>AddWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.AddWaiter">#</a></span></span></h1>
      <p>When AddWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is not on the list of waiters in any <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref>.</li><li>Add <var>W</var> to the end of the list of waiters in <var>WL</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiter" aoid="RemoveWaiter">
      <h1><span class="secnum">6.3.2.9</span>RemoveWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiter">#</a></span></span></h1>
      <p>When RemoveWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Remove <var>W</var> from the list of waiters in <var>WL</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.RemoveWaiters" aoid="RemoveWaiters">
      <h1><span class="secnum">6.3.2.10</span>RemoveWaiters( <var>WL</var>, <var>c</var> )<span class="utils"><span class="anchor"><a href="#Atomics.RemoveWaiters">#</a></span></span></h1>
      <p>When RemoveWaiters is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and nonnegative integer <var>c</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Let <var>L</var> be the empty list.</li><li>Let <var>S</var> be a reference to the list of waiters in <var>WL</var>.</li><li>While <var>c</var> &gt; 0 and <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first waiter in <var>S</var>.</li><li>Add <var>W</var> to the end of <var>L</var>.</li><li>Remove <var>W</var> from <var>S</var>.</li><li>Subtract 1 from <var>c</var>.</li></ol></li><li>Return <var>L</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.Suspend" aoid="Suspend">
      <h1><span class="secnum">6.3.2.11</span>Suspend( <var>WL</var>, <var>W</var>, <var>timeout</var> )<span class="utils"><span class="anchor"><a href="#Atomics.Suspend">#</a></span></span></h1>
      <p>When Suspend is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var>, agent signifier <var>W</var>, and nonnegative, non-<emu-val>NaN</emu-val> Number <var>timeout</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is equal to <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Assert: <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>() is equal to true.</li><li>Perform <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>) and suspend <var>W</var> for up to <var>timeout</var> milliseconds, performing the combined operation in such a way that a wakeup that arrives after the critical section is exited but before the suspension takes effect is not lost.  <var>W</var> can wake up either because the timeout expired or because it was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), and not for any other reasons at all.</li><li>Perform <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If <var>W</var> was woken explicitly by another agent calling <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>), then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.WakeWaiter" aoid="WakeWaiter">
      <h1><span class="secnum">6.3.2.12</span>WakeWaiter( <var>WL</var>, <var>W</var> )<span class="utils"><span class="anchor"><a href="#Atomics.WakeWaiter">#</a></span></span></h1>
      <p>When WakeWaiter is called with <emu-xref href="#GetWaiterList"><a href="#GetWaiterList">WaiterList</a></emu-xref> <var>WL</var> and agent signifier <var>W</var>, then the following steps are taken.</p>
      <emu-alg><ol><li>Assert: The calling agent is in the critical section for <var>WL</var>.</li><li>Assert: <var>W</var> is on the list of waiters in <var>WL</var>.</li><li>Wake the agent <var>W</var>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>The embedding may delay waking <var>W</var>, eg for resource management reasons, but <var>W</var> must eventually be woken in order to guarantee forward progress.</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="Atomics.ReadModifyWrite" aoid="AtomicReadModifyWrite">
      <h1><span class="secnum">6.3.2.13</span>AtomicReadModifyWrite( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>op</var> )<span class="utils"><span class="anchor"><a href="#Atomics.ReadModifyWrite">#</a></span></span></h1>
      <p>AtomicReadModifyWrite is a semantic function that atomically loads a value, combines it with another value, and stores the result of the combination.  It returns the loaded value.  It is parameterized by the (pure) combining operation <var>op</var> that takes two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments and returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values.  The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>value</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var>.</li><li>Return <emu-xref aoid="GetModifySetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetModifySetValueInBuffer">GetModifySetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>value</var>, <var>op</var>).
      </li></ol></emu-alg>
    </emu-clause>
  </emu-clause> <!-- runtime semantics -->

  <emu-clause id="AtomicsObjectFunctionProps">
    <h1><span class="secnum">6.3.3</span>Function Properties of the Atomics Object<span class="utils"><span class="anchor"><a href="#AtomicsObjectFunctionProps">#</a></span></span></h1>

    <emu-clause id="Atomics.add">
      <h1><span class="secnum">6.3.3.1</span>Atomics.add( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.add">#</a></span></span></h1>
      <p>Let <code>add</code> denote a semantic function of two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments that applies the addition operation to the Number values corresponding to the <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments and returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.ReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>add</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.and">
      <h1><span class="secnum">6.3.3.2</span>Atomics.and( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.and">#</a></span></span></h1>
      <p>Let <code>and</code> denote a semantic function of two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments that applies the bitwise-and operation element-wise to the two arguments and returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.ReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>and</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.compareExchange">
      <h1><span class="secnum">6.3.3.3</span>Atomics.compareExchange( <var>typedArray</var>, <var>index</var>, <var>expectedValue</var>, <var>replacementValue</var> )<span class="utils"><span class="anchor"><a href="#Atomics.compareExchange">#</a></span></span></h1>
      <p>Let <code>compareExchange</code> denote a semantic function of two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments that returns the second argument if the first argument is element-wise equal to the <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values corresponding to <var>expectedValue</var>.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.ReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>replacementValue</var>, <code>compareExchange</code>);
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.exchange">
      <h1><span class="secnum">6.3.3.4</span>Atomics.exchange( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.exchange">#</a></span></span></h1>
      <p>Let <code>second</code> denote a semantic function of two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments that returns its second argument.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.ReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>second</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.isLockFree">
      <h1><span class="secnum">6.3.3.5</span>Atomics.isLockFree( <var>size</var> )<span class="utils"><span class="anchor"><a href="#Atomics.isLockFree">#</a></span></span></h1>

      <emu-alg><ol><li>Let <var>n</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>size</var>).</li><li>Let <var>AR</var> be the <emu-xref href="#ExecutableCodeAndContexts.AgentCluster"><a href="#ExecutableCodeAndContexts.AgentCluster">Agent Record</a></emu-xref> of the <em>surrounding agent</em>.</li><li>If <var>n</var> equals 1 then return <var>AR</var>.[[IsLockFree1]].</li><li>If <var>n</var> equals 2 then return <var>AR</var>.[[IsLockFree2]].</li><li>If <var>n</var> equals 4 then return <emu-val>true</emu-val>.</li><li>Return <emu-val>false</emu-val>.
      </li></ol></emu-alg>

      <emu-note><span class="note">Note</span>
        <p>Atomics.isLockFree() is an optimization primitive.  The
          intuition is that if the atomic step of an atomic primitive
          (<code>compareExchange</code>, <code>load</code>, <code>store</code>, <code>add</code>, <code>sub</code>, <code>and</code>,
          <code>or</code>, <code>xor</code>, or <code>exchange</code>) on a datum of size <var>n</var> bytes
          will be performed without the calling agent acquiring a lock
          outside the <var>n</var> bytes comprising the datum, then
          Atomics.isLockFree(<var>n</var>) will return <emu-val>true</emu-val>.
          High-performance algorithms will use Atomics.isLockFree to
          determine whether to use locks or atomic operations in
          critical sections.  If an atomic primitive is not lock-free
          then it is often more efficient for an algorithm to provide
          its own locking.</p>

        <p>Atomics.isLockFree(4) always returns <emu-val>true</emu-val> as that can be
          supported on all known relevant hardware.  Being able to
          assume this will generally simplify programs.</p>

      </emu-note>

    </emu-clause>

    <emu-clause id="Atomics.load">
      <h1><span class="secnum">6.3.3.6</span>Atomics.load( <var>typedArray</var>, <var>index</var> )<span class="utils"><span class="anchor"><a href="#Atomics.load">#</a></span></span></h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in <emu-xref href="#table-49"><a href="https://tc39.github.io/ecma262/#table-49">Table 50</a></emu-xref> for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var>.</li><li>Return <emu-xref aoid="GetValueFromBuffer"><a href="#StructuredData.ArrayBuffer.abstract.GetValueFromBuffer">GetValueFromBuffer</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <emu-val>true</emu-val>, <code>"SeqCst"</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.or">
      <h1><span class="secnum">6.3.3.7</span>Atomics.or( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.or">#</a></span></span></h1>
      <p>Let <code>or</code> denote a semantic function of two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments that applies the bitwise-or operation element-wise to the two arguments and returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.ReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>or</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.store">
      <h1><span class="secnum">6.3.3.8</span>Atomics.store( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.store">#</a></span></span></h1>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>value</var>).</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>elementSize</var> be the Number value of the Element Size value specified in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>elementType</var> be the String value of the Element Type value in Table 49 for <var>arrayTypeName</var>.</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × <var>elementSize</var>) + <var>offset</var>.</li><li>Perform <emu-xref aoid="SetValueInBuffer"><a href="#StructuredData.ArrayBuffer.abstract.SetValueInBuffer">SetValueInBuffer</a></emu-xref>(<var>buffer</var>, <var>indexedPosition</var>, <var>elementType</var>, <var>v</var>, <emu-val>true</emu-val>, <code>"SeqCst"</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.sub">
      <h1><span class="secnum">6.3.3.9</span>Atomics.sub( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.sub">#</a></span></span></h1>
      <p>Let <code>subtract</code> denote a semantic function of two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments that applies the subtraction operation to the Number values corresponding to the <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments and returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.ReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>subtract</code>).
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.wait">
      <h1><span class="secnum">6.3.3.10</span>Atomics.wait( <var>typedArray</var>, <var>index</var>, <var>value</var>, <var>timeout</var> )<span class="utils"><span class="anchor"><a href="#Atomics.wait">#</a></span></span></h1>
      <p>Atomics.wait puts the calling agent in a wait queue and puts it to sleep until it is awoken or the sleep times out. The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>Let <var>v</var> be ? <emu-xref aoid="ToInt32"><a href="https://tc39.github.io/ecma262/#sec-toint32">ToInt32</a></emu-xref>(<var>value</var>).</li><li>If <var>timeout</var> is not provided or is <emu-val>undefined</emu-val> then let <var>t</var> be <emu-val>+∞</emu-val>.  Otherwise:<ol><li>Let <var>q</var> be ? <emu-xref aoid="ToNumber"><a href="https://tc39.github.io/ecma262/#sec-tonumber">ToNumber</a></emu-xref>(<var>timeout</var>).</li><li>If <var>q</var> is <emu-val>NaN</emu-val> then let <var>t</var> be <emu-val>+∞</emu-val>, otherwise let <var>t</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(0, <var>q</var>).</li></ol></li><li>Let <var>B</var> be <emu-xref aoid="AgentCanSuspend"><a href="#Atomics.AgentCanSuspend">AgentCanSuspend</a></emu-xref>().</li><li>If <var>B</var> is <emu-val>false</emu-val> then throw a <emu-val>TypeError</emu-val> exception.</li><li>Let <var>bufferVal</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="GetWaiterList"><a href="#GetWaiterList">GetWaiterList</a></emu-xref>(<var>block</var>, <var>indexedPosition</var>).</li><li>Perform <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Let <var>w</var> be Atomics.load(<var>typedArray</var>, <var>i</var>).</li><li>If <var>v</var> does not equal <var>w</var> then<ol><li>Perform <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Return the string <code>"not-equal"</code>.</li></ol></li><li>Let <var>W</var> be <emu-xref aoid="AgentSignifier"><a href="#Atomics.AgentSignifier">AgentSignifier</a></emu-xref>().</li><li>Perform <emu-xref aoid="AddWaiter"><a href="#Atomics.AddWaiter">AddWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</li><li>Let awoken be <emu-xref aoid="Suspend"><a href="#Atomics.Suspend">Suspend</a></emu-xref>(<var>WL</var>, <var>W</var>, <var>t</var>).</li><li>Perform <emu-xref aoid="RemoveWaiter"><a href="#Atomics.RemoveWaiter">RemoveWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</li><li>Perform <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>If awoken is <emu-val>true</emu-val> then return the string <code>"ok"</code>.</li><li>Return the string <code>"timed-out"</code>.
      </li></ol></emu-alg>

    </emu-clause>

    <emu-clause id="Atomics.wake">
      <h1><span class="secnum">6.3.3.11</span>Atomics.wake( <var>typedArray</var>, <var>index</var>, <var>count</var> )<span class="utils"><span class="anchor"><a href="#Atomics.wake">#</a></span></span></h1>
      <p>Atomics.wake wakes up some agents that are sleeping in the wait queue.  The following steps are taken:</p>
      <emu-alg><ol><li>Let <var>buffer</var> be ? <emu-xref aoid="ValidateSharedIntegerTypedArray"><a href="#Atomics.ValidateSharedIntegerTypedArray">ValidateSharedIntegerTypedArray</a></emu-xref>(<var>typedArray</var>, <emu-val>true</emu-val>).</li><li>Let <var>i</var> be ? <emu-xref aoid="ValidateAtomicAccess"><a href="#Atomics.ValidateAtomicAccess">ValidateAtomicAccess</a></emu-xref>(<var>typedArray</var>, <var>index</var>).</li><li>If <var>count</var> is not provided or is <emu-val>undefined</emu-val> then let <var>c</var> be <emu-val>+∞</emu-val>.  Otherwise:<ol><li>Let <var>tmp</var> be ? <emu-xref aoid="ToInteger"><a href="https://tc39.github.io/ecma262/#sec-tointeger">ToInteger</a></emu-xref>(<var>count</var>).</li><li>Let <var>c</var> be <emu-xref aoid="max"><a href="https://tc39.github.io/ecma262/#sec-algorithm-conventions">max</a></emu-xref>(<emu-val>+0</emu-val>, <var>tmp</var>).</li></ol></li><li>Let <var>bufferVal</var> be <var>buffer</var>.[[ArrayBufferData]].</li><li>Let <var>arrayTypeName</var> be <var>typedArray</var>.[[TypedArrayName]].</li><li>Let <var>offset</var> be <var>typedArray</var>.[[ByteOffset]].</li><li>Let <var>indexedPosition</var> be (<var>i</var> × 4) + <var>offset</var>.</li><li>Let <var>WL</var> be <emu-xref aoid="GetWaiterList"><a href="#GetWaiterList">GetWaiterList</a></emu-xref>(<var>block</var>, <var>indexedPosition</var>).</li><li>Let <var>n</var> be 0.</li><li>Perform <emu-xref aoid="EnterCriticalSection"><a href="#EnterCriticalSection">EnterCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Let <var>S</var> be <emu-xref aoid="RemoveWaiters"><a href="#Atomics.RemoveWaiters">RemoveWaiters</a></emu-xref>(<var>WL</var>, <var>c</var>).</li><li>While <var>S</var> is not the empty list:<ol><li>Let <var>W</var> be the first agent in <var>S</var>.</li><li>Remove <var>W</var> from the front of <var>S</var>.</li><li>Perform <emu-xref aoid="WakeWaiter"><a href="#Atomics.WakeWaiter">WakeWaiter</a></emu-xref>(<var>WL</var>, <var>W</var>).</li><li>Add 1 to <var>n</var>.</li></ol></li><li>Perform <emu-xref aoid="LeaveCriticalSection"><a href="#LeaveCriticalSection">LeaveCriticalSection</a></emu-xref>(<var>WL</var>).</li><li>Return <var>n</var>.
      </li></ol></emu-alg>
    </emu-clause>

    <emu-clause id="Atomics.xor">
      <h1><span class="secnum">6.3.3.12</span>Atomics.xor( <var>typedArray</var>, <var>index</var>, <var>value</var> )<span class="utils"><span class="anchor"><a href="#Atomics.xor">#</a></span></span></h1>
      <p>Let <code>xor</code> denote a semantic function of two <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values arguments that applies the bitwise-xor operation element-wise to the two arguments and returns a <emu-xref href="#sec-list-and-record-specification-type"><a href="https://tc39.github.io/ecma262/#sec-list-and-record-specification-type">List</a></emu-xref> of byte values corresponding to the result of that operation.</p>
      <p>The following steps are taken:</p>
      <emu-alg><ol><li>Return <emu-xref aoid="AtomicReadModifyWrite"><a href="#Atomics.ReadModifyWrite">AtomicReadModifyWrite</a></emu-xref>(<var>typedArray</var>, <var>index</var>, <var>value</var>, <code>xor</code>).
      </li></ol></emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="CompilerTransforms">
    <h1><span class="secnum">6.3.4</span>Compiler Transform Guidelines<span class="utils"><span class="anchor"><a href="#CompilerTransforms">#</a></span></span></h1>
    <p>Given a host-defined notion of observable behavior of programs, the following restrictions apply to compiler transforms for non-atomics operations.</p>

    <ul>
      <li>An API call introducing a single <emu-xref href="#MemoryModel.Fundamentals"><a href="#MemoryModel.Fundamentals">Shared Data Block event</a></emu-xref> that affects observable behavior cannot be transformed into API calls introducing multiple <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> events.
      
      </li><li>API calls introducing WriteSharedMemory or ReadModifyWriteSharedMemory events that affect observable behavior may not have their ranges narrowed.
      
      </li><li>API calls introducing WriteSharedMemory or ReadModifyWriteSharedMemory events that affect observable behavior may not be removed.
      
      </li><li>API calls introducing WriteSharedMemory or ReadModifyWriteSharedMemory events that both affect observable behavior and would not have otherwise arisen may not be introduced.
    
    </li></ul>

    <emu-note><span class="note">Note 1</span>
      <p>API calls introducing <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> events may be introduced, elided, or merged if they do not affect observable behavior of the program. For example, nonbinding prefetches of cache lines, assuming correctness of invalidations, are allowed. Contrastingly, rematerializing an observable read is not. For example, the following two programs are not equivalent.</p>

      <pre>let x = M[a]; if (x) observe(x);</pre>

      <p>and</p>

      <pre>if (M[a]) observe(M[a]);</pre>
    </emu-note>

    <p>The following additional restrictions apply to compiler transforms for atomic operations.</p>

    <ul>
      <li>API calls introducing <code>"SeqCst"</code> events that affect observable behavior may not be reordered.
    
    </li></ul>

    <p>The following additional restriction apply to compiler transforms for <emu-xref aoid="data race free"><a href="#MemoryModel.DRF">data race free</a></emu-xref> programs.</p>

    <ul>
      <li>API calls introducing <emu-xref href="#DataTypesValues.SpecTypes.DataBlocks"><a href="#DataTypesValues.SpecTypes.DataBlocks">Shared Data Block</a></emu-xref> events that do not affect observable behavior may not be transformed to API calls that result in shared memory events that affect observable behavior.
    
    </li></ul>

    <emu-note><span class="note">Note 2</span>
      <p>(Spec draft note): This proviso is intended to prohibit transforms that leak information.</p>
    </emu-note>
  </emu-clause>

  <emu-clause id="Codegen">
    <h1><span class="secnum">6.3.5</span>Code Generation Guidelines<span class="utils"><span class="anchor"><a href="#Codegen">#</a></span></span></h1>
    <p>For architectures with memory models no weaker than those of ARM or Power, non-atomic stores and loads may be compiled to bare stores and loads on the target architecture. Atomic stores and loads may be compiled down to instructions that guarantee sequential consistency. If no such instructions exist, memory barriers are to be employed, such as placing barriers on both sides of a bare store or load. Read-modify-write operations may be compiled to read-modify-write instructions on the target architectrue, such as <code>LOCK</code>-prefixed instructions on x86 and load-link/store-conditional instructions on ARM.</p>
  </emu-clause>
</emu-clause>

<emu-clause id="WebBrowserEmbedding">
  <h1><span class="secnum">6.4</span>Web browser embedding (informative)<span class="utils"><span class="anchor"><a href="#WebBrowserEmbedding">#</a></span></span></h1>

  <p>This section outlines how the Shared Memory and Atomics
    specification fits into the current web ecosystem with the minimum
    amount of change to that ecosystem.  This section is not part of
    the proposal, it is informative only.</p>

  <p>In a web browser an  <em>agent</em> is an HTML  <em>event
    loop</em> <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">[here]</a>.
    The event loop is realized as either a main thread (which may be
    shared among tabs, as it is in Firefox) or some type of worker
    thread.  The event loops are running jobs in the sense of ES262,
    and the forward-progress requirement of this specification
    (section&nbsp;3.1.1) is generally met as long as each agent has
    its own dedicated operating system thread or shared-thread agents
    can't block.</p>

  <p>Browsers will typically let agents that run on the browser's
    main thread have [[CanBlock]] equal to <emu-val>false</emu-val>, to prevent blocking the
    UI and to allow the main thread to do work on behalf of other
    threads.</p>

  <p>Normal ("dedicated") <code>Worker</code>s must be supported as agents for
    this proposal to make much sense.</p>

  <p>Memory will be shared among agents by using <code>postMessage</code> to
    transmit SharedArrayBuffer objects or TypedArray objects that
    have SharedArrayBuffer buffers; this requires an extension to
    the Structured Clone mechanism.  There is agreement on the general
    syntax and semantics for that extension.</p>

  <p>Agent-to-agent communication extends the <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> relation
    of the program, as follows:</p>

  <ul>
    <li>The call to the <code>Worker</code> constructor in the parent
      <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> the execution of the main script in the worker. 

    </li><li>(Worker termination is not directly observable in current
      browsers, but this is a moot point; see below.) 

    </li><li>A <code>postMessage</code> to another agent <emu-xref aoid="synchronizes-with"><a href="#MemoryModel.SynchronizesWith">synchronizes-with</a></emu-xref> the event
      that fires in the agent.
 
 </li></ul>

  <p>So long as the browser does not allow a <code>ServiceWorker</code> or
    <code>SharedWorker</code> ("non-page worker") to share memory with a <code>Worker</code>
    it will not violate the suspend/wake cohort rule of this
    specification (section&nbsp;3.3).  The restriction on sharing
    memory can be implemented in the extension to the Structured Clone
    mechanism.  For example, a non-page worker may simply not be
    allowed to receive shared memory (leading to a null value or an
    error signal).  There is not yet any agreement on this point, but
    it is clear that the restriction must be on the receiving side of
    the communication, as the sender may be sending on a <code>MessagePort</code>
    that is not yet connected, but may in the future be connected to
    either a valid or invalid recipient.</p>

  <p>At the moment, I believe dedicated workers are in the same
    process as their owning tab in all browsers, so if the process
    crashes then the workers will crash too.  I also don't know any
    reason a browser should forcibly terminate a worker except when a
    tab is closed.  In sum, the termination signaling requirement of
    this specification (section&nbsp;3.3) is probably met by existing
    browsers.</p>

  <p>The web platform should evolve to serve the shared memory use
    case better: by incorporating inspectable worker state and worker
    lifecycle events, and by tightening the wording in the HTML spec
    (currently the browser is allowed to kill a worker at any time for
    any reason, which is not quite what we want).  WebIDL should
    evolve to allow Web APIs to be described as to when they can and
    cannot receive shared memory parameters.  However, only an
    extension to the Structured Clone algorithm is needed to support
    the Shared Memory and Atomics specification in practice on current
    browsers.</p>

</emu-clause>
</emu-clause><emu-annex id="sec-copyright-and-software-license">
      <h1><span class="secnum">A</span>Copyright &amp; Software License<span class="utils"><span class="anchor"><a href="#sec-copyright-and-software-license">#</a></span></span></h1>
      
      <h2>Copyright Notice</h2>
      <p>© 2016 Mozilla, Inc.</p>

      <h2>Software License</h2>
      <p>All Software contained in this document ("Software") is protected by copyright and is being made available under the "BSD License", included below. This Software may be subject to third party rights (rights from parties other than Ecma International), including patent rights, and no licenses under such third party rights are granted under this license even if the third party concerned is a member of Ecma International. SEE THE ECMA CODE OF CONDUCT IN PATENT MATTERS AVAILABLE AT http://www.ecma-international.org/memento/codeofconduct.htm FOR INFORMATION REGARDING THE LICENSING OF PATENT CLAIMS THAT ARE REQUIRED TO IMPLEMENT ECMA INTERNATIONAL STANDARDS.</p>

<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>

<ol>
  <li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
  <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
  <li>Neither the name of the authors nor Ecma International may be used to endorse or promote products derived from this software without specific prior written permission.</li>
</ol>

<p>THIS SOFTWARE IS PROVIDED BY THE ECMA INTERNATIONAL "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL ECMA INTERNATIONAL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </emu-annex></body>